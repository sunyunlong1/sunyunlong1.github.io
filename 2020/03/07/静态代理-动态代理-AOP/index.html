<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Gavin"><link rel="alternative" href="/atom.xml" title="孙云龙的技术博客" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>静态代理/动态代理/AOP - 孙云龙的技术博客</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script></head><body style="opacity:0"><header class="head"><h1 class="head-title u-fl"><a href="/">孙云龙的技术博客</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/archives">目录</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"><time class="post__time" datetime="2020-03-07T09:04:35.000Z">2020 - 03 - 07 17:04:35</time><h1 class="post__title"><a href="/2020/03/07/静态代理-动态代理-AOP/">静态代理/动态代理/AOP</a></h1><div class="post__main echo"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">本文是看过的一篇文章做的记录</span><br><span class="line">Java 代理模式实现方式，主要有如下五种方法</span><br><span class="line">静态代理，工程师编辑代理类代码，实现代理模式；在编译期就生成了代理类。</span><br><span class="line">基于 JDK 实现动态代理，通过jdk提供的工具方法Proxy.newProxyInstance动态构建全新的代理类(继承Proxy类，并持有InvocationHandler接口引用 )字节码文件并实例化对象返回。(jdk动态代理是由java内部的反射机制来实例化代理对象，并代理的调用委托类方法)</span><br><span class="line">基于CGlib 动态代理模式 基于继承被代理类生成代理子类，不用实现接口。只需要被代理类是非final 类即可。(cglib动态代理底层是借助asm字节码技术</span><br><span class="line">基于 Aspectj 实现动态代理（修改目标类的字节，织入代理的字节，在程序编译的时候 插入动态代理的字节码，不会生成全新的Class ）</span><br><span class="line">基于 instrumentation 实现动态代理（修改目标类的字节码、类装载的时候动态拦截去修改，基于javaagent） -javaagent:spring-instrument-4.3.8.RELEASE.jar （类装载的时候 插入动态代理的字节码，不会生成全新的Class ）</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Notes</span><br><span class="line">委托类 即指的是代理模式中的被代理对象</span><br><span class="line">代理类 指的是生成的代表委托类的一个角色</span><br><span class="line">静态代理实现</span><br><span class="line">静态代理是代理类在编译期间就创建好了，不是编译器生成的代理类，而是手动创建的类。在编译时就已经将接口，被代理类，代理类等确定下来。，软件设计中所指的代理一般是指静态代理，也就是在代码中显式指定的代理。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">实现步骤</span><br><span class="line">委托类和代理类之间的约束接口Cat</span><br><span class="line">约束接口实现类 Lion，实现 Cat 接口，委托角色</span><br><span class="line">代理类实现 FeederProxy，实现Cat 接口，并含有一个 Cat接口引用属性。 代理角色，代理 cat接口属性引用实例的行为并可以新增公共逻辑</span><br><span class="line">Cat接口</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">package org.vincent.proxy.staticproxy;/**</span><br><span class="line">* @author PengRong</span><br><span class="line">* @package org.vincent.proxy.staticproxy</span><br><span class="line">* @date 2018/12/15 - 17:12</span><br><span class="line">* @ProjectName JavaAopLearning</span><br><span class="line">* @Description: 静态代理类接口, 委托类和代理类都需要实现的接口规范。</span><br><span class="line">* 定义了一个猫科动物的两个行为接口，吃东西，奔跑。</span><br><span class="line">* 作为代理类 和委托类之间的约束接口</span><br><span class="line">*/public interface Cat &#123;    public String eatFood(String foodName);    public boolean running();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">委托类 Lion</span><br><span class="line">package org.vincent.proxy.staticproxy;/**</span><br><span class="line">* @author PengRong</span><br><span class="line">* @package org.vincent.proxy.staticproxy</span><br><span class="line">* @date 2018/12/15 - 17:15</span><br><span class="line">* @ProjectName JavaAopLearning</span><br><span class="line">* @Description: 狮子 实现了猫科动物接口Cat， 并实现了具体的行为。作为委托类实现</span><br><span class="line">*/public class Lion implements Cat &#123;    private String name;    private int runningSpeed;    public String getName() &#123;        return name;</span><br><span class="line">   &#125;    public void setName(String name) &#123;        this.name = name;</span><br><span class="line">   &#125;    public int getRunningSpeed() &#123;        return runningSpeed;</span><br><span class="line">   &#125;    public void setRunningSpeed(int runningSpeed) &#123;        this.runningSpeed = runningSpeed;</span><br><span class="line">   &#125;    public Lion() &#123;</span><br><span class="line">   &#125;    @Override</span><br><span class="line">   public String eatFood(String foodName) &#123;</span><br><span class="line">       String eat = this.name + &quot; Lion eat food. foodName = &quot; + foodName;</span><br><span class="line">       System.out.println(eat);        return eat;</span><br><span class="line">   &#125;    @Override</span><br><span class="line">   public boolean running() &#123;</span><br><span class="line">       System.out.println(this.name + &quot; Lion is running . Speed :&quot; + this.runningSpeed);        return false;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">代理类角色(FeederProxy)</span><br><span class="line">package org.vincent.proxy.staticproxy;/**</span><br><span class="line">* @author PengRong</span><br><span class="line">* @package org.vincent.proxy.staticproxy</span><br><span class="line">* @date 2018/12/15 - 17:19</span><br><span class="line">* @ProjectName JavaAopLearning</span><br><span class="line">* @Description: 饲养员 实现Cat接口，作为静态代理类实现。代理狮子的行为。</span><br><span class="line">* 代理类中可以新增一些其他行为，在实践中主要做的是参数校验的功能。</span><br><span class="line">*/public class FeederProxy implements Cat &#123;    private Cat cat;    public FeederProxy()&#123;&#125;    public FeederProxy(Cat cat) &#123;        if (cat instanceof Cat) &#123;            this.cat = cat;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;    public void setCat(Cat cat) &#123;        if (cat instanceof Cat) &#123;            this.cat = cat;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;    @Override</span><br><span class="line">   public String eatFood(String foodName) &#123;</span><br><span class="line">       System.out.println(&quot;proxy Lion exec eatFood &quot;);        return cat.eatFood(foodName);</span><br><span class="line">   &#125;    @Override</span><br><span class="line">   public boolean running() &#123;</span><br><span class="line">       System.out.println(&quot;proxy Lion exec running.&quot;);        return cat.running();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">静态代理类测试</span><br><span class="line">package org.vincent.proxy;import org.vincent.proxy.staticproxy.Cat;import org.vincent.proxy.staticproxy.FeederProxy;import org.vincent.proxy.staticproxy.Lion;/**</span><br><span class="line">* @author PengRong</span><br><span class="line">* @package org.vincent.proxy</span><br><span class="line">* @date 2018/12/15 - 18:31</span><br><span class="line">* @ProjectName JavaAopLearning</span><br><span class="line">* @Description: 静态代理类测试</span><br><span class="line">*/public class staticProxyTest &#123;    public static void main(String[] args) &#123;</span><br><span class="line">       Lion lion = new Lion();</span><br><span class="line">       lion.setName(&quot;狮子 小王&quot;);</span><br><span class="line">       lion.setRunningSpeed(100);        /**</span><br><span class="line">        * new 静态代理类，静态代理类在编译前已经创建好了，和动态代理的最大区别点</span><br><span class="line">        */</span><br><span class="line">       Cat proxy = new FeederProxy(lion);       System.out.println(Thread.currentThread().getName()+&quot; -- &quot; + proxy.eatFood(&quot;水牛&quot;));</span><br><span class="line">       proxy.running();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">静态代理很好的诠释了代理设计模式，代理模式最主要的就是有一个公共接口（Cat），一个委托类（Lion），一个代理类（FeederProxy）,代理类持有委托类的实例，代为执行具体类实例方法。 上面说到，代理模式就是在访问实际对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。这里的间接性就是指客户端不直接调用实际对象的方法，客户端依赖公共接口并使用代理类。 那么我们在代理过程中就可以加上一些其他用途。 就这个例子来说在 eatFood方法调用中，代理类在调用具体实现类之前添加System.out.println(&quot;proxy Lion exec eatFood &quot;);语句 就是添加间接性带来的收益。代理类存在的意义是为了增加一些公共的逻辑代码。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">动态代理类(基于接口实现)</span><br><span class="line">静态代理是代理类在代码运行前已经创建好，并生成class文件；动态代理类 是代理类在程序运行时创建的代理模式。</span><br><span class="line"></span><br><span class="line">动态代理类的代理类并不是在Java代码中定义的，而是在运行时根据我们在Java代码中的“指示”动态生成的。相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。 想想你有100个静态代理类，现在有一个需求，每个代理类都需要新增一个处理逻辑，你需要打开100个代理类在每个代理方法里面新增处理逻辑吗？ 有或者代理类有5个方法，每个方法都需要新增一个处理逻辑， 你需要在每个方法都手动新增处理逻辑吗？ 想想就挺无趣的。动态代理类帮你一键搞定。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">动态代理类涉及角色</span><br><span class="line">委托类和代理类实现的公共接口(Person.java)</span><br><span class="line">实现公共接口的具体委托类(SoftwareEngineer.java)</span><br><span class="line">InvocationHandler接口被Proxy类回调处理，一般实现 InvocationHandler 接口的类具有委托类引用，接口方法 invoke 中添加公共代码并调用委托类的接口方法。(PersonInvocationHandler.java)</span><br><span class="line">JDK提供生成动态代理类的核心类Proxy ( JDK 提供的Proxy.java)</span><br><span class="line">基于JDK技术 动态代理类技术核心 Proxy类和一个 InvocationHandler 接口</span><br><span class="line">java的java.lang.reflect包下提供了Proxy类和一个 InvocationHandler 接口，这个类Proxy定义了生成JDK动态代理类的方法 getProxyClass(ClassLoader loader,Class&lt;?&gt;... interfaces)生成动态代理类,返回class实例代表一个class文件。可以保存该 class 文件查看jdk生成的代理类文件长什么样</span><br><span class="line"></span><br><span class="line">该生成的动态代理类继承Proxy类，(重要特性) ，并实现公共接口。</span><br><span class="line"></span><br><span class="line">InvocationHandler这个接口 是被动态代理类回调的接口，我们所有需要增加的针对委托类的统一处理逻辑都增加到invoke 方法里面在调用委托类接口方法之前或之后 结束战斗。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">案例</span><br><span class="line">公共接口</span><br><span class="line">package org.vincent.proxy.dynamicproxy;/**</span><br><span class="line">* Created by PengRong on 2018/12/25.</span><br><span class="line">* 创建Person 接口 用于定义 委托类和代理类之间的约束行为</span><br><span class="line">*/public interface Person&#123;    /**</span><br><span class="line">    *</span><br><span class="line">    * @param name 人名</span><br><span class="line">    * @param dst 工作目的地</span><br><span class="line">    */</span><br><span class="line">   void goWorking(String name, String dst);    /**</span><br><span class="line">    * 获取名称</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   String getName( );    /**</span><br><span class="line">    * 设置名称</span><br><span class="line">    * @param name</span><br><span class="line">    */</span><br><span class="line">   void  setName(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">具体实现类，等下被委托，被代理的类 SoftwareEngineer.java</span><br><span class="line">package org.vincent.proxy.dynamicproxy;/**</span><br><span class="line">* Created by PengRong on 2018/12/25.</span><br><span class="line">* 动态代理委托类实现， 实现接口 Person。 被动态生成的代理类代理</span><br><span class="line">*/public class SoftwareEngineer implements Person&#123;    public  SoftwareEngineer()&#123;&#125;    public  SoftwareEngineer(String name)&#123;        this.name=name;</span><br><span class="line">   &#125;    private  String name;    public String getName() &#123;        return name;</span><br><span class="line">   &#125;    public void setName(String name) &#123;        this.name = name;</span><br><span class="line">   &#125;    @Override</span><br><span class="line">   public void goWorking(String name, String dst) &#123;</span><br><span class="line">       System.out.println(&quot;name =&quot;+name+&quot; ， 去 &quot;+dst +&quot; 工作&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">InvocationHandler 接口实现 PersonInvocationHandler.java</span><br><span class="line">package org.vincent.proxy.dynamicproxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.util.Arrays;/**</span><br><span class="line">* Created by PengRong on 2018/12/25.</span><br><span class="line">* PersonInvocationHandler 类 实现InvocationHandler接口，这个类中持有一个被代理对象(委托类)的实例target。该类别JDK Proxy类回调</span><br><span class="line">* InvocationHandler 接口中有一个invoke方法，当一个代理实例的方法被调用时，代理方法将被编码并分发到 InvocationHandler接口的invoke方法执行。</span><br><span class="line">*/public class PersonInvocationHandler&lt;T&gt; implements InvocationHandler &#123;    /**</span><br><span class="line">    * 被代理对象引用，invoke 方法里面method 需要使用这个 被代理对象</span><br><span class="line">    */</span><br><span class="line">   T target;    public PersonInvocationHandler(T target) &#123;        this.target = target;</span><br><span class="line">   &#125;    /**</span><br><span class="line">    * 在</span><br><span class="line">    * @param proxy  代表动态生成的 动态代理 对象实例</span><br><span class="line">    * @param method 代表被调用委托类的接口方法，和生成的代理类实例调用的接口方法是一致的，它对应的Method 实例</span><br><span class="line">    * @param args   代表调用接口方法对应的Object参数数组，如果接口是无参，则为null； 对于原始数据类型返回的他的包装类型。</span><br><span class="line">    * @return</span><br><span class="line">    * @throws Throwable</span><br><span class="line">    */</span><br><span class="line">   @Override</span><br><span class="line">   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;        /**</span><br><span class="line">        * 在转调具体目标对象之前，可以执行一些功能处理</span><br><span class="line">        */</span><br><span class="line">       System.out.println(&quot;被动态代理类回调执行, 代理类 proxyClass =&quot;+proxy.getClass()+&quot; 方法名: &quot; + method.getName() + &quot;方法. 方法返回类型：&quot;+method.getReturnType()</span><br><span class="line">       +&quot; 接口方法入参数组: &quot;+(args ==null ? &quot;null&quot; : Arrays.toString(args)));        /**</span><br><span class="line">        * 代理过程中插入监测方法,计算该方法耗时</span><br><span class="line">        */</span><br><span class="line">       MonitorUtil.start();</span><br><span class="line">       Thread.sleep(1);        /** 调用呗代理对象的真实方法，*/</span><br><span class="line">       Object result = method.invoke(target, args);</span><br><span class="line">       MonitorUtil.finish(method.getName());        return result;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PersonInvocationHandler invoke 方法中添加的公共代码，这里简单以统计方法执行时间为逻辑</span><br><span class="line">package org.vincent.proxy.dynamicproxy;/**</span><br><span class="line">* Created by PengRong on 2018/12/25.</span><br><span class="line">* 方法用时监控类</span><br><span class="line">*/public class MonitorUtil &#123;    private static ThreadLocal&lt;Long&gt; tl = new ThreadLocal&lt;&gt;();    public static void start() &#123;</span><br><span class="line">       tl.set(System.currentTimeMillis());</span><br><span class="line">   &#125;    /**</span><br><span class="line">    * 结束时打印耗时</span><br><span class="line">    * @param methodName 方法名</span><br><span class="line">    */</span><br><span class="line">   public static void finish(String methodName) &#123;        long finishTime = System.currentTimeMillis();</span><br><span class="line">       System.out.println(methodName + &quot;方法执行耗时&quot; + (finishTime - tl.get()) + &quot;ms&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">最后的是 怎么创建代理类</span><br><span class="line">package org.vincent.proxy.jdkdynamicProxy;import org.vincent.proxy.dynamicproxy.Person;import org.vincent.proxy.dynamicproxy.PersonInvocationHandler;import org.vincent.proxy.dynamicproxy.SoftwareEngineer;import sun.misc.ProxyGenerator;import java.io.FileOutputStream;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;import java.nio.file.Path;import java.nio.file.Paths;import java.util.Arrays;import java.util.Properties;/**</span><br><span class="line">* 动态代理类测试</span><br><span class="line">* Created by PengRong on 2018/12/25.</span><br><span class="line">*/public class JdkDynamicProxyTest &#123;    public static void main(String[] args) throws Exception &#123;        // 打开保存JDK动态代理生成的类文件</span><br><span class="line">       saveGeneratedJdkProxyFiles();        /**</span><br><span class="line">        * 第一种方法: 通过 Proxy.newProxyInstance 方法 获取代理对象</span><br><span class="line">        */</span><br><span class="line">       System.out.println(&quot;-------------------第一种创建代理类方法--------------&quot;);        //创建一个实例对象，这个对象是被代理的对象，委托类</span><br><span class="line">       Person person = new SoftwareEngineer(&quot;Vincent&quot;);        //创建一个与代理类相关联的InvocationHandler,每一个代理类都有一个关联的 InvocationHandler，并将代理类引用传递进去</span><br><span class="line">       InvocationHandler Handler = new PersonInvocationHandler&lt;&gt;(person);        //创建一个 代理对象 personProxy 来代理 person，创建的代理对象的每个执行方法都会被替换执行Invocation接口中的invoke方法</span><br><span class="line">       Person personProxy = (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), new Class&lt;?&gt;[]&#123;Person.class&#125;, Handler);        /** 代理类信息 */</span><br><span class="line">       System.out.println(&quot;package = &quot; + personProxy.getClass().getPackage() + &quot; SimpleName = &quot; + personProxy.getClass().getSimpleName() + &quot; name =&quot; + personProxy.getClass().getName() + &quot; CanonicalName = &quot; +                &quot;&quot; + personProxy.getClass().getCanonicalName() + &quot; 实现的接口 Interfaces = &quot; + Arrays.toString(personProxy.getClass().getInterfaces()) +                &quot; superClass = &quot; + personProxy.getClass().getSuperclass() + &quot; methods =&quot; + Arrays.toString(personProxy.getClass().getMethods()));        // 通过 代理类 执行 委托类的代码逻辑</span><br><span class="line">       personProxy.goWorking(personProxy.getName(), &quot;深圳&quot;);       System.out.println(&quot;-------------------第二种创建代理类方法--------------&quot;);        /**</span><br><span class="line">        *  动态代理对象步骤</span><br><span class="line">        *      1、 创建一个与代理对象相关联的 InvocationHandler，以及真实的委托类实例</span><br><span class="line">        *      2、Proxy类的getProxyClass静态方法生成一个动态代理类stuProxyClass，该类继承Proxy类，实现 Person.java接口；JDK动态代理的特点是代理类必须继承Proxy类</span><br><span class="line">        *      3、通过代理类 proxyClass 获得他的带InvocationHandler 接口的构造函数 ProxyConstructor</span><br><span class="line">        *      4、通过 构造函数实例 ProxyConstructor 实例化一个代理对象，并将  InvocationHandler 接口实例传递给代理类。</span><br><span class="line">        */</span><br><span class="line">       // 1、创建 InvocationHandler 实例并设置代理的目标类对象</span><br><span class="line">       Person persontwo = new SoftwareEngineer(&quot;Vincent&quot;);</span><br><span class="line">       InvocationHandler Handlertwo = new PersonInvocationHandler&lt;&gt;(persontwo);        // 2 创建代理类,是一个字节码文件, 把 proxyClass 保存起来就能看到 他继承Proxy 类，实现Person接口</span><br><span class="line">       Class&lt;?&gt; proxyClass = Proxy.getProxyClass(Person.class.getClassLoader(), new Class&lt;?&gt;[]&#123;Person.class&#125;);        /** 代理类信息 */</span><br><span class="line">       System.out.println(&quot;package = &quot; + proxyClass.getPackage() + &quot; SimpleName = &quot; + proxyClass.getSimpleName() + &quot; name =&quot; + proxyClass.getName() + &quot; CanonicalName = &quot; +                &quot;&quot; + proxyClass.getCanonicalName() + &quot; 实现的接口 Interfaces = &quot; + Arrays.toString(proxyClass.getInterfaces()) +                &quot; superClass = &quot; + proxyClass.getSuperclass() + &quot; methods =&quot; + Arrays.toString(proxyClass.getMethods()));        // 3、  通过 proxyClass 获得 一个带有InvocationHandler参数的构造器constructor</span><br><span class="line">       Constructor&lt;?&gt; ProxyConstructor = proxyClass.getConstructor(InvocationHandler.class);        // 4、通过构造器创建一个  动态代理类 实例</span><br><span class="line">       Person stuProxy = (Person) ProxyConstructor.newInstance(Handlertwo);        /** 检测生成的类是否是代理类 */</span><br><span class="line">       System.out.println(&quot;stuProxy isProxy &quot;+Proxy.isProxyClass(stuProxy.getClass()));        /** 获取 代理类关联的 InvocationHandler 是哪个*/</span><br><span class="line">       InvocationHandler handlerObject = Proxy.getInvocationHandler(stuProxy);</span><br><span class="line">       System.out.println(handlerObject.getClass().getName());</span><br><span class="line">       stuProxy.goWorking(stuProxy.getName(), &quot;广州&quot;);        // 保存代理類</span><br><span class="line">       saveClass(&quot;$PersonProxy0&quot;, proxyClass.getInterfaces(), &quot;D:/123/&quot;);</span><br><span class="line">   &#125;    /**</span><br><span class="line">    * 生成代理类 class 并保持到文件中</span><br><span class="line">    *</span><br><span class="line">    * @param className  生成的代理类名称</span><br><span class="line">    * @param interfaces 代理类需要实现的接口</span><br><span class="line">    * @param pathdir    代理类保存的目录路径,以目录分隔符结尾</span><br><span class="line">    */</span><br><span class="line">   public static void saveClass(String className, Class&lt;?&gt;[] interfaces, String pathdir) &#123;        /**</span><br><span class="line">        * 第一个参数是 代理类 名 。</span><br><span class="line">        * 第二个参数是 代理类需要实现的接口</span><br><span class="line">        */</span><br><span class="line">       byte[] classFile = ProxyGenerator.generateProxyClass(className, interfaces);        /**</span><br><span class="line">        * 如果目录不存在就新建所有子目录</span><br><span class="line">        */</span><br><span class="line">       Path path1 = Paths.get(pathdir);        if (!path1.toFile().exists())&#123;</span><br><span class="line">           path1.toFile().mkdirs();</span><br><span class="line">       &#125;</span><br><span class="line">       String path = pathdir + className + &quot;.class&quot;;        try (FileOutputStream fos = new FileOutputStream(path)) &#123;</span><br><span class="line">           fos.write(classFile);</span><br><span class="line">           fos.flush();</span><br><span class="line">           System.out.println(&quot;代理类class文件写入成功&quot;);</span><br><span class="line">       &#125; catch (Exception e) &#123;</span><br><span class="line">           System.out.println(&quot;写文件错误&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;    /**</span><br><span class="line">    * 设置保存Java动态代理生成的类文件。</span><br><span class="line">    *</span><br><span class="line">    * @throws Exception</span><br><span class="line">    */</span><br><span class="line">   public static void saveGeneratedJdkProxyFiles() throws Exception &#123;</span><br><span class="line">       Field field = System.class.getDeclaredField(&quot;props&quot;);</span><br><span class="line">       field.setAccessible(true);</span><br><span class="line">       Properties props = (Properties) field.get(null);</span><br><span class="line">       props.put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</span><br><span class="line">   &#125;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">解析JDK生成的动态代理类</span><br><span class="line">saveGeneratedJdkProxyFiles方法 打开了存储jdk生成的动态代理类 以 接口方法 goWorking 为例讲解</span><br><span class="line"></span><br><span class="line">//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//package com.sun.proxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;import org.vincent.proxy.dynamicproxy.Person;public final class $Proxy0 extends Proxy implements Person &#123;    private static Method m1;    private static Method m4;    private static Method m3;    private static Method m2;    private static Method m5;    private static Method m0;    public $Proxy0(InvocationHandler var1) throws  &#123;        super(var1);</span><br><span class="line">   &#125;    public final boolean equals(Object var1) throws  &#123;        try &#123;            return ((Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;)).booleanValue();</span><br><span class="line">       &#125; catch (RuntimeException | Error var3) &#123;            throw var3;</span><br><span class="line">       &#125; catch (Throwable var4) &#123;            throw new UndeclaredThrowableException(var4);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;    public final void setName(String var1) throws  &#123;        try &#123;            super.h.invoke(this, m4, new Object[]&#123;var1&#125;);</span><br><span class="line">       &#125; catch (RuntimeException | Error var3) &#123;            throw var3;</span><br><span class="line">       &#125; catch (Throwable var4) &#123;            throw new UndeclaredThrowableException(var4);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;    public final String getName() throws  &#123;        try &#123;            return (String)super.h.invoke(this, m3, (Object[])null);</span><br><span class="line">       &#125; catch (RuntimeException | Error var2) &#123;            throw var2;</span><br><span class="line">       &#125; catch (Throwable var3) &#123;            throw new UndeclaredThrowableException(var3);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;    public final String toString() throws  &#123;        try &#123;            return (String)super.h.invoke(this, m2, (Object[])null);</span><br><span class="line">       &#125; catch (RuntimeException | Error var2) &#123;            throw var2;</span><br><span class="line">       &#125; catch (Throwable var3) &#123;            throw new UndeclaredThrowableException(var3);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;    /**</span><br><span class="line">   * 对接口  goWorking 的调用 转变成   super.h.invoke(this, m5, new Object[]&#123;var1, var2&#125;); 调用。</span><br><span class="line">   * h 就是Proxy.java类的一个 InvocationHandler 接口 属性，</span><br><span class="line">   * 我们在创建 动态代理类实例时候都必须 传一个 InvocationHandler 接口的实例过去。 这里就是刚才我们定义的 PersonInvocationHandler 。</span><br><span class="line">   * 回到过后是不是就回到了 PersonInvocationHandler.invoke方法里面，所以 PersonInvocationHandler 是我们生成的动态代理类的拦截器，拦截所有方法调用。</span><br><span class="line">   */</span><br><span class="line">   public final void goWorking(String var1, String var2) throws  &#123;        try &#123;            super.h.invoke(this, m5, new Object[]&#123;var1, var2&#125;);</span><br><span class="line">       &#125; catch (RuntimeException | Error var4) &#123;            throw var4;</span><br><span class="line">       &#125; catch (Throwable var5) &#123;            throw new UndeclaredThrowableException(var5);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;    public final int hashCode() throws  &#123;        try &#123;            return ((Integer)super.h.invoke(this, m0, (Object[])null)).intValue();</span><br><span class="line">       &#125; catch (RuntimeException | Error var2) &#123;            throw var2;</span><br><span class="line">       &#125; catch (Throwable var3) &#123;            throw new UndeclaredThrowableException(var3);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;/**</span><br><span class="line">* 静态代码块，根据动态代理实现的公共接口类接口方法 获取到所有接口方法 的 Method 实例*/</span><br><span class="line">   static &#123;        try &#123;</span><br><span class="line">           m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[]&#123;Class.forName(&quot;java.lang.Object&quot;)&#125;);</span><br><span class="line">           m4 = Class.forName(&quot;org.vincent.proxy.dynamicproxy.Person&quot;).getMethod(&quot;setName&quot;, new Class[]&#123;Class.forName(&quot;java.lang.String&quot;)&#125;);</span><br><span class="line">           m3 = Class.forName(&quot;org.vincent.proxy.dynamicproxy.Person&quot;).getMethod(&quot;getName&quot;, new Class[0]);</span><br><span class="line">           m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]);</span><br><span class="line">           m5 = Class.forName(&quot;org.vincent.proxy.dynamicproxy.Person&quot;).getMethod(&quot;goWorking&quot;, new Class[]&#123;Class.forName(&quot;java.lang.String&quot;), Class.forName(&quot;java.lang.String&quot;)&#125;);</span><br><span class="line">           m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]);</span><br><span class="line">       &#125; catch (NoSuchMethodException var2) &#123;            throw new NoSuchMethodError(var2.getMessage());</span><br><span class="line">       &#125; catch (ClassNotFoundException var3) &#123;            throw new NoClassDefFoundError(var3.getMessage());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Jdk为我们的生成了一个叫$Proxy0（这个名字后面的0是编号，有多个代理类会一次递增）的代理类，这个类文件时默认不会保存在文件，放在内存中的，我们在创建代理对象时，就是通过反射获得这个类的构造方法，然后创建代理对象实例。通过对这个生成的代理类源码的查看，我们很容易能看出，动态代理实现的具体过程。</span><br><span class="line"></span><br><span class="line">我们可以对 InvocationHandler 看做一个中介类，中介类持有一个被代理对象，被Proxy类回调。在invoke方法中调用了被代理对象的相应方法。通过聚合方式持有被代理对象的引用，把客户端对invoke的调用最终都转为对被代理对象的调用。</span><br><span class="line"></span><br><span class="line">客户端代码通过代理类引用调用接口方法时，通过代理类关联的中介类对象引用来调用中介类对象的invoke方法，从而达到代理执行被代理对象的方法。也就是说，动态代理Proxy类提供了模板实现，对外提供扩展点，外部通过实现InvocationHandler接口将被代理类纳入JDK代理类Proxy。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">一个典型的基于JDK动态代理创建对象过程可分为以下四个步骤：</span><br><span class="line">1、通过实现InvocationHandler接口创建自己的调用处理器 IvocationHandler handler = new InvocationHandlerImpl(...);</span><br><span class="line"></span><br><span class="line">2、通过为Proxy类指定ClassLoader对象和一组interface代理类需要实现的接口，创建动态代理类类文件，默认JDK并不会保存这个文件到文件中；可以保存起来观察生成的代理类结构Class clazz = Proxy.getProxyClass(classLoader,new Class[]&#123;...&#125;);</span><br><span class="line"></span><br><span class="line">3、通过上面新建的代理clazz的反射机制获取动态代理类的一个构造函数，其构造函数入参类型是调用处理器接口(IvocationHandler)类型 Constructor constructor = clazz.getConstructor(new Class[]&#123;InvocationHandler.class&#125;);</span><br><span class="line"></span><br><span class="line">4、通过构造函数实例创建代理类实例，此时需将调用处理器对象作为参数被传入 Interface Proxy = (Interface)constructor.newInstance(new Object[] (handler)); 为了简化对象创建过程，Proxy类中的newInstance工具方法封装了2~4，只需两步即可完成代理对象的创建。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JDK动态代理特点总结</span><br><span class="line">生成的代理类：$Proxy0 extends Proxy implements Person，我们看到代理类继承了Proxy类，Java的继承机制决定了JDK动态代理类们无法实现对 类 的动态代理。所以也就决定了java动态代理只能对接口进行代理，</span><br><span class="line">每个生成的动态代理实例都会关联一个调用处理器对象，可以通过 Proxy 提供的静态方法 getInvocationHandler 去获得代理类实例的调用处理器对象。在代理类实例上调用其代理的接口中所声明的方法时，这些方法最终都会由调用处理器的 invoke 方法执行</span><br><span class="line">代理类的根类 java.lang.Object 中有三个方法也同样会被分派到调用处理器的 invoke 方法执行，它们是 hashCode，equals 和 toString，可能的原因有：一是因为这些方法为 public 且非 final 类型，能够被代理类覆盖； 二是因为这些方法往往呈现出一个类的某种特征属性，具有一定的区分度，所以为了保证代理类与委托类对外的一致性，这三个方法也应该被调用处理器分派到委托类执行。</span><br><span class="line">JDK动态代理不足</span><br><span class="line">JDK动态代理的代理类字节码在创建时，需要实现业务实现类所实现的接口作为参数。如果业务实现类是没有实现接口而是直接定义业务方法的话，就无法使用JDK动态代理了。(JDK动态代理重要特点是代理接口) 并且，如果业务实现类中新增了接口中没有的方法，这些方法是无法被代理的（因为无法被调用）。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">动态代理只能对接口产生代理，不能对类产生代理</span><br><span class="line"></span><br><span class="line">基于CGlib 技术动态代理代理类实现 (基于继承)</span><br><span class="line">Cglib是针对类来实现代理的，他的原理是对代理的目标类生成一个子类，并覆盖其中方法实现增强，因为底层是基于创建被代理类的一个子类，所以它避免了JDK动态代理类的缺陷。</span><br><span class="line"></span><br><span class="line">但因为采用的是继承，所以不能对final修饰的类进行代理。final修饰的类不可继承。</span><br><span class="line"></span><br><span class="line">导入maven 依赖</span><br><span class="line">cglib 是基于asm 字节修改技术。导入 cglib 会间接导入 asm, ant, ant-launcher 三个jar 包。</span><br><span class="line"></span><br><span class="line">&lt;!-- cglib 动态代理依赖 begin --&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;cglib&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;3.2.5&lt;/version&gt;&lt;/dependency&gt;&lt;!-- cglib 动态代理依赖 stop --&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">业务类实现</span><br><span class="line">cglib是针对类来实现代理的，原理是对指定的业务类生成他的一个子类，并覆盖其中的业务方法来实现代理。因为采用的是继承，所以不能对final修饰的类进行代理。</span><br><span class="line"></span><br><span class="line">package org.vincent.proxy.cglibproxy;/**</span><br><span class="line">* @Package: org.vincent.proxy.cglibproxy &lt;br/&gt;</span><br><span class="line">* @Description： Cglib 代理模式中 被代理的委托类 &lt;br/&gt;</span><br><span class="line">* @author: lenovo &lt;br/&gt;</span><br><span class="line">* @Company: PLCC &lt;br/&gt;</span><br><span class="line">* @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line">* @Version: 1.0 &lt;br/&gt;</span><br><span class="line">* @Modified By: &lt;br/&gt;</span><br><span class="line">* @Created by lenovo on 2018/12/26-17:55 &lt;br/&gt;</span><br><span class="line">*/public class Dog &#123;    public String  call() &#123;</span><br><span class="line">       System.out.println(&quot;wang wang wang&quot;);        return &quot;Dog ..&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">方法拦截器 实现 MethodInterceptor 接口</span><br><span class="line">package org.vincent.proxy.cglibproxy;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import java.lang.reflect.Method;/**</span><br><span class="line">* @Package: org.vincent.proxy.cglibproxy &lt;br/&gt;</span><br><span class="line">* @Description： Cglib 方法拦截器,不用依赖被代理业务类的引用。  &lt;br/&gt;</span><br><span class="line">* @author: lenovo &lt;br/&gt;</span><br><span class="line">* @Company: PLCC &lt;br/&gt;</span><br><span class="line">* @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line">* @Version: 1.0 &lt;br/&gt;</span><br><span class="line">* @Modified By: &lt;br/&gt;</span><br><span class="line">* @Created by lenovo on 2018/12/26-17:56 &lt;br/&gt;</span><br><span class="line">*/public class CglibMethodInterceptor implements MethodInterceptor &#123;    /**</span><br><span class="line">    * 用于生成 Cglib 动态代理类工具方法</span><br><span class="line">    * @param target 代表需要 被代理的 委托类的 Class 对象</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   public Object CglibProxyGeneratory(Class target) &#123;        /** 创建cglib 代理类 start */</span><br><span class="line">       // 创建加强器，用来创建动态代理类</span><br><span class="line">       Enhancer enhancer = new Enhancer();        // 为代理类指定需要代理的类，也即是父类</span><br><span class="line">       enhancer.setSuperclass(target);        // 设置方法拦截器回调引用，对于代理类上所有方法的调用，都会调用CallBack，而Callback则需要实现intercept() 方法进行拦截</span><br><span class="line">       enhancer.setCallback(this);        // 获取动态代理类对象并返回</span><br><span class="line">       return enhancer.create();        /** 创建cglib 代理类 end */</span><br><span class="line">   &#125;    /**</span><br><span class="line">    * 功能主要是在调用业务类方法之前 之后添加统计时间的方法逻辑.</span><br><span class="line">    * intercept 因为  具有 MethodProxy proxy 参数的原因 不再需要代理类的引用对象了,直接通过proxy 对象访问被代理对象的方法(这种方式更快)。</span><br><span class="line">    * 当然 也可以通过反射机制，通过 method 引用实例    Object result = method.invoke(target, args); 形式反射调用被代理类方法，</span><br><span class="line">    * target 实例代表被代理类对象引用, 初始化 CglibMethodInterceptor 时候被赋值 。但是Cglib不推荐使用这种方式</span><br><span class="line">    * @param obj    代表Cglib 生成的动态代理类 对象本身</span><br><span class="line">    * @param method 代理类中被拦截的接口方法 Method 实例</span><br><span class="line">    * @param args   接口方法参数</span><br><span class="line">    * @param proxy  用于调用父类真正的业务类方法。可以直接调用被代理类接口方法</span><br><span class="line">    * @return</span><br><span class="line">    * @throws Throwable</span><br><span class="line">    */</span><br><span class="line">   @Override</span><br><span class="line">   public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;</span><br><span class="line">       System.out.println(&quot;before&quot;);</span><br><span class="line">       MonitorUtil.start();</span><br><span class="line">       Object result = proxy.invokeSuper(obj, args);        //Object result = method.invoke(target, args);</span><br><span class="line">       System.out.println(&quot;after&quot;);</span><br><span class="line">       MonitorUtil.finish(method.getName());        return result;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">一个切面，用于在方法拦截器中intercept 方法中调用真正业务方法之前 之后处理逻辑</span><br><span class="line">package org.vincent.proxy.cglibproxy;/**</span><br><span class="line">* Created by PengRong on 2018/12/25.</span><br><span class="line">* 方法用时监控类,作为一个切面 ，具有两个方法</span><br><span class="line">*/public class MonitorUtil &#123;    private static ThreadLocal&lt;Long&gt; tl = new ThreadLocal&lt;&gt;();    public static void start() &#123;</span><br><span class="line">       tl.set(System.currentTimeMillis());</span><br><span class="line">   &#125;    /**</span><br><span class="line">    * 结束时打印耗时</span><br><span class="line">    * @param methodName 方法名</span><br><span class="line">    */</span><br><span class="line">   public static void finish(String methodName) &#123;        long finishTime = System.currentTimeMillis();</span><br><span class="line">       System.out.println(methodName + &quot;方法执行耗时&quot; + (finishTime - tl.get()) + &quot;ms&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Cglib测试类</span><br><span class="line">package org.vincent.proxy.cglibproxy;import net.sf.cglib.core.DebuggingClassWriter;import net.sf.cglib.proxy.Enhancer;import org.junit.Test;import java.lang.reflect.Field;import java.util.Properties;/**</span><br><span class="line">* @Package: org.vincent.proxy.cglibproxy &lt;br/&gt;</span><br><span class="line">* @Description： TODO &lt;br/&gt;</span><br><span class="line">* @author: lenovo &lt;br/&gt;</span><br><span class="line">* @Company: PLCC &lt;br/&gt;</span><br><span class="line">* @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line">* @Version: 1.0 &lt;br/&gt;</span><br><span class="line">* @Modified By: &lt;br/&gt;</span><br><span class="line">* @Created by lenovo on 2018/12/26-18:05 &lt;br/&gt;</span><br><span class="line">*/public class CglibTest &#123;    @Test</span><br><span class="line">   public void testCglib() throws Exception &#123;       System.out.println(System.getProperty(&quot;user.dir&quot;));        /** 开启 保存cglib生成的动态代理类类文件*/</span><br><span class="line">       saveGeneratedCGlibProxyFiles(System.getProperty(&quot;user.dir&quot;));        /** 第一种方法: 创建cglib 代理类 start */</span><br><span class="line">       // 创建加强器，用来创建动态代理类</span><br><span class="line">       Enhancer enhancer = new Enhancer();        // 为代理类指定需要代理的类，也即是父类</span><br><span class="line">       enhancer.setSuperclass(Dog.class);        // new 一个新的方法拦截器</span><br><span class="line">       CglibMethodInterceptor cglibMethodInterceptor = new CglibMethodInterceptor();        // 设置方法拦截器回调引用，对于代理类上所有方法的调用，都会调用CallBack，而Callback则需要实现intercept() 方法进行拦截</span><br><span class="line">       enhancer.setCallback(cglibMethodInterceptor);        // 获取动态代理类对象并返回</span><br><span class="line">       Dog dog = (Dog) enhancer.create();        /** 创建cglib 代理类 end */</span><br><span class="line">       System.out.println(dog.call());        // 对于上面这几步，可以新增一个工具方法 放置在 CglibMethodInterceptor 里面；也就有了第二种方法</span><br><span class="line">       // new 一个新的方法拦截器，该拦截器还顺带一个用于创建代理类的工具方法。看起来简单很多</span><br><span class="line">       cglibMethodInterceptor = new CglibMethodInterceptor();</span><br><span class="line">       dog = (Dog) cglibMethodInterceptor.CglibProxyGeneratory(Dog.class);</span><br><span class="line">       System.out.println(dog.call());   &#125;    /**</span><br><span class="line">    * 设置保存Cglib代理生成的类文件。</span><br><span class="line">    *</span><br><span class="line">    * @throws Exception</span><br><span class="line">    */</span><br><span class="line">   public void saveGeneratedCGlibProxyFiles(String dir) throws Exception &#123;</span><br><span class="line">       Field field = System.class.getDeclaredField(&quot;props&quot;);</span><br><span class="line">       field.setAccessible(true);</span><br><span class="line">       Properties props = (Properties) field.get(null);</span><br><span class="line">       System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, dir);//dir为保存文件路径</span><br><span class="line">       props.put(&quot;net.sf.cglib.core.DebuggingClassWriter.traceEnabled&quot;, &quot;true&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Cglib 总结</span><br><span class="line">CGlib可以传入接口也可以传入普通的类，接口使用实现的方式,普通类使用会使用继承的方式生成代理类.</span><br><span class="line">由于是继承方式,如果是 static方法,private方法,final方法等描述的方法是不能被代理的</span><br><span class="line">做了方法访问优化，使用建立方法索引的方式避免了传统JDK动态代理需要通过Method方法反射调用.</span><br><span class="line">提供callback 和filter设计，可以灵活地给不同的方法绑定不同的callback。编码更方便灵活。</span><br><span class="line">CGLIB会默认代理Object中equals,toString,hashCode,clone等方法。比JDK代理多了clone。</span><br><span class="line">静态代理 基于JDK动态代理 基于Cglib 动态代理</span><br><span class="line">静态代理是通过在代码中显式编码定义一个业务实现类的代理类，在代理类中对同名的业务方法进行包装，用户通过代理类调用被包装过的业务方法；</span><br><span class="line"></span><br><span class="line">JDK动态代理是通过接口中的方法名，在动态生成的代理类中调用业务实现类的同名方法；</span><br><span class="line"></span><br><span class="line">CGlib动态代理是通过继承业务类，生成的动态代理类是业务类的子类，通过重写业务方法进行代理；</span><br><span class="line"></span><br><span class="line">静态代理在编译时产生class字节码文件，可以直接使用，效率高。动态代理必须实现InvocationHandler接口，通过invoke调用被委托类接口方法是通过反射方式，比较消耗系统性能，但可以减少代理类的数量，使用更灵活。 cglib代理无需实现接口，通过生成类字节码实现代理，比反射稍快，不存在性能问题，但cglib会继承目标对象，需要重写方法，所以目标对象不能为final类。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AOP 实现案例</span><br><span class="line">AOP的源码中用到了两种动态代理来实现拦截切入功能：jdk动态代理和cglib动态代理。两种方法同时存在，各有优劣。 jdk动态代理是由java内部的反射机制来实现的，cglib动态代理底层则是借助asm来实现的。 总的来说，反射机制在生成类的过程中比较高效，执行时候通过反射调用委托类接口方法比较慢；而asm在生成类之后的相关代理类执行过程中比较高效（可以通过将asm生成的类进行缓存，这样解决asm生成类过程低效问题）。 还有一点必须注意：jdk动态代理的应用前提，必须是委托类基于统一的接口。如果没有上述前提，jdk动态代理不能应用。 由此可以看出，jdk动态代理有一定的局限性，cglib这种第三方类库实现的动态代理应用更加广泛，且在效率上更有优势。</span><br><span class="line"></span><br><span class="line">实现AOP关键特点是定义好两个角色 切点 和 切面 。 代理模式中被代理类 委托类处于切点角色，需要添加的其他比如 校验逻辑，事务，审计逻辑 属于非功能实现逻辑通过 切面类定义的方法插入进去。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">JDK动态代理 aop 实现方式</span><br><span class="line">定义切面接口，完成将通用公共方法注入到被代理类接口调用处理中</span><br><span class="line">package org.vincent.aop.dynamicproxy;/**</span><br><span class="line">* @Package: org.vincent.aop.dynamicproxy &lt;br/&gt;</span><br><span class="line">* @Description： 定义切面接口，切面接口定义了两个切面方法，分别在切点接口方法执行前和执行后执行 &lt;br/&gt;</span><br><span class="line">* @author: lenovo &lt;br/&gt;</span><br><span class="line">* @Company: PLCC &lt;br/&gt;</span><br><span class="line">* @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line">* @Version: 1.0 &lt;br/&gt;</span><br><span class="line">* @Modified By: &lt;br/&gt;</span><br><span class="line">* @Created by lenovo on 2018/12/26 &lt;br/&gt;</span><br><span class="line">*/public interface IAspect &#123;    /**</span><br><span class="line">    * 在切点接口方法执行之前执行</span><br><span class="line">    * @param args 切点参数列表</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   boolean startTransaction(Object... args);    /**</span><br><span class="line">    * 在切点接口方法执行之后执行</span><br><span class="line">    */</span><br><span class="line">   void endTrasaction();</span><br><span class="line">&#125;</span><br><span class="line">定义切面实现类</span><br><span class="line">package org.vincent.aop.dynamicproxy;import java.util.Objects;/**</span><br><span class="line">* @Package: org.vincent.aop.dynamicproxy &lt;br/&gt;</span><br><span class="line">* @Description： 改类作为AOP 模型中切面角色类， 实现切面接口，切面接口定义了两个切面方法，分别在切点接口方法执行前和执行后执行 。 &lt;br/&gt;</span><br><span class="line">* @author: lenovo &lt;br/&gt;</span><br><span class="line">* @Company: PLCC &lt;br/&gt;</span><br><span class="line">* @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line">* @Version: 1.0 &lt;br/&gt;</span><br><span class="line">* @Modified By: &lt;br/&gt;</span><br><span class="line">* @Created by lenovo on 2018/12/26 &lt;br/&gt;</span><br><span class="line">*/public class CustomAspect implements IAspect &#123;    /**</span><br><span class="line">    * 对参数 做判空处理</span><br><span class="line">    * @param args 切点参数列表</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   @Override</span><br><span class="line">   public boolean startTransaction(Object... args) &#123;</span><br><span class="line">       Objects.nonNull(args);        boolean result = true;        for (Object temp :args) &#123;            if (Objects.isNull(temp))&#123;</span><br><span class="line">                result =false;                 break;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;        return result;</span><br><span class="line">   &#125;    public void endTrasaction() &#123;</span><br><span class="line">       System.out.println(&quot;I get datasource here and end transaction&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">定义切点角色接口 因为是基于JDK实现的Aop ，所以委托类需要基于接口实现。</span><br><span class="line">package org.vincent.aop.dynamicproxy;/**</span><br><span class="line">* @Package: org.vincent.aop.dynamicproxy &lt;br/&gt;</span><br><span class="line">* @Description： AOP基于动态代理 实现  &lt;br/&gt;</span><br><span class="line">* @author: lenovo &lt;br/&gt;</span><br><span class="line">* @Company: PLCC &lt;br/&gt;</span><br><span class="line">* @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line">* @Version: 1.0 &lt;br/&gt;</span><br><span class="line">* @Modified By: &lt;br/&gt;</span><br><span class="line">* @Created by lenovo on 2018/12/26 &lt;br/&gt;</span><br><span class="line">*/public interface IUserService &#123;    void saveUser(String username, String password) throws Exception;</span><br><span class="line">&#125;</span><br><span class="line">委托类实现</span><br><span class="line">package org.vincent.aop.dynamicproxy;/**</span><br><span class="line">* @Package: org.vincent.aop.dynamicproxy &lt;br/&gt;</span><br><span class="line">* @Description： UserService接口实现类UserServiceImpl 该类 作为AOP中切点角色，切面定义的方法插入到切点的接口方法 执行前和执行后执行。 &lt;br/&gt;</span><br><span class="line">* @author: lenovo &lt;br/&gt;</span><br><span class="line">* @Company: PLCC &lt;br/&gt;</span><br><span class="line">* @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line">* @Version: 1.0 &lt;br/&gt;</span><br><span class="line">* @Modified By: &lt;br/&gt;</span><br><span class="line">* @Created by lenovo on 2018/12/26 &lt;br/&gt;</span><br><span class="line">*/public class UserServiceImpl implements IUserService&#123;    @Override</span><br><span class="line">   public void saveUser(String username, String password) throws Exception &#123;</span><br><span class="line">       System.out.println(&quot;save user[username=&quot; + username + &quot;,password=&quot; + password + &quot;]&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">JDK动态代理生成器工具类</span><br><span class="line">可以看到 generatorJDKProxy 方法入参只有两个参数 一个切点接口引用，一个切面接口引用；在InvocationHandler 内部类中可以完整看到切面类方法是怎么影响切点代码执行逻辑的。</span><br><span class="line"></span><br><span class="line">package org.vincent.aop.dynamicproxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.util.Arrays;/**</span><br><span class="line">* @Package: org.vincent.aop.dynamicproxy &lt;br/&gt;</span><br><span class="line">* @Description： JDK动态代理类生成器 &lt;br/&gt;</span><br><span class="line">* @author: lenovo &lt;br/&gt;</span><br><span class="line">* @Company: PLCC &lt;br/&gt;</span><br><span class="line">* @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line">* @Version: 1.0 &lt;br/&gt;</span><br><span class="line">* @Modified By: &lt;br/&gt;</span><br><span class="line">* @Created by lenovo on 2018/12/26-16:48 &lt;br/&gt;</span><br><span class="line">*/public class JDKDynamicProxyGenerator &#123;    /**</span><br><span class="line">    * @param targetPoint 需要被代理的委托类对象</span><br><span class="line">    * @param aspect 切面对象,该对象方法将在切点方法之前或之后执行</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   public static Object generatorJDKProxy(IUserService targetPoint, final IAspect aspect) &#123;        return Proxy.newProxyInstance(                /**</span><br><span class="line">                *   委托类使用的类加载器</span><br><span class="line">                */</span><br><span class="line">               targetPoint.getClass().getClassLoader(),                /**</span><br><span class="line">                * 委托类实现的接口</span><br><span class="line">                */</span><br><span class="line">               targetPoint.getClass().getInterfaces(),                /**</span><br><span class="line">                * 生成的动态代理类关联的 执行处理器，代理我们的业务逻辑被生成的动态代理类回调</span><br><span class="line">                * 具体逻辑代码执行,返回值为方法执行结果, 在aop模型中，委托类的接口方法称为切点。</span><br><span class="line">                */</span><br><span class="line">               new InvocationHandler() &#123;                    @Override</span><br><span class="line">                   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                        // 执行切面方法,对入参进行校验</span><br><span class="line">                      boolean prepareAction = aspect.startTransaction(args);                       if (prepareAction)&#123;                           // 具体逻辑代码执行,返回值为方法执行结果</span><br><span class="line">                          Object result = method.invoke(targetPoint, args);</span><br><span class="line">                          aspect.endTrasaction();                           return result;</span><br><span class="line">                      &#125;else &#123;                           throw  new RuntimeException(&quot;args: &quot;+ Arrays.toString(args)+&quot;不能为null &quot;);</span><br><span class="line">                      &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">测试类</span><br><span class="line">package org.vincent.aop;import org.junit.Test;import org.vincent.aop.dynamicproxy.CustomAspect;import org.vincent.aop.dynamicproxy.IUserService;import org.vincent.aop.dynamicproxy.JDKDynamicProxyGenerator;import org.vincent.aop.dynamicproxy.UserServiceImpl;/**</span><br><span class="line">* @Package: org.vincent &lt;br/&gt;</span><br><span class="line">* @Description： 基于动态代理类AOP测试案例 &lt;br/&gt;</span><br><span class="line">* @author: lenovo &lt;br/&gt;</span><br><span class="line">* @Company: PLCC &lt;br/&gt;</span><br><span class="line">* @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line">* @Version: 1.0 &lt;br/&gt;</span><br><span class="line">* @Modified By: &lt;br/&gt;</span><br><span class="line">* @Created by lenovo on 2018/12/26-16:56 &lt;br/&gt;</span><br><span class="line">*/public class testAopJDKProxy &#123;    @Test</span><br><span class="line">   public void testJDKProxy() throws Exception &#123;</span><br><span class="line">       System.out.println(&quot;无代理前 调用方法 userService.saveUser 输出......&quot;);</span><br><span class="line">       IUserService userService = new UserServiceImpl();</span><br><span class="line">       userService.saveUser(&quot;zby&quot;, &quot;1234567890&quot;);       System.out.println(&quot;有代理后AOP 是怎么样的？ Proxy......&quot;);</span><br><span class="line">       IUserService proxyUserService = (IUserService) JDKDynamicProxyGenerator.generatorJDKProxy(userService, new CustomAspect());</span><br><span class="line">       proxyUserService.saveUser(&quot;zby&quot;, &quot;1234567890&quot;);        /** 制造异常,两个入参都是null   */</span><br><span class="line">       proxyUserService.saveUser(null, null);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Cglib aop 实现方式</span><br><span class="line">定义切面接口</span><br><span class="line">package org.vincent.aop.cglib;/**</span><br><span class="line">* @Package: org.vincent.aop.dynamicproxy &lt;br/&gt;</span><br><span class="line">* @Description： 定义切面接口，切面接口定义了两个切面方法，分别在切点接口方法执行前和执行后执行 &lt;br/&gt;</span><br><span class="line">* @author: lenovo &lt;br/&gt;</span><br><span class="line">* @Company: PLCC &lt;br/&gt;</span><br><span class="line">* @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line">* @Version: 1.0 &lt;br/&gt;</span><br><span class="line">* @Modified By: &lt;br/&gt;</span><br><span class="line">* @Created by lenovo on 2018/12/26 &lt;br/&gt;</span><br><span class="line">*/public interface IAspect &#123;    /**</span><br><span class="line">    * 在切点接口方法执行之前执行</span><br><span class="line">    */</span><br><span class="line">   void startTransaction();    /**</span><br><span class="line">    * 在切点接口方法执行之后执行</span><br><span class="line">    */</span><br><span class="line">   void endTrasaction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">切面实现</span><br><span class="line">package org.vincent.aop.cglib;/**</span><br><span class="line">* @Package: org.vincent.aop.dynamicproxy &lt;br/&gt;</span><br><span class="line">* @Description： 改类作为AOP 模型中切面角色类， 实现切面接口，切面接口定义了两个切面方法，分别在切点接口方法执行前和执行后执行 。 &lt;br/&gt;</span><br><span class="line">* @author: lenovo &lt;br/&gt;</span><br><span class="line">* @Company: PLCC &lt;br/&gt;</span><br><span class="line">* @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line">* @Version: 1.0 &lt;br/&gt;</span><br><span class="line">* @Modified By: &lt;br/&gt;</span><br><span class="line">* @Created by lenovo on 2018/12/26 &lt;br/&gt;</span><br><span class="line">*/public class CustomAspect implements IAspect &#123;    @Override</span><br><span class="line">   public void startTransaction() &#123;</span><br><span class="line">       System.out.println(&quot;cglib. I get datasource here and start transaction&quot;);</span><br><span class="line">   &#125;    public void endTrasaction() &#123;</span><br><span class="line">       System.out.println(&quot;cglib I get datasource here and end transaction&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">Cglib 是基于类实现的动态代理即业务类只需要实现类即可，不用强制必须实现某个接口为了突出这个优点这里没有实现接口</span><br><span class="line">package org.vincent.aop.cglib;/**</span><br><span class="line">* @Package: org.vincent.aop.dynamicproxy &lt;br/&gt;</span><br><span class="line">* @Description： 业务实现类UserServiceImpl 该类 作为AOP中切点角色，切面定义的方法插入到切点的接口方法 执行前和执行后执行。 &lt;br/&gt;</span><br><span class="line">* @author: lenovo &lt;br/&gt;</span><br><span class="line">* @Company: PLCC &lt;br/&gt;</span><br><span class="line">* @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line">* @Version: 1.0 &lt;br/&gt;</span><br><span class="line">* @Modified By: &lt;br/&gt;</span><br><span class="line">* @Created by lenovo on 2018/12/26 &lt;br/&gt;</span><br><span class="line">*/public class UserServiceImpl &#123;    public void saveUser(String username, String password) &#123;</span><br><span class="line">       System.out.println(&quot;cglib save user[username=&quot; + username + &quot;,password=&quot; + password + &quot;]&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Cglib 动态代理生成器工具类</span><br><span class="line">package org.vincent.aop.cglib;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import java.lang.reflect.Method;/**</span><br><span class="line">* @Package: org.vincent.aop.cglib &lt;br/&gt;</span><br><span class="line">* @Description： 基于Cglib代理类生成器工具类 &lt;br/&gt;</span><br><span class="line">* @author: lenovo &lt;br/&gt;</span><br><span class="line">* @Company: PLCC &lt;br/&gt;</span><br><span class="line">* @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line">* @Version: 1.0 &lt;br/&gt;</span><br><span class="line">* @Modified By: &lt;br/&gt;</span><br><span class="line">* @Created by lenovo on 2018/12/26-17:04 &lt;br/&gt;</span><br><span class="line">*/public class CglibProxyGenerator &#123;    /**</span><br><span class="line">    * @param target 需要被代理的委托类对象，Cglib需要继承该类生成子类</span><br><span class="line">    * @param aspect 切面对象,改对象方法将在切点方法之前或之后执行</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   public static  Object generatorCglibProxy(final Object target, final IAspect aspect)&#123;        //3.1 new Enhancer</span><br><span class="line">       Enhancer enhancer = new Enhancer();        //3.2 设置需要代理的父类</span><br><span class="line">       enhancer.setSuperclass(target.getClass());        //3.3 设置回调</span><br><span class="line">       enhancer.setCallback(new MethodInterceptor() &#123;            @Override</span><br><span class="line">           public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span><br><span class="line">                   throws Throwable &#123;                // 执行切面方法</span><br><span class="line">               aspect.startTransaction();                // 具体逻辑代码执行,返回值为方法执行结果</span><br><span class="line">               Object result = methodProxy.invokeSuper(proxy, args);                // 执行切面方法</span><br><span class="line">               aspect.endTrasaction();                // 返回方法执行结果</span><br><span class="line">               return result;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);        // 3.4 创建代理对象</span><br><span class="line">       return enhancer.create();</span><br><span class="line">   &#125;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">测试类</span><br><span class="line">package org.vincent.aop;import org.junit.Test;import org.vincent.aop.cglib.CglibProxyGenerator;import org.vincent.aop.cglib.CustomAspect;import org.vincent.aop.cglib.UserServiceImpl;/**</span><br><span class="line">* @Package: org.vincent &lt;br/&gt;</span><br><span class="line">* @Description： 基于动态代理类AOP测试案例 &lt;br/&gt;</span><br><span class="line">* @author: lenovo &lt;br/&gt;</span><br><span class="line">* @Company: PLCC &lt;br/&gt;</span><br><span class="line">* @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line">* @Version: 1.0 &lt;br/&gt;</span><br><span class="line">* @Modified By: &lt;br/&gt;</span><br><span class="line">* @Created by lenovo on 2018/12/26-16:56 &lt;br/&gt;</span><br><span class="line">*/public class testAopCglibKProxy &#123;    @Test</span><br><span class="line">   public void testCglibProxy() &#123;</span><br><span class="line">       System.out.println(&quot;before Proxy......&quot;);</span><br><span class="line">       UserServiceImpl userService = new UserServiceImpl();</span><br><span class="line">       userService.saveUser(&quot;zby&quot;, &quot;1234567890&quot;);</span><br><span class="line">       System.out.println(&quot;引入Cglib  Proxy代理库 后......&quot;);</span><br><span class="line">       UserServiceImpl proxyUserService = (UserServiceImpl) CglibProxyGenerator.generatorCglibProxy(userService, new CustomAspect());</span><br><span class="line">       proxyUserService.saveUser(&quot;zby&quot;, &quot;1234567890&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">AspectJ 实现 AOP 效果</span><br><span class="line">AOP 实现的关键就在于 AOP 框架自动创建的 AOP 代理，AOP 代理则可分为静态代理和动态代理两大类:</span><br><span class="line"></span><br><span class="line">静态代理是指使用 AOP 框架提供的命令进行编译，从而在编译阶段通过AOP框架指令生成 AOP 代理类，因此也称为编译时增强；还有一种静态代理是编写代码实现不用工具；这种方式一般是代理模式会使用。</span><br><span class="line">动态代理则在运行时借助于 JDK 动态代理、CGLIB 等在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。</span><br><span class="line">基于 AspectJ 的编译时增强进行 AOP POM 依赖</span><br><span class="line">原生 AspectJ 不依赖Spring案例, 基于 AspectJ 的编译时增强进行 AOP 它是在编译期修改字节码，增强功能；并不会生成新的代理类字节码。</span><br><span class="line"></span><br><span class="line">&lt;!-- AspectJ begin--&gt;&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- AspectJ stop--&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">动态代理 使用场景</span><br><span class="line">日志集中打印</span><br><span class="line">事务</span><br><span class="line">权限管理</span><br><span class="line">AOP</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">SpringAop 什么时候调用jdk动态代理？什么时候调用cglib</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">1.导入log4j.jar，开启log4j DEBUG模式</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">2.查看打印日志，可以发现一个重要信息：</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">2020-03-03 15:13:31,870 DEBUG [org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator] - Creating implicit proxy for bean &apos;userService&apos; with 0 common interceptors and 4 specific interceptors</span><br><span class="line">spring再执行aop时，执行了 AnnotationAwareAspectJAutoProxyCreator 类中的某个方法</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">3.通过 AnnotationAwareAspectJAutoProxyCreator 找到最终执行的是其父类 AbstractAutoProxyCreator 中的 protected Advisor[] buildAdvisors(String beanName, Object[] specificInterceptors) 方法</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">4. 重新在 buildAdvisors 这个方法打断点进行调试</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">5.AbstractAutoProxyCreator 类中发现有一个重要的方法createProxy 如下：</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">protected Object createProxy(</span><br><span class="line">    Class&lt;?&gt; beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource) &#123;</span><br><span class="line"></span><br><span class="line">    if (this.beanFactory instanceof ConfigurableListableBeanFactory) &#123;</span><br><span class="line">        AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) this.beanFactory, beanName, beanClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ProxyFactory proxyFactory = new ProxyFactory();</span><br><span class="line">    proxyFactory.copyFrom(this);</span><br><span class="line"></span><br><span class="line">    if (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">        if (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">            proxyFactory.setProxyTargetClass(true);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">    proxyFactory.addAdvisors(advisors);</span><br><span class="line">    proxyFactory.setTargetSource(targetSource);</span><br><span class="line">    customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">    proxyFactory.setFrozen(this.freezeProxy);</span><br><span class="line">    if (advisorsPreFiltered()) &#123;</span><br><span class="line">        proxyFactory.setPreFiltered(true);</span><br><span class="line">    &#125;</span><br><span class="line">    // 核心代码</span><br><span class="line">    return proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">接着进入 ProxyFactory 中的 getProxy 方法</span><br><span class="line"></span><br><span class="line">public Object getProxy(ClassLoader classLoader) &#123;</span><br><span class="line">    // createAopProxy 方法中判断是选择jdk动态代理还是cglib方式代理</span><br><span class="line">    return createAopProxy().getProxy(classLoader);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">再进入到 ProxyCreatorSupport 中的 createAopProxy 方法</span><br><span class="line"></span><br><span class="line">复制代码</span><br><span class="line">protected final synchronized AopProxy createAopProxy() &#123;</span><br><span class="line">    if (!this.active) &#123;</span><br><span class="line">        activate();</span><br><span class="line">    &#125;</span><br><span class="line">    // getAopProxyFactory() 返回的是 DefaultAopProxyFactory对象，所以重点还是在 createAopProxy 方法上</span><br><span class="line">    return getAopProxyFactory().createAopProxy(this);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">6.进入到 DefaultAopProxyFactory 类中的 createAopProxy 方法，这个方法就是如何选择JDK动态代理还是Cglib代理</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException &#123;</span><br><span class="line">    // 1.config.isProxyTargetClass() 代表 配置中的proxy-target-class属性true/false，默认false</span><br><span class="line">    // </span><br><span class="line">    if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">        // 目标代理类，如 com.service.impl.UserServiceImpl</span><br><span class="line">        Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">        if (targetClass == null) &#123;</span><br><span class="line">            throw new AopConfigException(&quot;TargetSource cannot determine target class: &quot; +</span><br><span class="line">                                         &quot;Either an interface or a target is required for proxy creation.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        // 目标类如果是一个接口 或 </span><br><span class="line">        if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">            return new JdkDynamicAopProxy(config);</span><br><span class="line">        &#125;</span><br><span class="line">        return new ObjenesisCglibAopProxy(config);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        return new JdkDynamicAopProxy(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">方法中参数config 是一个 AdvisedSupport类型， AdvisedSupport 继承了 ProxyConfig 类，</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class ProxyConfig implements Serializable &#123;</span><br><span class="line">    // 代表 配置中的proxy-target-class，如果设置true，则使用Cglib方式代理</span><br><span class="line">    private boolean proxyTargetClass = false;</span><br><span class="line"></span><br><span class="line">    private boolean optimize = false;</span><br><span class="line"></span><br><span class="line">    boolean opaque = false;</span><br><span class="line"></span><br><span class="line">    boolean exposeProxy = false;</span><br><span class="line"></span><br><span class="line">    private boolean frozen = false;</span><br><span class="line"></span><br><span class="line">    // 省略部分代码</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></header></article><section class="reward"><a class="btn-reward" href="#">打赏</a><div class="reward-wrapper clearfix"><img src="/img/wechat.png" title="微信"><img src="/img/alipay.png" title="支付宝"></div></section></main><footer class="foot"><div class="foot-copy">&copy; 2016 - 2020 Gavin</div></footer><script src="/js/scroller.js"></script><script src="/js/main.js"></script></body></html>