<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Gavin"><link rel="alternative" href="/atom.xml" title="孙云龙的技术博客" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>Session Token Cookie - 孙云龙的技术博客</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script></head><body style="opacity:0"><header class="head"><h1 class="head-title u-fl"><a href="/">孙云龙的技术博客</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/archives">目录</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"><time class="post__time" datetime="2019-12-13T02:09:01.000Z">2019 - 12 - 13 10:09:01</time><h1 class="post__title"><a href="/2019/12/13/Session-Token-Cookie/">Session Token Cookie</a></h1><div class="post__main echo"><h4 id="本文记录一下Session-Token-Cookie到底是什么，以及有什么区别。按顺序来看保证登陆状态的演进的几种方式"><a href="#本文记录一下Session-Token-Cookie到底是什么，以及有什么区别。按顺序来看保证登陆状态的演进的几种方式" class="headerlink" title="本文记录一下Session Token Cookie到底是什么，以及有什么区别。按顺序来看保证登陆状态的演进的几种方式"></a>本文记录一下Session Token Cookie到底是什么，以及有什么区别。按顺序来看保证登陆状态的演进的几种方式</h4><h4 id="1-最开始互联网并没有那么大的体量，每个网站也没有那么多的用户，所以访问网站时，只需要做最简单的用户名密码进行校验就可以，但慢慢的随着用户量增加，体量增大，就面临一个问题，那就是要管理会话，必须记住哪些人登陆系统，也就是说必须要把每个人区分开，这就是一个不小的挑战，因为HTTP请求是无状态的，当时想出的办法是给大家发一个会话标识-session-id-，其实就是一个随机的字符串，每个人的都不一样，作为唯一区分。"><a href="#1-最开始互联网并没有那么大的体量，每个网站也没有那么多的用户，所以访问网站时，只需要做最简单的用户名密码进行校验就可以，但慢慢的随着用户量增加，体量增大，就面临一个问题，那就是要管理会话，必须记住哪些人登陆系统，也就是说必须要把每个人区分开，这就是一个不小的挑战，因为HTTP请求是无状态的，当时想出的办法是给大家发一个会话标识-session-id-，其实就是一个随机的字符串，每个人的都不一样，作为唯一区分。" class="headerlink" title="1.最开始互联网并没有那么大的体量，每个网站也没有那么多的用户，所以访问网站时，只需要做最简单的用户名密码进行校验就可以，但慢慢的随着用户量增加，体量增大，就面临一个问题，那就是要管理会话，必须记住哪些人登陆系统，也就是说必须要把每个人区分开，这就是一个不小的挑战，因为HTTP请求是无状态的，当时想出的办法是给大家发一个会话标识(session_id)，其实就是一个随机的字符串，每个人的都不一样，作为唯一区分。"></a>1.最开始互联网并没有那么大的体量，每个网站也没有那么多的用户，所以访问网站时，只需要做最简单的用户名密码进行校验就可以，但慢慢的随着用户量增加，体量增大，就面临一个问题，那就是要管理会话，必须记住哪些人登陆系统，也就是说必须要把每个人区分开，这就是一个不小的挑战，因为HTTP请求是无状态的，当时想出的办法是给大家发一个会话标识(session_id)，其实就是一个随机的字符串，每个人的都不一样，作为唯一区分。</h4><h4 id="2-这样大家很开心，但是服务器就不开心了，每个人只需要保存自己的session-id，但服务器需要保存所有人的session-id，如果访问服务器多了，就得由成千上万，甚至几十万个，这对服务器是一个巨大的开销，严重限制了服务器扩展的能力，比如说我用两个机器组成了一个集群，小F通过机器A登陆了系统，那session-id会保存在机器A上，假设小F的下一次请求被转发到机器B怎么办？机器B可没有小F的session-id"><a href="#2-这样大家很开心，但是服务器就不开心了，每个人只需要保存自己的session-id，但服务器需要保存所有人的session-id，如果访问服务器多了，就得由成千上万，甚至几十万个，这对服务器是一个巨大的开销，严重限制了服务器扩展的能力，比如说我用两个机器组成了一个集群，小F通过机器A登陆了系统，那session-id会保存在机器A上，假设小F的下一次请求被转发到机器B怎么办？机器B可没有小F的session-id" class="headerlink" title="2.这样大家很开心，但是服务器就不开心了，每个人只需要保存自己的session_id，但服务器需要保存所有人的session_id，如果访问服务器多了，就得由成千上万，甚至几十万个，这对服务器是一个巨大的开销，严重限制了服务器扩展的能力，比如说我用两个机器组成了一个集群，小F通过机器A登陆了系统，那session_id会保存在机器A上，假设小F的下一次请求被转发到机器B怎么办？机器B可没有小F的session_id"></a>2.这样大家很开心，但是服务器就不开心了，每个人只需要保存自己的session_id，但服务器需要保存所有人的session_id，如果访问服务器多了，就得由成千上万，甚至几十万个，这对服务器是一个巨大的开销，严重限制了服务器扩展的能力，比如说我用两个机器组成了一个集群，小F通过机器A登陆了系统，那session_id会保存在机器A上，假设小F的下一次请求被转发到机器B怎么办？机器B可没有小F的session_id</h4><h4 id="3-有时候会采用一点小伎俩，session-sticky，就是让小F的请求一直粘连在机器A上，但是这也不管用，要是机器A挂掉了，还得转到机器B去。"><a href="#3-有时候会采用一点小伎俩，session-sticky，就是让小F的请求一直粘连在机器A上，但是这也不管用，要是机器A挂掉了，还得转到机器B去。" class="headerlink" title="3.有时候会采用一点小伎俩，session sticky，就是让小F的请求一直粘连在机器A上，但是这也不管用，要是机器A挂掉了，还得转到机器B去。"></a>3.有时候会采用一点小伎俩，session sticky，就是让小F的请求一直粘连在机器A上，但是这也不管用，要是机器A挂掉了，还得转到机器B去。</h4><h4 id="4-那就只好做session-id的复制了，把session-id在两个机器之间搬来搬去，快累死了。"><a href="#4-那就只好做session-id的复制了，把session-id在两个机器之间搬来搬去，快累死了。" class="headerlink" title="4.那就只好做session_id的复制了，把session_id在两个机器之间搬来搬去，快累死了。"></a>4.那就只好做session_id的复制了，把session_id在两个机器之间搬来搬去，快累死了。</h4><h4 id="5-后来有个叫Memcached的支了招，把session-id集中存储到一个地方，所有的机器都来访问这个地方的数据，这样一来，就不用复制了，但是增加了单点失败的可能性，要是那个负责session的机器挂了，所有人就需要重新登陆一边，后来也尝试把这个单点的机器也搞出集群，增加可靠性，但不管如何，这小小的session对我来说是一个沉重的负担。"><a href="#5-后来有个叫Memcached的支了招，把session-id集中存储到一个地方，所有的机器都来访问这个地方的数据，这样一来，就不用复制了，但是增加了单点失败的可能性，要是那个负责session的机器挂了，所有人就需要重新登陆一边，后来也尝试把这个单点的机器也搞出集群，增加可靠性，但不管如何，这小小的session对我来说是一个沉重的负担。" class="headerlink" title="5.后来有个叫Memcached的支了招，把session_id集中存储到一个地方，所有的机器都来访问这个地方的数据，这样一来，就不用复制了，但是增加了单点失败的可能性，要是那个负责session的机器挂了，所有人就需要重新登陆一边，后来也尝试把这个单点的机器也搞出集群，增加可靠性，但不管如何，这小小的session对我来说是一个沉重的负担。"></a>5.后来有个叫Memcached的支了招，把session_id集中存储到一个地方，所有的机器都来访问这个地方的数据，这样一来，就不用复制了，但是增加了单点失败的可能性，要是那个负责session的机器挂了，所有人就需要重新登陆一边，后来也尝试把这个单点的机器也搞出集群，增加可靠性，但不管如何，这小小的session对我来说是一个沉重的负担。</h4><h4 id="6-于是有人就一直思考，我为什么要保存这可恶的session呢，只让每个客户端去保存该多好，可是如果不保存这些session-id，怎么验证客户端发给我的session-id的确是我生成的呢？如果不去验证，我们都不知道他们是不是合法的登陆用户，那些不怀好意的家伙就可以伪造session-id-为所欲为了。关键就是验证，这个时候token应运而生，用户登陆系统，最简单的token组成-uid-用户唯一的身份标识-、time-当前时间的时间戳-、sign-签名，由token的前几位-盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器-。"><a href="#6-于是有人就一直思考，我为什么要保存这可恶的session呢，只让每个客户端去保存该多好，可是如果不保存这些session-id，怎么验证客户端发给我的session-id的确是我生成的呢？如果不去验证，我们都不知道他们是不是合法的登陆用户，那些不怀好意的家伙就可以伪造session-id-为所欲为了。关键就是验证，这个时候token应运而生，用户登陆系统，最简单的token组成-uid-用户唯一的身份标识-、time-当前时间的时间戳-、sign-签名，由token的前几位-盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器-。" class="headerlink" title="6.于是有人就一直思考，我为什么要保存这可恶的session呢，只让每个客户端去保存该多好，可是如果不保存这些session_id，怎么验证客户端发给我的session_id的确是我生成的呢？如果不去验证，我们都不知道他们是不是合法的登陆用户，那些不怀好意的家伙就可以伪造session_id,为所欲为了。关键就是验证，这个时候token应运而生，用户登陆系统，最简单的token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器)。"></a>6.于是有人就一直思考，我为什么要保存这可恶的session呢，只让每个客户端去保存该多好，可是如果不保存这些session_id，怎么验证客户端发给我的session_id的确是我生成的呢？如果不去验证，我们都不知道他们是不是合法的登陆用户，那些不怀好意的家伙就可以伪造session_id,为所欲为了。关键就是验证，这个时候token应运而生，用户登陆系统，最简单的token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器)。</h4><h4 id="7-至此基本的登陆过程就讲完了，但是现在也出现了更加安全的便捷的方式，token更多用于单点登录，拿着手机token去sso验证，验证通过可以重定向到之前访问的网站。"><a href="#7-至此基本的登陆过程就讲完了，但是现在也出现了更加安全的便捷的方式，token更多用于单点登录，拿着手机token去sso验证，验证通过可以重定向到之前访问的网站。" class="headerlink" title="7.至此基本的登陆过程就讲完了，但是现在也出现了更加安全的便捷的方式，token更多用于单点登录，拿着手机token去sso验证，验证通过可以重定向到之前访问的网站。"></a>7.至此基本的登陆过程就讲完了，但是现在也出现了更加安全的便捷的方式，token更多用于单点登录，拿着手机token去sso验证，验证通过可以重定向到之前访问的网站。</h4><h4 id="8-总结一下cookie，session，token"><a href="#8-总结一下cookie，session，token" class="headerlink" title="8.总结一下cookie，session，token"></a>8.总结一下cookie，session，token</h4><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><h4 id="cookie存储在客户端，HTTP是无状态的，HTTP每次发出的时候会附上改域名下的cookie，从而可以给HTTP附上状态，最常见的就是登陆态。"><a href="#cookie存储在客户端，HTTP是无状态的，HTTP每次发出的时候会附上改域名下的cookie，从而可以给HTTP附上状态，最常见的就是登陆态。" class="headerlink" title="cookie存储在客户端，HTTP是无状态的，HTTP每次发出的时候会附上改域名下的cookie，从而可以给HTTP附上状态，最常见的就是登陆态。"></a>cookie存储在客户端，HTTP是无状态的，HTTP每次发出的时候会附上改域名下的cookie，从而可以给HTTP附上状态，最常见的就是登陆态。</h4><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><h4 id="1-客户端向服务器请求，发送用户名和密码"><a href="#1-客户端向服务器请求，发送用户名和密码" class="headerlink" title="1.客户端向服务器请求，发送用户名和密码"></a>1.客户端向服务器请求，发送用户名和密码</h4><h4 id="2-服务器生成session-id，绑定用户数据存储在数据库"><a href="#2-服务器生成session-id，绑定用户数据存储在数据库" class="headerlink" title="2.服务器生成session_id，绑定用户数据存储在数据库"></a>2.服务器生成session_id，绑定用户数据存储在数据库</h4><h4 id="3-服务器返回session-id给客户端"><a href="#3-服务器返回session-id给客户端" class="headerlink" title="3.服务器返回session_id给客户端"></a>3.服务器返回session_id给客户端</h4><h4 id="4-客户端用cookie存储session-id，以后请求都带上这个session-id"><a href="#4-客户端用cookie存储session-id，以后请求都带上这个session-id" class="headerlink" title="4.客户端用cookie存储session_id，以后请求都带上这个session_id"></a>4.客户端用cookie存储session_id，以后请求都带上这个session_id</h4><h4 id="5-服务器如果收到这个session-id，那么就去数据库查找用户数据，如果找到了说明验证通过"><a href="#5-服务器如果收到这个session-id，那么就去数据库查找用户数据，如果找到了说明验证通过" class="headerlink" title="5.服务器如果收到这个session_id，那么就去数据库查找用户数据，如果找到了说明验证通过"></a>5.服务器如果收到这个session_id，那么就去数据库查找用户数据，如果找到了说明验证通过</h4><h4 id="6-服务器把验证结果返回客户端"><a href="#6-服务器把验证结果返回客户端" class="headerlink" title="6.服务器把验证结果返回客户端"></a>6.服务器把验证结果返回客户端</h4><h3 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h3><h4 id="1-客户端向服务器请求，发送用户名和密码-1"><a href="#1-客户端向服务器请求，发送用户名和密码-1" class="headerlink" title="1.客户端向服务器请求，发送用户名和密码"></a>1.客户端向服务器请求，发送用户名和密码</h4><h4 id="2-服务器根据用户信息通过加密生成token，用户信息包括账号，token过期时间等，具体由服务器自定义"><a href="#2-服务器根据用户信息通过加密生成token，用户信息包括账号，token过期时间等，具体由服务器自定义" class="headerlink" title="2.服务器根据用户信息通过加密生成token，用户信息包括账号，token过期时间等，具体由服务器自定义"></a>2.服务器根据用户信息通过加密生成token，用户信息包括账号，token过期时间等，具体由服务器自定义</h4><h4 id="3-服务器返回token给客户端"><a href="#3-服务器返回token给客户端" class="headerlink" title="3.服务器返回token给客户端"></a>3.服务器返回token给客户端</h4><h4 id="4-客户端用cookie存储token，以后的请求都带上这个token"><a href="#4-客户端用cookie存储token，以后的请求都带上这个token" class="headerlink" title="4.客户端用cookie存储token，以后的请求都带上这个token"></a>4.客户端用cookie存储token，以后的请求都带上这个token</h4><h4 id="5-服务器拿到token，把token解密，确认用户信息是否正确"><a href="#5-服务器拿到token，把token解密，确认用户信息是否正确" class="headerlink" title="5.服务器拿到token，把token解密，确认用户信息是否正确"></a>5.服务器拿到token，把token解密，确认用户信息是否正确</h4><h4 id="6-服务器把验证结果返回给客户端"><a href="#6-服务器把验证结果返回给客户端" class="headerlink" title="6.服务器把验证结果返回给客户端"></a>6.服务器把验证结果返回给客户端</h4><h3 id="Session，token优劣"><a href="#Session，token优劣" class="headerlink" title="Session，token优劣"></a>Session，token优劣</h3><h4 id="session"><a href="#session" class="headerlink" title="session"></a>session</h4><h5 id="由于session-id和用户信息相互绑定的数据库存在服务器，所以服务器可以随时让发送出去的一个session-id失效，这是保障安全的一种重要手段"><a href="#由于session-id和用户信息相互绑定的数据库存在服务器，所以服务器可以随时让发送出去的一个session-id失效，这是保障安全的一种重要手段" class="headerlink" title="由于session_id和用户信息相互绑定的数据库存在服务器，所以服务器可以随时让发送出去的一个session_id失效，这是保障安全的一种重要手段"></a>由于session_id和用户信息相互绑定的数据库存在服务器，所以服务器可以随时让发送出去的一个session_id失效，这是保障安全的一种重要手段</h5><h4 id="token"><a href="#token" class="headerlink" title="token"></a>token</h4><h5 id="token的好处是比session更省空间和时间，服务器不需要去管理session-id和用户信息的数据库，服务器收到token直接解密就可以验证，不需要去数据库查找验证，但是token发出去之后，就只能等待它过期之后才会失效，后台服务器无法对其进行控制"><a href="#token的好处是比session更省空间和时间，服务器不需要去管理session-id和用户信息的数据库，服务器收到token直接解密就可以验证，不需要去数据库查找验证，但是token发出去之后，就只能等待它过期之后才会失效，后台服务器无法对其进行控制" class="headerlink" title="token的好处是比session更省空间和时间，服务器不需要去管理session_id和用户信息的数据库，服务器收到token直接解密就可以验证，不需要去数据库查找验证，但是token发出去之后，就只能等待它过期之后才会失效，后台服务器无法对其进行控制"></a>token的好处是比session更省空间和时间，服务器不需要去管理session_id和用户信息的数据库，服务器收到token直接解密就可以验证，不需要去数据库查找验证，但是token发出去之后，就只能等待它过期之后才会失效，后台服务器无法对其进行控制</h5><h4 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">加入jwt依赖</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.auth0&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;java-jwt&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">声明2个变量过期时间和token秘钥(UUID可能会更好，我是自己随便输的)，token秘钥用于后面解密</span><br><span class="line"></span><br><span class="line">    //设置30分钟过期</span><br><span class="line">    private static final long EXPIRE_DATE=30*60*1000;</span><br><span class="line">    //token秘钥</span><br><span class="line">    private static final String TOKEN_SECRET = &quot;EQIUBFKSJBFJH2367816BQWE&quot;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">加密</span><br><span class="line">public static String tokenTest (String username,String password)&#123;        </span><br><span class="line"> </span><br><span class="line">        String token = &quot;&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            //过期时间</span><br><span class="line">            Date date = new Date(System.currentTimeMillis()+EXPIRE_DATE);</span><br><span class="line">            //秘钥及加密算法</span><br><span class="line">            Algorithm algorithm = Algorithm.HMAC256(TOKEN_SECRET);</span><br><span class="line">            //设置头部信息</span><br><span class="line">            Map&lt;String,Object&gt; header = new HashMap&lt;&gt;();</span><br><span class="line">            header.put(&quot;typ&quot;,&quot;JWT&quot;);</span><br><span class="line">            header.put(&quot;alg&quot;,&quot;HS256&quot;);</span><br><span class="line">            //携带username，password信息，生成签名</span><br><span class="line">            token = JWT.create()</span><br><span class="line">                    .withHeader(header)</span><br><span class="line">                    .withClaim(&quot;username&quot;,username)</span><br><span class="line">                    .withClaim(&quot;password&quot;,password).withExpiresAt(date)</span><br><span class="line">                    .sign(algorithm);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return  null;</span><br><span class="line">        &#125;</span><br><span class="line">        return token;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">解密。该方法的参数token是加密方法的返回值</span><br><span class="line">public static boolean verify(String token)&#123;</span><br><span class="line">        /**</span><br><span class="line">         * @desc   验证token，通过返回true</span><br><span class="line">         * @create 2019/1/18/018 9:39</span><br><span class="line">         * @params [token]需要校验的串</span><br><span class="line">        **/</span><br><span class="line">        try &#123;</span><br><span class="line">            Algorithm algorithm = Algorithm.HMAC256(TOKEN_SECRET);</span><br><span class="line">            JWTVerifier verifier = JWT.require(algorithm).build();</span><br><span class="line">            DecodedJWT jwt = verifier.verify(token);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return  false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">登陆接口</span><br><span class="line">@RequestMapping(value = &quot;/logon&quot;)</span><br><span class="line">    public JsonRESTResult getUserInfo(HttpSession session ,String userName, String password) &#123;</span><br><span class="line">        /**</span><br><span class="line">        * @author zdj</span><br><span class="line">        * @create 2019/1/17/017 9:55</span><br><span class="line">        * @params [session, userName, password]</span><br><span class="line">        **/</span><br><span class="line">        JsonRESTResult jsonRESTResult = new JsonRESTResult();        </span><br><span class="line">        //使用token工具类生成token串</span><br><span class="line">        String token  = TokenUtil.tokenTest(userName,password);</span><br><span class="line">        //根据用户名密码查找用户</span><br><span class="line">        User user = loginService.findUser(userName,password);</span><br><span class="line">        if (user !=null)&#123;</span><br><span class="line">            //将用户对象放到session中</span><br><span class="line">            session.setAttribute(&quot;USER_INFO&quot;,user);</span><br><span class="line">            //用户无操作30分钟需重新登录</span><br><span class="line">            session.setMaxInactiveInterval(60*30);</span><br><span class="line">            Map map = new HashMap&lt;&gt;();</span><br><span class="line">            map.put(&quot;USERINFO&quot;,user);</span><br><span class="line">            map.put(&quot;SESSIONID&quot;,session.getId());</span><br><span class="line">            map.put(&quot;token&quot;,token);</span><br><span class="line">            jsonRESTResult.setCode(JsonRESTResultMsg.CODE_800.getCode());</span><br><span class="line">            jsonRESTResult.setMsg(&quot;登录成功&quot;);</span><br><span class="line">            jsonRESTResult.setData(map);</span><br><span class="line">            return jsonRESTResult;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            jsonRESTResult.setCode(JsonRESTResultMsg.CODE_500.getCode());</span><br><span class="line">            jsonRESTResult.setMsg(&quot;登录失败,用户名密码错误&quot;);</span><br><span class="line">            jsonRESTResult.setData(null);</span><br><span class="line">            return jsonRESTResult;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">验证用户是否登陆接口</span><br><span class="line">@RequestMapping(&quot;/judgeLogin&quot;)</span><br><span class="line">    public JsonRESTResult judgeLogin(String token,HttpSession session)&#123;</span><br><span class="line">        JsonRESTResult jsonRESTResult = new JsonRESTResult();</span><br><span class="line">        if (TokenUtil.verify(token))&#123;</span><br><span class="line">            User user = (User)session.getAttribute(&quot;USER_INFO&quot;);</span><br><span class="line">            jsonRESTResult.setCode(JsonRESTResultMsg.CODE_800.getCode());</span><br><span class="line">            jsonRESTResult.setData(user);</span><br><span class="line">            jsonRESTResult.setMsg(&quot;用户登录成功&quot;);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            jsonRESTResult.setCode(JsonRESTResultMsg.CODE_500.getCode());</span><br><span class="line">            jsonRESTResult.setMsg(&quot;未登录或已过期&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonRESTResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></header></article><section class="reward"><a class="btn-reward" href="#">打赏</a><div class="reward-wrapper clearfix"><img src="/img/wechat.png" title="微信"><img src="/img/alipay.png" title="支付宝"></div></section></main><footer class="foot"><div class="foot-copy">&copy; 2016 - 2019 Gavin</div></footer><script src="/js/scroller.js"></script><script src="/js/main.js"></script></body></html>