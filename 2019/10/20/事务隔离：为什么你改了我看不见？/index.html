<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Gavin"><link rel="alternative" href="/atom.xml" title="孙云龙的技术博客" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>事务隔离：为什么你改了我看不见？ - 孙云龙的技术博客</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script></head><body style="opacity:0"><header class="head"><h1 class="head-title u-fl"><a href="/">孙云龙的技术博客</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/archives">目录</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"><time class="post__time" datetime="2019-10-20T15:20:57.000Z">2019 - 10 - 20 23:20:57</time><h1 class="post__title"><a href="/2019/10/20/事务隔离：为什么你改了我看不见？/">事务隔离：为什么你改了我看不见？</a></h1><div class="post__main echo"><p>这篇讲的是事务隔离，个人了解的还不够多，所以就把最基础的写上，后面的等搞懂了再重新更新下。<br>提到事务，你肯定不陌生，和数据库打交道的时候，我们总是会用到事务。最经典的例子就是转账，你要给朋友小王转 100 块钱，而此时你的银行卡只有 100 块钱。<br>转账过程具体到程序里会有一系列的操作，比如查询余额、做加减法、更新余额等，这些操作必须保证是一体的，不然等程序查完之后，还没做减法之前，你这 100 块钱，完全可以借着这个时间差再查一次，然后再给另外一个朋友转账，如果银行这么整，不就乱了么？这时就要用到“事务”这个概念了。<br>简单来说，事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在 MySQL 中，事务支持是在引擎层实现的。你现在知道，MySQL 是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如 MySQL 原生的 MyISAM 引擎就不支持事务，这也是 MyISAM 被 InnoDB 取代的重要原因之一。  </p>
<h3 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="headerlink" title="隔离性与隔离级别"></a>隔离性与隔离级别</h3><p>提到事务肯定会想到ACID（原子性，一致性，隔离性，持久性），这节主要讲的是隔离性。<br>当数据库有多个事务同时执行的时候，就可能会出现脏读，不可重复读，幻读的问题，为了解决这些问题，就有了“隔离级别”的概念。<br>在谈隔离级别之前，要了解的是隔离的越严实，效率就会越低，因此很多时候都要在二者之间寻找一个平衡点，SQL标准的隔离级别包括：读未提交，读已提交，可重复读，串行化。<br>读未提交是指，一个事务还没提交时，就能被其他的事务看见。<br>读已提交是指，一个事务提交后才能被其他的事务看见。<br>可重复读是指一个事务在执行过程中看到的数据总是和事务执行时看到的数据保持一致。<br>串行化，顾名思义对于同一行记录，“写”会加“写锁”，“读”会加“读锁”，当出现读写锁冲突的时候，后访问的事务必须等到前一个事务执行完成，才能继续执行。<br>下面举个例子来更好理解：  </p>
<p><img src="../image/%E4%BA%8B%E5%8A%A1.png" alt="事务.png" title="事务">  </p>
<p>来看一下，在不同隔离级别下，事务A会有哪些不同的返回结果，V1，V2，V3的返回值分别是什么。</p>
<p>若隔离级别是“读未提交”：V1就是2，事务B还没有提交就被A看到了，同样V2，V3也是2  </p>
<p>若隔离级别是“读已提交”：V1是1，V2，V3是2，事务B提交后A才能看见改变。  </p>
<p>若隔离级别是“可重复读”：V1，V2是1，V3是2，同一个事务才执行中和执行开始的值应该是一样的，V3在事务A提交后可以看到事务B的改变。  </p>
<p>若隔离级别是“串行化”：V1，V2是1，V3是2，当事务B执行“将1改为2的时候”会被锁住，直到事务A提交后才能改变。  </p>
<p>在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图实在事务启动时创建的，整个事务存在期间都用这个视图。在“读已提交”隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图的概念，而“串行化”隔离级别下直接用加锁的方式来避免并行访问。<br>我们可以看到在不同的隔离级别下，数据库行为是有所不同的。Oracle数据库的默认隔离级别其实就是“读提交”，因此对于一些从Oracle迁移到MySQL的应用，为保证数据库隔离级别的一致，你一定要记得将MySQL的隔离级别设置为“读提交”。  </p>
<p>配置的方式是，将启动参数transaction的值设置成READ-COMMITTED。你可以用show variables来查看当前的值。<br>总结来说，存在即合理，哪个隔离级别都有它自己的使用场景，你要根据自己的业务情况来定。那么什么时候需要“可重复读”的场景呢？我们来看一个校对逻辑的案例。<br>假设你在管理一个个人银行账户表。一个表存了每个月月底的余额，一个表存了账单明细。这时候你要做数据校对，也就是判断上个月的余额和当月余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。  </p>
<h3 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h3><p>理解了事务的隔离级别，我们再来看看事务隔离具体是怎么实现的。这里我们展开说明“可重复读”。  </p>
<p>在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。<br>假设一个值从1被按顺序改成了2，3，4，在回滚日志里面就会有类似下面的记录。  </p>
<p><img src="../image/%E5%9B%9E%E6%BB%9A%E6%AE%B5.png" alt="回滚段.png" title="回滚段">    </p>
<p>当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不用的read-view。如图中看到的，在视图A，B，C里面，这一个记录的值分别是1，2，4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）对于read-view，要得到1，就必须将当前值依次执行图中所有的回滚操作得到。<br>同时你会发现，即使现在有另外一个事务正在将4改成5，这个事务跟read-viewA，B，C对应的事务是不会冲突的。<br>你一定会问，回滚日志总不能一直保留吧，什么时候删除呢？答案是，在不需要的时候才删除，也就是说，系统会判断，当没有事务在需要用到这些回滚日志时，回滚日志会被删除。  </p>
<p>什么时候才不需要了呢？<br>就时当系统里没有比这个回滚日志更早的read-view的时候。<br>基于上面的说明，我们来讨论一下为什么建议你尽量不要使用长事务。<br>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。<br>在MySQL5.5及以前的版本，回滚日志时跟数据字典一起放在ibdata文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。我见过数只有20GB，而非回滚段有200GB的库，最终只好为了清理回滚段，重建整个库。<br>除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库，后面讲锁的时候还会展开说。 </p>
<h3 id="事务的启动方式"><a href="#事务的启动方式" class="headerlink" title="事务的启动方式"></a>事务的启动方式</h3><p>如前面所述，长事务有这些潜在风险，我当然是建议你尽量避免。其实很多时候业务开发同学并不是有意使用长事务，通常是由于误用所致。MySQL的事务启动方式有以下几种：<br>1.显示启动事务语句，begin活start transaction。配套的提交语句是commit，回滚语句是rollback，或者断开连接。<br>有些客户端连接框架会默认连接成功后先执行一个set autocommit = 0的命令。这就导致接下来的查询都在事务中，如果是长链接，就导致了意外的长事务。<br>因此，我会建议你总是使用set autocommit = 1，通过显式语句的方式来启动事务。   </p>
<p>ps：这里解释一下set autocommit = 1  autocommit指的是事务，如果set autocommit = 0那么所有的语句一定是在一个事务里。在这种情况下，如果使用连接池，并且在查询之前没有rollback或者set autocommit = 1，那么就悲剧了，因为根据mysql的默认事务级别，可重复读，永远也取不到这个事务被开户前的数据。另外一点set autocommit = 0，会自动提交前一个事务，因此正确的做法是rollback ，set autocommit = 0，完成之后在set autocommit<br> = 1  </p>
<p>但有的开发同学会纠结“多一次交互”的问题，对于一个需要频繁使用事务的业务，第二种方式每个事务在开始时都不需要主动执行一次“begin”，减少了语句的交互次数。如果你也有这个顾虑，我建议你commit work and chain语法。<br>在autocommit为1的情况下，用beigin显示启动的事务，如果执行commit则提交事务。如果执行commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行begin语句的开销，同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。  </p>
<p>你可以在information_schema库的innodb_trx这个表中查询长事务，比如下面这个语句，用于查找持续时间超过60s的事务。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from information_schema.innodb_trx where TIME_TO_SET(timediff(now(),trx_started)) &gt; 60</span><br></pre></td></tr></table></figure></div></header></article><section class="reward"><a class="btn-reward" href="#">打赏</a><div class="reward-wrapper clearfix"><img src="/img/wechat.png" title="微信"><img src="/img/alipay.png" title="支付宝"></div></section></main><footer class="foot"><div class="foot-copy">&copy; 2016 - 2020 Gavin</div></footer><script src="/js/scroller.js"></script><script src="/js/main.js"></script></body></html>