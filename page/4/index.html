<!DOCTYPE html>


<html lang="en" >


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     孙云龙的技术博客
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  <link rel="stylesheet" href="/dist/main.css">
  <link rel="stylesheet" href="/css/custom.css">
  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

<link rel="alternate" href="/atom.xml" title="孙云龙的技术博客" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">孙云龙的技术博客</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="blog-go-big-or-go-home-3" class="article article-type-blog" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/18/go-big-or-go-home-3/"
    >go big or go home-3</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/18/go-big-or-go-home-3/" class="article-date">
  <time datetime="2020-03-18T14:25:24.000Z" itemprop="datePublished">2020-03-18</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/English/">English</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <table>
<thead>
<tr>
<th>单词/短语</th>
<th>中文</th>
<th>句子</th>
</tr>
</thead>
<tbody><tr>
<td>output</td>
<td>生产</td>
<td>You need to have the output of the code</td>
</tr>
<tr>
<td>pocket</td>
<td>口袋</td>
<td>My pocket is full of money</td>
</tr>
<tr>
<td>dioxide</td>
<td>氧化物</td>
<td>Carbon dioxide causes global warming</td>
</tr>
<tr>
<td>several</td>
<td>几个</td>
<td>I hava several apples</td>
</tr>
<tr>
<td>award</td>
<td>奖</td>
<td>He won the ACM award</td>
</tr>
<tr>
<td>physical education</td>
<td>体育课</td>
<td>I like physical education when I was a student</td>
</tr>
<tr>
<td>physics</td>
<td>物理</td>
<td>Physics is amazing</td>
</tr>
<tr>
<td>past tense</td>
<td>过去式</td>
<td>It was all in the past</td>
</tr>
<tr>
<td>primary school</td>
<td>小学</td>
<td>He’s only eight years old in primary school</td>
</tr>
<tr>
<td>junior high school/middle school</td>
<td>初中</td>
<td>He studied physics in junior high school</td>
</tr>
<tr>
<td>high school</td>
<td>高中</td>
<td>He studied biology in high school</td>
</tr>
<tr>
<td>approachable</td>
<td>亲和力的</td>
<td>My teacher is very approachable</td>
</tr>
<tr>
<td>chemistry</td>
<td>化学</td>
<td>I like chemistry</td>
</tr>
<tr>
<td>biology</td>
<td>生物</td>
<td>Biology is a very difficult subject</td>
</tr>
<tr>
<td>science classes</td>
<td>理科</td>
<td>I studied science classes in my high school</td>
</tr>
<tr>
<td>art classes</td>
<td>文科</td>
<td>I studied art classes in my high school</td>
</tr>
<tr>
<td>geography</td>
<td>地理</td>
<td>Geography was my weak subject</td>
</tr>
<tr>
<td>politics</td>
<td>政治</td>
<td>He quickly involved himself in local politics</td>
</tr>
<tr>
<td>have a test</td>
<td>测试</td>
<td>There is a test this week</td>
</tr>
<tr>
<td>have an exam</td>
<td>考试</td>
<td>There is an exam this week about biology</td>
</tr>
<tr>
<td>exercise</td>
<td>锻炼</td>
<td>I run every day to exercise my legs</td>
</tr>
<tr>
<td>spacious and bright</td>
<td>宽敞明亮</td>
<td>My house is spacious and bright</td>
</tr>
<tr>
<td>play outside–&gt;针对小孩儿</td>
<td>出去玩儿</td>
<td>In spring,we can play outside all day</td>
</tr>
<tr>
<td>do outdoor activities–&gt;对成年人</td>
<td>出去玩儿</td>
<td>Classes are over, and it’s time for students to do some outdoor activities</td>
</tr>
<tr>
<td>不能与成年人说play with要说hang out</td>
<td>与。。。玩儿</td>
<td>Children like to play with water/Let’s hang out again tomorrow</td>
</tr>
<tr>
<td>besides</td>
<td>除。。。之外</td>
<td>He gave me a book, a pen and some money besides</td>
</tr>
<tr>
<td>house意为别墅/apartment公寓/home意为家</td>
<td>家</td>
<td>All you have to do is make a home video</td>
</tr>
<tr>
<td>volume</td>
<td>声音</td>
<td>turn on the TV volume</td>
</tr>
<tr>
<td>prepare</td>
<td>准备</td>
<td>I’m preparing to tell you</td>
</tr>
<tr>
<td>How are you？</td>
<td>最近怎么样</td>
<td>Couldn’t be better</td>
</tr>
<tr>
<td>How are you doing?</td>
<td>最近怎么样</td>
<td>Keeping busy</td>
</tr>
<tr>
<td>How’s everything?</td>
<td>最近怎么样</td>
<td>Can’t complain</td>
</tr>
<tr>
<td>How’s it going?</td>
<td>最近怎么样</td>
<td>Been getting by</td>
</tr>
<tr>
<td>How’s your business?</td>
<td>最近怎么样</td>
<td>Not so good</td>
</tr>
</tbody></table>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/单词/">单词</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="blog-go-big-or-go-home-2" class="article article-type-blog" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/17/go-big-or-go-home-2/"
    >go big or go home-2</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/17/go-big-or-go-home-2/" class="article-date">
  <time datetime="2020-03-17T14:03:22.000Z" itemprop="datePublished">2020-03-17</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/English/">English</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <table>
<thead>
<tr>
<th>单词/短语</th>
<th>中文</th>
<th>句子</th>
</tr>
</thead>
<tbody><tr>
<td>stadium</td>
<td>体育场</td>
<td>I often play football in the stadium</td>
</tr>
<tr>
<td>reply</td>
<td>回复</td>
<td>I’m waiting for your reply</td>
</tr>
<tr>
<td>standard</td>
<td>标准</td>
<td>Such a standard figure</td>
</tr>
<tr>
<td>honour</td>
<td>荣誉</td>
<td>It’s an honour to graduate from this school</td>
</tr>
<tr>
<td>village</td>
<td>乡村</td>
<td>I like village life</td>
</tr>
<tr>
<td>ever since</td>
<td>自从…时起</td>
<td>They lived there ever since they married</td>
</tr>
<tr>
<td>turn up</td>
<td>调高</td>
<td>Turn up the TV volume</td>
</tr>
<tr>
<td>volume</td>
<td>音量</td>
<td>Turn on the volume</td>
</tr>
<tr>
<td>get on with</td>
<td>与…相处</td>
<td>She likes get on with animals</td>
</tr>
<tr>
<td>tourism</td>
<td>旅游</td>
<td>I like tourism around the world</td>
</tr>
<tr>
<td>industry</td>
<td>行业</td>
<td>The tourism industry is getting worse</td>
</tr>
<tr>
<td>experience</td>
<td>经验</td>
<td>He has five years of programming experience</td>
</tr>
<tr>
<td>sorrows</td>
<td>悲伤</td>
<td>I often share happiness and sorrows with my friends</td>
</tr>
</tbody></table>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/单词/">单词</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="blog-go big or go home" class="article article-type-blog" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/16/go big or go home/"
    >go big or go home</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/16/go big or go home/" class="article-date">
  <time datetime="2020-03-16T14:10:25.000Z" itemprop="datePublished">2020-03-16</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/English/">English</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <table>
<thead>
<tr>
<th>单词/短语</th>
<th>中文</th>
<th>句子</th>
</tr>
</thead>
<tbody><tr>
<td>early birld</td>
<td>早起的鸟儿</td>
<td>Early birld gets the worm</td>
</tr>
<tr>
<td>happiness</td>
<td>开心幸福</td>
<td>I often share happiness and sorrows with my friends</td>
</tr>
<tr>
<td>jail</td>
<td>监狱</td>
<td>He may be jailed for killing</td>
</tr>
<tr>
<td>breaks the law</td>
<td>打破法律</td>
<td>He was jailed for breaking the law</td>
</tr>
<tr>
<td>chemical reaction</td>
<td>化学反应</td>
<td>When you smiling,you will experience a chemical reaction</td>
</tr>
<tr>
<td>produces good-feeling chemicals</td>
<td>同上</td>
<td>When you smiling,you produces good-feeling chemicals</td>
</tr>
<tr>
<td>fake simle</td>
<td>假笑</td>
<td>I may be fake simle when I together with my boss</td>
</tr>
<tr>
<td>relax</td>
<td>放松</td>
<td>I want to keep relaxing in holiday</td>
</tr>
<tr>
<td>look younger</td>
<td>看起来年轻</td>
<td>You look younger than your age</td>
</tr>
<tr>
<td>sick</td>
<td>生病</td>
<td>The little girl may be sick</td>
</tr>
<tr>
<td>pressure</td>
<td>压力</td>
<td>Post-90s pressure</td>
</tr>
<tr>
<td>mortgage</td>
<td>房贷</td>
<td>He feel pressure beacuse of the mortgage</td>
</tr>
<tr>
<td>get sick</td>
<td>生病</td>
<td>I don’t want to get sick</td>
</tr>
<tr>
<td>vocabulary</td>
<td>词汇</td>
<td>Chinese vocabulary</td>
</tr>
<tr>
<td>busy with</td>
<td>忙于工作</td>
<td>I’m too busy with my work</td>
</tr>
<tr>
<td>crying</td>
<td>哭</td>
<td>The little girl is crying</td>
</tr>
<tr>
<td>get lost</td>
<td>走丢</td>
<td>She got lost</td>
</tr>
<tr>
<td>toothache</td>
<td>牙痛</td>
<td>Doctor,I have a toothache</td>
</tr>
<tr>
<td>glass</td>
<td>杯子</td>
<td>The glass is broken</td>
</tr>
<tr>
<td>stomachache</td>
<td>胃痛</td>
<td>The boy has a stomachache</td>
</tr>
<tr>
<td>live</td>
<td>注意读音[lɪv , laɪv]</td>
<td>I live in Beijing；live Spring gala</td>
</tr>
<tr>
<td>farther</td>
<td>更远</td>
<td>The higher you climb,The farther you can see</td>
</tr>
<tr>
<td>suffer</td>
<td>伤害</td>
<td>The longer the war lasts,the more the people there will suffer</td>
</tr>
</tbody></table>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/单词/">单词</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="bloe-volatile关键字" class="article article-type-bloe" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/11/volatile关键字/"
    >volatile关键字</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/11/volatile关键字/" class="article-date">
  <time datetime="2020-03-11T11:19:42.000Z" itemprop="datePublished">2020-03-11</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/高并发系列/">高并发系列</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h3 id="本文还是以面试提问的方式来说一下volatile"><a href="#本文还是以面试提问的方式来说一下volatile" class="headerlink" title="本文还是以面试提问的方式来说一下volatile"></a>本文还是以面试提问的方式来说一下volatile</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.Java并发这块了解的怎么样？说说对volatile的理解？</span><br><span class="line">答:</span><br><span class="line">  (1).保证了不同线程对该变量操作的内存可见性</span><br><span class="line">  (2).禁止指令重排</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">2.能不能详细说说什么是内存可见性，什么又是重排序呢？</span><br><span class="line">答：</span><br><span class="line">  这里先从Java内存模型说起。</span><br><span class="line">  Java虚拟机规范一种Java内存模型(JMM) 用来屏蔽各种硬件和操作系统的内存访问差异，让Java程序在各种平台上都能达到一致的内存访问效果。</span><br><span class="line">  JMM规定所有变量都是存在主存中的，每个线程又包含自己的工作内存，方便理解就可以看成CPU上的寄存器或者高速缓存，所以线程的操作都是以工作内存为主，它们只能访问自己的工作内存，且前后都要把值同步回主内存。</span><br><span class="line">  在线程执行时，首先会从主存中读变量值，在下载到工作内存的副本中，然后在传给处理器执行，执行完毕后再给工作内存中的副本赋值，随后工作内存再把值传回给主存，主存中的值才更新。</span><br><span class="line">  这就引出了一个问题，比如执行 i = i + 1或i++</span><br><span class="line">  假设初始i值为0，当只有一个线程执行它时，结果肯定得到1，当两个线程执行时，会得到结果2吗？可能会出现这种情况：</span><br><span class="line">  </span><br><span class="line">线程1： load i from 主存    // i = 0</span><br><span class="line">        i + 1  // i = 1</span><br><span class="line">线程2： load i from主存  // 因为线程1还没将i的值写回主存，所以i还是0</span><br><span class="line">        i +  1 //i = 1</span><br><span class="line">线程1:  save i to 主存</span><br><span class="line">线程2： save i to 主存</span><br><span class="line">  如果两个线程按照上面的执行流程，那么最后i的值会是1，如果最后的写回生效的慢，在读取i的值，都有可能是0，这就是缓存不一致问题。</span><br><span class="line">分析</span><br><span class="line">结合内存屏障这个概念对volatile的读写操作深入理解的话：</span><br><span class="line"></span><br><span class="line">第一步：读</span><br><span class="line">在第一步操作的指令后，会增加两个内存屏障：</span><br><span class="line"></span><br><span class="line">在Volatile读操作后插入LoadLoad屏障，防止前面的Volatile读与后面的普通读重排序</span><br><span class="line">在Volatile读操作后插入LoadStore屏障，防止前面的Volatile读与后面的普通写重排序</span><br><span class="line">因此第一个指令和它后续的普通读写操作会被保证没有重排序来捣乱。通常是去内存中去读。</span><br><span class="line"></span><br><span class="line">那么问题又来了，为什么通常去内存中读？</span><br><span class="line"></span><br><span class="line">其实这个问题要说细的话可以很细，大概就两个关键点吧：</span><br><span class="line"></span><br><span class="line">volatile的写操作的缓存失效机制</span><br><span class="line">最后一个对volatile变量执行写操作的CPU，由于在它对应的缓存中保有最新的值，因此可以不用再去主存里面获取</span><br><span class="line">具体看下面第三步的分析。</span><br><span class="line"></span><br><span class="line">第二步：自增</span><br><span class="line">这个步骤没什么特别的，就是在CPU自身的高速缓存(寄存器，L1-L3 Cache)中完成。不涉及到缓存和内存的交互。</span><br><span class="line"></span><br><span class="line">第三步：写</span><br><span class="line">volatile写算是一个重点。</span><br><span class="line"></span><br><span class="line">根据JMM对于volatile变量类型的语义规范：volatile在编译之后，会在变量写操作时添加LOCK前缀指令。这个LOCK前缀指令在多核处理器的环境中，有这样的作用：</span><br><span class="line"></span><br><span class="line">通知CPU将当前处理器缓存行的数据写回到系统主存中</span><br><span class="line">该写回操作将使其他CPU缓存了该内存地址的数据无效</span><br><span class="line">另外，内存屏障在volatile的写操作中起到了很大的作用，来保证上面两点能够实现：</span><br><span class="line"></span><br><span class="line">在Volatile写操作前插入StoreStore屏障，防止前面其他写与本次Volatile写重排序</span><br><span class="line">在Volatile写操作后插入StoreLoad屏障，防止本次的Volatile写与后面的读操作重排序</span><br><span class="line"></span><br><span class="line">JMM主要就是围绕着如何在并发过程中如何处理原子性，可见性和有序性这三个特征来建立的，通过解决着三个问题，可以接触缓存不一致的问题，而volatile跟可见性和有序性都有关。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">3.那你具体说说这三个特性呢？</span><br><span class="line">  (1).原子性：Java中，对基本数据类型的读取和赋值操作是原子性操作，也就是这些操作是不可中断的，要做一定做完。JMM只实现了基本的原子性，像上面i++那样的操作，必须借助synchronized和Lock来保证整块代码的原子性了，线程在锁释放之前，必然会把i的值刷回到主存的。</span><br><span class="line">  (2).可见性：可见性Java就是利用volatile来提供可见性的，当一个变量被volatile修饰时，那么对它的修改会立刻刷新到主存，当其他线程需要读取该变量时，会去内存中读取新值。而普通变量则不能保证这一点。</span><br><span class="line">  其实通过synchronized和Lock也能够保证可见性，线程在释放锁之前，会把共享变量值都刷回主存，但是synchronized和Lock的开销都更大。</span><br><span class="line">  (3).有序性：JMM是允许编译器和处理器对指令重排序的，但是规定了as-if-serial语义，即不管怎么重排序，程序的执行结果不能改变。比如下面的程序段：</span><br><span class="line">double pi = 3.14;    //A</span><br><span class="line">double r = 1;        //B</span><br><span class="line">double s= pi * r * r;//C</span><br><span class="line">上面的语句，可以按照A-&gt;B-&gt;C执行，结果为3.14,但是也可以按照B-&gt;A-&gt;C的顺序执行，因为A、B是两句独立的语句，而C则依赖于A、B，所以A、B可以重排序，但是C却不能排到A、B的前面。JMM保证了重排序不会影响到单线程的执行，但是在多线程中却容易出问题。</span><br><span class="line">比如这样的代码:</span><br><span class="line">int a = 0;</span><br><span class="line">bool flag = false;</span><br><span class="line"></span><br><span class="line">public void write() &#123;</span><br><span class="line">    a = 2;              //1</span><br><span class="line">    flag = true;        //2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void multiply() &#123;</span><br><span class="line">    if (flag) &#123;         //3</span><br><span class="line">        int ret = a * a;//4</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">write方法里的1和2做了重排序，线程1先对flag赋值为true，随后执行到线程2，ret直接计算出结果，再到线程1，这时候a才赋值为2,很明显迟了一步。</span><br><span class="line">这时候可以为flag加上volatile关键字，禁止重排序，可以确保程序的“有序性”，也可以上重量级的synchronized和Lock来保证有序性,它们能保证那一块区域里的代码都是一次性执行完毕的。</span><br><span class="line">ps：这里提一句：volatile的禁止指令重排是在jdk1.6之后才做了修复，这也是jdk1.6之前用双重锁校验的synchronized单例模式会有线程不安全的问题原因。</span><br><span class="line">另外，JMM具备一些先天的有序性,即不需要通过任何手段就可以保证的有序性，通常称为happens-before原则。具体如下：</span><br><span class="line">1.程序顺序规则： 一个线程中的每个操作，happens-before于该线程中的任意后续操作</span><br><span class="line">2.监视器锁规则：对一个线程的解锁，happens-before于随后对这个线程的加锁</span><br><span class="line">3.volatile变量规则： 对一个volatile域的写，happens-before于后续对这个volatile域的读</span><br><span class="line">4.传递性：如果A happens-before B ,且 B happens-before C, 那么 A happens-before C</span><br><span class="line">5.start()规则： 如果线程A执行操作ThreadB_start()(启动线程B) ,  那么A线程的ThreadB_start()happens-before 于B中的任意操作</span><br><span class="line">6.join()原则： 如果A执行ThreadB.join()并且成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</span><br><span class="line">7.interrupt()原则： 对线程interrupt()方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测是否有中断发生</span><br><span class="line">8.finalize()原则：一个对象的初始化完成先行发生于它的finalize()方法的开始</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4.volatile关键字如何满足并发编程的三大特性的？</span><br><span class="line">当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存</span><br><span class="line">当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主存中读取共享变量。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">5.volatile可以保证可见性和有序性，但是能保证原子性吗？</span><br><span class="line">  首先我回答是不能保证原子性，要是说能保证，也只是对单个volatile变量的读/写具有原子性，但是对于类似volatile++这样的复合操作就无能为力了，比如下面的例子：</span><br><span class="line">public class Test &#123;</span><br><span class="line">    public volatile int inc = 0;</span><br><span class="line"> </span><br><span class="line">    public void increase() &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Test test = new Test();</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            new Thread()&#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for(int j=0;j&lt;1000;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完</span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">按道理来说结果是10000，但是运行下很可能是个小于10000的值。有人可能会说volatile不是保证了可见性啊，一个线程对inc的修改，另外一个线程应该立刻看到啊！可是这里的操作inc++是个复合操作啊，包括读取inc的值，对其自增，然后再写回主存。</span><br><span class="line">假设线程A，读取了inc的值为10，这时候被阻塞了，因为没有对变量进行修改，触发不了volatile规则。</span><br><span class="line">线程B此时也读读inc的值，主存里inc的值依旧为10，做自增，然后立刻就被写回主存了，为11。</span><br><span class="line">此时又轮到线程A执行，由于工作内存里保存的是10，所以继续做自增，再写回主存，11又被写了一遍。所以虽然两个线程执行了两次increase()，结果却只加了一次。</span><br><span class="line">有人说，volatile不是会使缓存行无效的吗？但是这里线程A读取到线程B也进行操作之前，并没有修改inc值，所以线程B读取的时候，还是读的10。</span><br><span class="line">又有人说，线程B将11写回主存，不会把线程A的缓存行设为无效吗？但是线程A的读取操作已经做过了啊，只有在做读取操作时，发现自己缓存行无效，才会去读主存的值，所以这里线程A只能继续做自增了。</span><br><span class="line">综上所述，在这种复合操作的情景下，原子性的功能是维持不了了。但是volatile在上面那种设置flag值的例子里，由于对flag的读/写操作都是单步的，所以还是能保证原子性的。</span><br><span class="line">要想保证原子性，只能借助于synchronized,Lock以及并发包下的atomic的原子操作类了，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6.那你知道volatile的底层实现机制吗？</span><br><span class="line">如果把加入volatile关键字的代码和未加入volatile关键字的代码都生成汇编代码，会发现加入volatile关键字的代码会多出一个lock前缀指令。</span><br><span class="line">lock前缀指令实际相当于一个内存屏障，内存屏障提供了以下功能：</span><br><span class="line"></span><br><span class="line">1 . 重排序时不能把后面的指令重排序到内存屏障之前的位置</span><br><span class="line">2 . 使得本CPU的Cache写入内存</span><br><span class="line">3 . 写入动作也会引起别的CPU或者别的内核无效化其Cache，相当于让新写入的值对别的线程可见。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">7.你在哪里会使用到volatile，举几个例子？</span><br><span class="line">  (1).状态量标记，true/false</span><br><span class="line">  (2).单例模式双重检查锁</span><br></pre></td></tr></table></figure>


      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/volatile/">volatile</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/高并发/">高并发</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="blog-彻底搞懂ThreadLocal" class="article article-type-blog" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/10/彻底搞懂ThreadLocal/"
    >彻底搞懂ThreadLocal</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/10/彻底搞懂ThreadLocal/" class="article-date">
  <time datetime="2020-03-10T15:51:45.000Z" itemprop="datePublished">2020-03-10</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/高并发系列/">高并发系列</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h3 id="1-问：ThreadLocal了解吗？您能给我说说他的主要用途吗？"><a href="#1-问：ThreadLocal了解吗？您能给我说说他的主要用途吗？" class="headerlink" title="1.问：ThreadLocal了解吗？您能给我说说他的主要用途吗？"></a>1.问：ThreadLocal了解吗？您能给我说说他的主要用途吗？</h3><p>答：</p>
<p>从JAVA官方对ThreadLocal类的说明定义（定义在示例代码中）：ThreadLocal类用来提供线程内部的局部变量。这种变量在多线程环境下访问（通过get和set方法访问）时能保证各个线程的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是private static类型的，用于关联线程和线程上下文。</p>
<p>我们可以得知ThreadLocal的作用是：ThreadLocal的作用是提供线程内的局部变量，不同的线程之间不会相互干扰，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或组件之间一些公共变量的传递的复杂度。</p>
<p>上述可以概述为：ThreadLocal提供线程内部的局部变量，在本线程内随时随地可取，隔离其他线程。</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 该类提供了线程局部 (thread-local) 变量。 这些变量不同于它们的普通对应物，</span><br><span class="line"> * 因为访问某个变量（通过其 get 或 set 方法）的每个线程都有自己的局部变量</span><br><span class="line"> * 它独立于变量的初始化副本。ThreadLocal 实例通常是类中的 private static 字段</span><br><span class="line"> * 它们希望将状态与某一个线程（例如，用户 ID 或事务 ID）相关联。</span><br><span class="line"> *</span><br><span class="line"> * 例如，以下类生成对每个线程唯一的局部标识符。</span><br><span class="line"> * </span><br><span class="line"> * 线程 ID 是在第一次调用 UniqueThreadIdGenerator.getCurrentThreadId() 时分配的，</span><br><span class="line"> * 在后续调用中不会更改。</span><br><span class="line"> * &lt;pre&gt;</span><br><span class="line"> * import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"> *</span><br><span class="line"> * public class ThreadId &#123;</span><br><span class="line"> *     // 原子性整数，包含下一个分配的线程Thread ID </span><br><span class="line"> *     private static final AtomicInteger nextId = new AtomicInteger(0);</span><br><span class="line"> *</span><br><span class="line"> *     // 每一个线程对应的Thread ID</span><br><span class="line"> *     private static final ThreadLocal&lt;Integer&gt; threadId =</span><br><span class="line"> *         new ThreadLocal&lt;Integer&gt;() &#123;</span><br><span class="line"> *             @Override protected Integer initialValue() &#123;</span><br><span class="line"> *                 return nextId.getAndIncrement();</span><br><span class="line"> *         &#125;</span><br><span class="line"> *     &#125;;</span><br><span class="line"> *</span><br><span class="line"> *     // 返回当前线程对应的唯一Thread ID, 必要时会进行分配</span><br><span class="line"> *     public static int get() &#123;</span><br><span class="line"> *         return threadId.get();</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> * &lt;/pre&gt;</span><br><span class="line"> * 每个线程都保持对其线程局部变量副本的隐式引用，只要线程是活动的并且 ThreadLocal 实例是可访问的</span><br><span class="line"> * 在线程消失之后，其线程局部实例的所有副本都会被垃圾回收，（除非存在对这些副本的其他引用）。</span><br><span class="line"> *</span><br><span class="line"> * @author  Josh Bloch and Doug Lea</span><br><span class="line"> * @since   1.2</span><br><span class="line"> */</span><br><span class="line">public class ThreadLocal&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">     * 自定义哈希码（仅在ThreadLocalMaps中有用）</span><br><span class="line">     * 可用于降低hash冲突</span><br><span class="line">     */</span><br><span class="line">    private final int threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 生成下一个哈希码hashCode. 生成操作是原子性的. 从0开始</span><br><span class="line">     * </span><br><span class="line">     */</span><br><span class="line">    private static AtomicInteger nextHashCode =</span><br><span class="line">        new AtomicInteger();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 表示了连续分配的两个ThreadLocal实例的threadLocalHashCode值的增量 </span><br><span class="line">     */</span><br><span class="line">    private static final int HASH_INCREMENT = 0x61c88647;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回下一个哈希码hashCode</span><br><span class="line">     */</span><br><span class="line">    private static int nextHashCode() &#123;</span><br><span class="line">        return nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中nextHashCode()方法就是一个原子类不停地去加上0x61c88647，这是一个很特别的数，叫斐波那契散列（Fibonacci Hashing），斐波那契又有一个名称叫黄金分割，也就是说将这个数作为哈希值的增量将会使哈希表的分布更为均匀。</p>
<h3 id="2-问：ThreadLocal实现原理是什么，它是怎么样做到局部变量不同的线程之间不会相互干扰的？"><a href="#2-问：ThreadLocal实现原理是什么，它是怎么样做到局部变量不同的线程之间不会相互干扰的？" class="headerlink" title="2.问：ThreadLocal实现原理是什么，它是怎么样做到局部变量不同的线程之间不会相互干扰的？"></a>2.问：ThreadLocal实现原理是什么，它是怎么样做到局部变量不同的线程之间不会相互干扰的？</h3><p>答：</p>
<p>通常，如果我不去看源代码的话，我猜ThreadLocal是这样子设计的：每个ThreadLocal类都创建一个Map，然后用线程的ID threadID作为Map的key，要存储的局部变量作为Map的value，这样就能达到各个线程的值隔离的效果。这是最简单的设计方法，JDK最早期的ThreadLocal就是这样设计的。</p>
<p>但是，JDK后面优化了设计方案，现时JDK8 ThreadLocal的设计是：每个Thread维护一个ThreadLocalMap哈希表，这个哈希表的key是ThreadLocal实例本身，value才是真正要存储的值Object。</p>
<p>这个设计与我们一开始说的设计刚好相反，这样设计有如下几点优势：<br>1） 这样设计之后每个Map存储的Entry数量就会变小，因为之前的存储数量由Thread的数量决定，现在是由ThreadLocal的数量决定。</p>
<h4 id="关于这点需要做一个解释：至于jdk8之前的做法是有多少线程map中就存放多少，自然map很大，链表很长效率很低；jdk1-8之后用ThreadLocal作为key，也就是说每个线程内部维护一个ThreadLocalMap，每次set时都有偏移量，黄金分割点，不会导致key重复，map小冲突就小，效率高，即使还会存在冲突，不过没关系，这个ThreadLocal是不存在Next的所以不会存在链表，继续增加偏移量寻找下一个空点。"><a href="#关于这点需要做一个解释：至于jdk8之前的做法是有多少线程map中就存放多少，自然map很大，链表很长效率很低；jdk1-8之后用ThreadLocal作为key，也就是说每个线程内部维护一个ThreadLocalMap，每次set时都有偏移量，黄金分割点，不会导致key重复，map小冲突就小，效率高，即使还会存在冲突，不过没关系，这个ThreadLocal是不存在Next的所以不会存在链表，继续增加偏移量寻找下一个空点。" class="headerlink" title="关于这点需要做一个解释：至于jdk8之前的做法是有多少线程map中就存放多少，自然map很大，链表很长效率很低；jdk1.8之后用ThreadLocal作为key，也就是说每个线程内部维护一个ThreadLocalMap，每次set时都有偏移量，黄金分割点，不会导致key重复，map小冲突就小，效率高，即使还会存在冲突，不过没关系，这个ThreadLocal是不存在Next的所以不会存在链表，继续增加偏移量寻找下一个空点。"></a>关于这点需要做一个解释：至于jdk8之前的做法是有多少线程map中就存放多少，自然map很大，链表很长效率很低；jdk1.8之后用ThreadLocal作为key，也就是说每个线程内部维护一个ThreadLocalMap，每次set时都有偏移量，黄金分割点，不会导致key重复，map小冲突就小，效率高，即使还会存在冲突，不过没关系，这个ThreadLocal是不存在Next的所以不会存在链表，继续增加偏移量寻找下一个空点。</h4><p>2） 当Thread销毁之后，对应的ThreadLocalMap也会随之销毁，能减少内存的使用。</p>
<h3 id="3-问：您能说说ThreadLocal常用操作的底层实现原理吗？如存储set-T-value-，获取get-，删除remove-等操作。"><a href="#3-问：您能说说ThreadLocal常用操作的底层实现原理吗？如存储set-T-value-，获取get-，删除remove-等操作。" class="headerlink" title="3.问：您能说说ThreadLocal常用操作的底层实现原理吗？如存储set(T value)，获取get()，删除remove()等操作。"></a>3.问：您能说说ThreadLocal常用操作的底层实现原理吗？如存储set(T value)，获取get()，删除remove()等操作。</h3><p>答：</p>
<p>调用get()操作获取ThreadLocal中对应当前线程存储的值时，进行了如下操作：<br>1 ) 获取当前线程Thread对象，进而获取此线程对象中维护的ThreadLocalMap对象。<br>2 ) 判断当前的ThreadLocalMap是否存在：</p>
<p>如果存在，则以当前的ThreadLocal 为 key，调用ThreadLocalMap中的getEntry方法获取对应的存储实体 e。找到对应的存储实体 e，获取存储实体 e 对应的 value值，即为我们想要的当前线程对应此ThreadLocal的值，返回结果值。<br>如果不存在，则证明此线程没有维护的ThreadLocalMap对象，调用setInitialValue方法进行初始化。返回setInitialValue初始化的值。</p>
<p>setInitialValue方法的操作如下：<br>1 ) 调用initialValue获取初始化的值。<br>2 ) 获取当前线程Thread对象，进而获取此线程对象中维护的ThreadLocalMap对象。<br>3 ) 判断当前的ThreadLocalMap是否存在：</p>
<p>如果存在，则调用map.set设置此实体entry。</p>
<p>如果不存在，则调用createMap进行ThreadLocalMap对象的初始化，并将此实体entry作为第一个值存放至ThreadLocalMap中。</p>
<h3 id="4-问：对ThreadLocal的常用操作实际是对线程Thread中的ThreadLocalMap进行操作，核心是ThreadLocalMap这个哈希表，你能谈谈ThreadLocalMap的内部底层实现吗"><a href="#4-问：对ThreadLocal的常用操作实际是对线程Thread中的ThreadLocalMap进行操作，核心是ThreadLocalMap这个哈希表，你能谈谈ThreadLocalMap的内部底层实现吗" class="headerlink" title="4.问：对ThreadLocal的常用操作实际是对线程Thread中的ThreadLocalMap进行操作，核心是ThreadLocalMap这个哈希表，你能谈谈ThreadLocalMap的内部底层实现吗?"></a>4.问：对ThreadLocal的常用操作实际是对线程Thread中的ThreadLocalMap进行操作，核心是ThreadLocalMap这个哈希表，你能谈谈ThreadLocalMap的内部底层实现吗?</h3><p>答：</p>
<p>ThreadLocalMap的底层实现是一个定制的自定义HashMap哈希表，核心组成元素有：<br>1 ) Entry[] table;：底层哈希表 table, 必要时需要进行扩容，底层哈希表 table.length 长度必须是2的n次方。<br>2 ) int size;：实际存储键值对元素个数 entries<br>3 ) int threshold;：下一次扩容时的阈值，阈值 threshold = 底层哈希表table的长度 len * 2 / 3。当size &gt;= threshold时，遍历table并删除key为null的元素，如果删除后size &gt;= threshold*3/4时，需要对table进行扩容（详情请查看set(ThreadLocal&lt;?&gt; key, Object value)方法说明）。</p>
<p>其中Entry[] table;哈希表存储的核心元素是Entry，Entry包含：<br>1 ) ThreadLocal&lt;?&gt; k；：当前存储的ThreadLocal实例对象<br>2 ) Object value;：当前 ThreadLocal 对应储存的值value</p>
<p>需要注意的是，此Entry继承了弱引用 WeakReference，所以在使用ThreadLocalMap时，发现key == null，则意味着此key ThreadLocal不在被引用，需要将其从ThreadLocalMap哈希表中移除。(弱引用相关问题解释请查看 问答 5)</p>
<h3 id="5-问：ThreadLocalMap中的存储实体Entry使用ThreadLocal作为key，但这个Entry是继承弱引用WeakReference的，为什么要这样设计，使用了弱引用WeakReference会造成内存泄露问题吗？"><a href="#5-问：ThreadLocalMap中的存储实体Entry使用ThreadLocal作为key，但这个Entry是继承弱引用WeakReference的，为什么要这样设计，使用了弱引用WeakReference会造成内存泄露问题吗？" class="headerlink" title="5.问：ThreadLocalMap中的存储实体Entry使用ThreadLocal作为key，但这个Entry是继承弱引用WeakReference的，为什么要这样设计，使用了弱引用WeakReference会造成内存泄露问题吗？"></a>5.问：ThreadLocalMap中的存储实体Entry使用ThreadLocal作为key，但这个Entry是继承弱引用WeakReference的，为什么要这样设计，使用了弱引用WeakReference会造成内存泄露问题吗？</h3><p>答：</p>
<p>首先，回答这个问题之前，我需要解释一下什么是强引用，什么是弱引用。</p>
<p>我们在正常情况下，普遍使用的是强引用：<br>A a = new A();</p>
<p>B b = new B();复制代码当 a = null;b = null;时，一段时间后，JAVA垃圾回收机制GC会将 a 和 b 对应所分配的内存空间给回收。<br>但考虑这样一种情况：<br>C c = new C(b);<br>b = null;复制代码当 b 被设置成null时，那么是否意味这一段时间后GC工作可以回收 b 所分配的内存空间呢？答案是否定的，因为即使 b 被设置成null，但 c 仍然持有对 b 的引用，而且还是强引用，所以GC不会回收 b 原先所分配的空间，既不能回收，又不能使用，这就造成了 内存泄露。<br>那么如何处理呢？<br>可以通过c = null;，也可以使用弱引用WeakReference w = new WeakReference(b);。因为使用了弱引用WeakReference，GC是可以回收 b 原先所分配的空间的。<br>上述解释主要参考自：对ThreadLocal实现原理的一点思考</p>
<p>回到ThreadLocal的层面上，ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用来引用它，那么系统 GC 的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value 永远无法回收，造成内存泄漏。</p>
<p>其实，ThreadLocalMap的设计中已经考虑到这种情况，也加上了一些防护措施：在ThreadLocal的get(),set(),remove()的时候都会清除线程ThreadLocalMap里所有key为null的value。<br>但是这些被动的预防措施并不能保证不会内存泄漏：</p>
<p>使用static的ThreadLocal，延长了ThreadLocal的生命周期，可能导致的内存泄漏（参考ThreadLocal 内存泄露的实例分析）。</p>
<p>分配使用了ThreadLocal又不再调用get(),set(),remove()方法，那么就会导致内存泄漏。</p>
<p>从表面上看内存泄漏的根源在于使用了弱引用。网上的文章大多着重分析ThreadLocal使用了弱引用会导致内存泄漏，但是另一个问题也同样值得思考：为什么使用弱引用而不是强引用？<br>我们先来看看官方文档的说法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">To help deal with very large and long-lived usages, </span><br><span class="line">the hash table entries use WeakReferences for keys.</span><br></pre></td></tr></table></figure>

<p>为了应对非常大和长时间的用途，哈希表使用弱引用的 key。<br>下面我们分两种情况讨论：</p>
<p>key 使用强引用：引用的ThreadLocal的对象被回收了，但是ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏。</p>
<p>key 使用弱引用：引用的ThreadLocal的对象被回收了，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收。value在下一次ThreadLocalMap调用get(),set(),remove()的时候会被清除。</p>
<p>比较两种情况，我们可以发现：由于ThreadLocalMap的生命周期跟Thread一样长，如果都没有手动删除对应key，都会导致内存泄漏，但是使用弱引用可以多一层保障：弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用get(),set(),remove()的时候会被清除。</p>
<p>因此，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。<br>综合上面的分析，我们可以理解ThreadLocal内存泄漏的前因后果，那么怎么避免内存泄漏呢？<br>每次使用完ThreadLocal，都调用它的remove()方法，清除数据。<br>在使用线程池的情况下，没有及时清理ThreadLocal，不仅是内存泄漏的问题，更严重的是可能导致业务逻辑出现问题。所以，使用ThreadLocal就跟加锁完要解锁一样，用完就清理。</p>
<h3 id="6-问：ThreadLocal和synchronized的区别"><a href="#6-问：ThreadLocal和synchronized的区别" class="headerlink" title="6.问：ThreadLocal和synchronized的区别?"></a>6.问：ThreadLocal和synchronized的区别?</h3><p>答：ThreadLocal和synchronized关键字都用于处理多线程并发访问变量的问题，只是二者处理问题的角度和思路不同。</p>
<p>ThreadLocal是一个Java类,通过对当前线程中的局部变量的操作来解决不同线程的变量访问的冲突问题。所以，ThreadLocal提供了线程安全的共享对象机制，每个线程都拥有其副本。</p>
<p>Java中的synchronized是一个保留字，它依靠JVM的锁机制来实现临界区的函数或者变量的访问中的原子性。在同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量。此时，被用作“锁机制”的变量时多个线程共享的。</p>
<p>同步机制(synchronized关键字)采用了以“时间换空间”的方式，提供一份变量，让不同的线程排队访问。而ThreadLocal采用了“以空间换时间”的方式，为每一个线程都提供一份变量的副本，从而实现同时访问而互不影响。</p>
<h3 id="7-问：ThreadLocal在现时有什么应用场景？"><a href="#7-问：ThreadLocal在现时有什么应用场景？" class="headerlink" title="7.问：ThreadLocal在现时有什么应用场景？"></a>7.问：ThreadLocal在现时有什么应用场景？</h3><p>答：总的来说ThreadLocal主要是解决2种类型的问题：</p>
<p>解决并发问题：使用ThreadLocal代替synchronized来保证线程安全。同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。</p>
<p>解决数据存储问题：ThreadLocal为变量在每个线程中都创建了一个副本，所以每个线程可以访问自己内部的副本变量，不同线程之间不会互相干扰。如一个Parameter对象的数据需要在多个模块中使用，如果采用参数传递的方式，显然会增加模块之间的耦合性。此时我们可以使用ThreadLocal解决。</p>
<p>应用场景：<br>Spring使用ThreadLocal解决线程安全问题</p>
<p>我们知道在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域。就是因为Spring对一些Bean（如RequestContextHolder、TransactionSynchronizationManager、LocaleContextHolder等）中非线程安全状态采用ThreadLocal进行处理，让它们也成为线程安全的状态，因为有状态的Bean就可以在多线程中共享了。</p>
<p>一般的Web应用划分为展现层、服务层和持久层三个层次，在不同的层中编写对应的逻辑，下层通过接口向上层开放功能调用。在一般情况下，从接收请求到返回响应所经过的所有程序调用都同属于一个线程ThreadLocal是解决线程安全问题一个很好的思路，它通过为每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题。在很多情况下，ThreadLocal比直接使用synchronized同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="1-ThreadLocal提供线程内部的局部变量，在本线程内随时随地可取，隔离其他线程。"><a href="#1-ThreadLocal提供线程内部的局部变量，在本线程内随时随地可取，隔离其他线程。" class="headerlink" title="1.ThreadLocal提供线程内部的局部变量，在本线程内随时随地可取，隔离其他线程。"></a>1.ThreadLocal提供线程内部的局部变量，在本线程内随时随地可取，隔离其他线程。</h3><h3 id="2-ThreadLocal的设计是：每个Thread维护一个ThreadLocalMap哈希表，这个哈希表的key是ThreadLocal实例本身，value才是真正要存储的值Object。"><a href="#2-ThreadLocal的设计是：每个Thread维护一个ThreadLocalMap哈希表，这个哈希表的key是ThreadLocal实例本身，value才是真正要存储的值Object。" class="headerlink" title="2.ThreadLocal的设计是：每个Thread维护一个ThreadLocalMap哈希表，这个哈希表的key是ThreadLocal实例本身，value才是真正要存储的值Object。"></a>2.ThreadLocal的设计是：每个Thread维护一个ThreadLocalMap哈希表，这个哈希表的key是ThreadLocal实例本身，value才是真正要存储的值Object。</h3><h3 id="3-对ThreadLocal的常用操作实际是对线程Thread中的ThreadLocalMap进行操作。"><a href="#3-对ThreadLocal的常用操作实际是对线程Thread中的ThreadLocalMap进行操作。" class="headerlink" title="3.对ThreadLocal的常用操作实际是对线程Thread中的ThreadLocalMap进行操作。"></a>3.对ThreadLocal的常用操作实际是对线程Thread中的ThreadLocalMap进行操作。</h3><h3 id="4-ThreadLocalMap的底层实现是一个定制的自定义HashMap哈希表，ThreadLocalMap的阈值threshold-底层哈希表table的长度-len-2-3，当实际存储元素个数size-大于或等于-阈值threshold的-3-4-时size-gt-threshold-3-4，则对底层哈希表数组table进行扩容操作。"><a href="#4-ThreadLocalMap的底层实现是一个定制的自定义HashMap哈希表，ThreadLocalMap的阈值threshold-底层哈希表table的长度-len-2-3，当实际存储元素个数size-大于或等于-阈值threshold的-3-4-时size-gt-threshold-3-4，则对底层哈希表数组table进行扩容操作。" class="headerlink" title="4.ThreadLocalMap的底层实现是一个定制的自定义HashMap哈希表，ThreadLocalMap的阈值threshold = 底层哈希表table的长度 len * 2 / 3，当实际存储元素个数size 大于或等于 阈值threshold的 3/4 时size &gt;= threshold*3/4，则对底层哈希表数组table进行扩容操作。"></a>4.ThreadLocalMap的底层实现是一个定制的自定义HashMap哈希表，ThreadLocalMap的阈值threshold = 底层哈希表table的长度 len * 2 / 3，当实际存储元素个数size 大于或等于 阈值threshold的 3/4 时size &gt;= threshold*3/4，则对底层哈希表数组table进行扩容操作。</h3><h3 id="5-ThreadLocalMap中的哈希表Entry-table存储的核心元素是Entry，存储的key是ThreadLocal实例对象，value是ThreadLocal-对应储存的值value。需要注意的是，此Entry继承了弱引用-WeakReference，所以在使用ThreadLocalMap时，发现key-null，则意味着此key-ThreadLocal不在被引用，需要将其从ThreadLocalMap哈希表中移除。"><a href="#5-ThreadLocalMap中的哈希表Entry-table存储的核心元素是Entry，存储的key是ThreadLocal实例对象，value是ThreadLocal-对应储存的值value。需要注意的是，此Entry继承了弱引用-WeakReference，所以在使用ThreadLocalMap时，发现key-null，则意味着此key-ThreadLocal不在被引用，需要将其从ThreadLocalMap哈希表中移除。" class="headerlink" title="5.ThreadLocalMap中的哈希表Entry[] table存储的核心元素是Entry，存储的key是ThreadLocal实例对象，value是ThreadLocal 对应储存的值value。需要注意的是，此Entry继承了弱引用 WeakReference，所以在使用ThreadLocalMap时，发现key == null，则意味着此key  ThreadLocal不在被引用，需要将其从ThreadLocalMap哈希表中移除。"></a>5.ThreadLocalMap中的哈希表Entry[] table存储的核心元素是Entry，存储的key是ThreadLocal实例对象，value是ThreadLocal 对应储存的值value。需要注意的是，此Entry继承了弱引用 WeakReference，所以在使用ThreadLocalMap时，发现key == null，则意味着此key  ThreadLocal不在被引用，需要将其从ThreadLocalMap哈希表中移除。</h3><h3 id="6-ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用来引用它，那么系统-GC-的时候，这个ThreadLocal势必会被回收。所以，在ThreadLocal的get-set-remove-的时候都会清除线程ThreadLocalMap里所有key为null的value。如果我们不主动调用上述操作，则会导致内存泄露。"><a href="#6-ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用来引用它，那么系统-GC-的时候，这个ThreadLocal势必会被回收。所以，在ThreadLocal的get-set-remove-的时候都会清除线程ThreadLocalMap里所有key为null的value。如果我们不主动调用上述操作，则会导致内存泄露。" class="headerlink" title="6.ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用来引用它，那么系统 GC 的时候，这个ThreadLocal势必会被回收。所以，在ThreadLocal的get(),set(),remove()的时候都会清除线程ThreadLocalMap里所有key为null的value。如果我们不主动调用上述操作，则会导致内存泄露。"></a>6.ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用来引用它，那么系统 GC 的时候，这个ThreadLocal势必会被回收。所以，在ThreadLocal的get(),set(),remove()的时候都会清除线程ThreadLocalMap里所有key为null的value。如果我们不主动调用上述操作，则会导致内存泄露。</h3><h3 id="7-为了安全地使用ThreadLocal，必须要像每次使用完锁就解锁一样，在每次使用完ThreadLocal后都要调用remove-来清理无用的Entry。这在操作在使用线程池时尤为重要。"><a href="#7-为了安全地使用ThreadLocal，必须要像每次使用完锁就解锁一样，在每次使用完ThreadLocal后都要调用remove-来清理无用的Entry。这在操作在使用线程池时尤为重要。" class="headerlink" title="7.为了安全地使用ThreadLocal，必须要像每次使用完锁就解锁一样，在每次使用完ThreadLocal后都要调用remove()来清理无用的Entry。这在操作在使用线程池时尤为重要。"></a>7.为了安全地使用ThreadLocal，必须要像每次使用完锁就解锁一样，在每次使用完ThreadLocal后都要调用remove()来清理无用的Entry。这在操作在使用线程池时尤为重要。</h3><h3 id="8-ThreadLocal和synchronized的区别：同步机制-synchronized关键字-采用了以“时间换空间”的方式，提供一份变量，让不同的线程排队访问。而ThreadLocal采用了“以空间换时间”的方式，为每一个线程都提供一份变量的副本，从而实现同时访问而互不影响。"><a href="#8-ThreadLocal和synchronized的区别：同步机制-synchronized关键字-采用了以“时间换空间”的方式，提供一份变量，让不同的线程排队访问。而ThreadLocal采用了“以空间换时间”的方式，为每一个线程都提供一份变量的副本，从而实现同时访问而互不影响。" class="headerlink" title="8.ThreadLocal和synchronized的区别：同步机制(synchronized关键字)采用了以“时间换空间”的方式，提供一份变量，让不同的线程排队访问。而ThreadLocal采用了“以空间换时间”的方式，为每一个线程都提供一份变量的副本，从而实现同时访问而互不影响。"></a>8.ThreadLocal和synchronized的区别：同步机制(synchronized关键字)采用了以“时间换空间”的方式，提供一份变量，让不同的线程排队访问。而ThreadLocal采用了“以空间换时间”的方式，为每一个线程都提供一份变量的副本，从而实现同时访问而互不影响。</h3><h3 id="9-ThreadLocal主要是解决2种类型的问题：A-解决并发问题：使用ThreadLocal代替同步机制解决并发问题。B-解决数据存储问题：如一个Parameter对象的数据需要在多个模块中使用，如果采用参数传递的方式，显然会增加模块之间的耦合性。此时我们可以使用ThreadLocal解决。"><a href="#9-ThreadLocal主要是解决2种类型的问题：A-解决并发问题：使用ThreadLocal代替同步机制解决并发问题。B-解决数据存储问题：如一个Parameter对象的数据需要在多个模块中使用，如果采用参数传递的方式，显然会增加模块之间的耦合性。此时我们可以使用ThreadLocal解决。" class="headerlink" title="9.ThreadLocal主要是解决2种类型的问题：A. 解决并发问题：使用ThreadLocal代替同步机制解决并发问题。B. 解决数据存储问题：如一个Parameter对象的数据需要在多个模块中使用，如果采用参数传递的方式，显然会增加模块之间的耦合性。此时我们可以使用ThreadLocal解决。"></a>9.ThreadLocal主要是解决2种类型的问题：A. 解决并发问题：使用ThreadLocal代替同步机制解决并发问题。B. 解决数据存储问题：如一个Parameter对象的数据需要在多个模块中使用，如果采用参数传递的方式，显然会增加模块之间的耦合性。此时我们可以使用ThreadLocal解决。</h3><p>作者：liangzzz<br>链接：<a href="https://juejin.im/post/5a0e985df265da430e4ebb92" target="_blank" rel="noopener">https://juejin.im/post/5a0e985df265da430e4ebb92</a><br>来源：掘金<br>中间加上了自己的理解</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ThreadLocal/">ThreadLocal</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/高并发/">高并发</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="blog-不得不说的Java‘锁’事" class="article article-type-blog" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/09/不得不说的Java‘锁’事/"
    >不得不说的Java‘锁’事</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/09/不得不说的Java‘锁’事/" class="article-date">
  <time datetime="2020-03-09T15:46:23.000Z" itemprop="datePublished">2020-03-09</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/高并发系列/">高并发系列</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>水文一篇<br>转载<br><a href="https://tech.meituan.com/2018/11/15/java-lock.html" target="_blank" rel="noopener">https://tech.meituan.com/2018/11/15/java-lock.html</a></p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/锁/">锁</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/高并发/">高并发</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="blog-静态代理-动态代理-AOP" class="article article-type-blog" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/07/静态代理-动态代理-AOP/"
    >静态代理/动态代理/AOP</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/07/静态代理-动态代理-AOP/" class="article-date">
  <time datetime="2020-03-07T09:04:35.000Z" itemprop="datePublished">2020-03-07</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java基础/">Java基础</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">本文是看过的一篇文章做的记录</span><br><span class="line">Java 代理模式实现方式，主要有如下五种方法</span><br><span class="line">静态代理，工程师编辑代理类代码，实现代理模式；在编译期就生成了代理类。</span><br><span class="line">基于 JDK 实现动态代理，通过jdk提供的工具方法Proxy.newProxyInstance动态构建全新的代理类(继承Proxy类，并持有InvocationHandler接口引用 )字节码文件并实例化对象返回。(jdk动态代理是由java内部的反射机制来实例化代理对象，并代理的调用委托类方法)</span><br><span class="line">基于CGlib 动态代理模式 基于继承被代理类生成代理子类，不用实现接口。只需要被代理类是非final 类即可。(cglib动态代理底层是借助asm字节码技术</span><br><span class="line">基于 Aspectj 实现动态代理（修改目标类的字节，织入代理的字节，在程序编译的时候 插入动态代理的字节码，不会生成全新的Class ）</span><br><span class="line">基于 instrumentation 实现动态代理（修改目标类的字节码、类装载的时候动态拦截去修改，基于javaagent） -javaagent:spring-instrument-4.3.8.RELEASE.jar （类装载的时候 插入动态代理的字节码，不会生成全新的Class ）</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Notes</span><br><span class="line">委托类 即指的是代理模式中的被代理对象</span><br><span class="line">代理类 指的是生成的代表委托类的一个角色</span><br><span class="line">静态代理实现</span><br><span class="line">静态代理是代理类在编译期间就创建好了，不是编译器生成的代理类，而是手动创建的类。在编译时就已经将接口，被代理类，代理类等确定下来。，软件设计中所指的代理一般是指静态代理，也就是在代码中显式指定的代理。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">实现步骤</span><br><span class="line">委托类和代理类之间的约束接口Cat</span><br><span class="line">约束接口实现类 Lion，实现 Cat 接口，委托角色</span><br><span class="line">代理类实现 FeederProxy，实现Cat 接口，并含有一个 Cat接口引用属性。 代理角色，代理 cat接口属性引用实例的行为并可以新增公共逻辑</span><br><span class="line">Cat接口</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">package org.vincent.proxy.staticproxy;/**</span><br><span class="line">* @author PengRong</span><br><span class="line">* @package org.vincent.proxy.staticproxy</span><br><span class="line">* @date 2018/12/15 - 17:12</span><br><span class="line">* @ProjectName JavaAopLearning</span><br><span class="line">* @Description: 静态代理类接口, 委托类和代理类都需要实现的接口规范。</span><br><span class="line">* 定义了一个猫科动物的两个行为接口，吃东西，奔跑。</span><br><span class="line">* 作为代理类 和委托类之间的约束接口</span><br><span class="line">*/public interface Cat &#123;    public String eatFood(String foodName);    public boolean running();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">委托类 Lion</span><br><span class="line">package org.vincent.proxy.staticproxy;/**</span><br><span class="line">* @author PengRong</span><br><span class="line">* @package org.vincent.proxy.staticproxy</span><br><span class="line">* @date 2018/12/15 - 17:15</span><br><span class="line">* @ProjectName JavaAopLearning</span><br><span class="line">* @Description: 狮子 实现了猫科动物接口Cat， 并实现了具体的行为。作为委托类实现</span><br><span class="line">*/public class Lion implements Cat &#123;    private String name;    private int runningSpeed;    public String getName() &#123;        return name;</span><br><span class="line">   &#125;    public void setName(String name) &#123;        this.name = name;</span><br><span class="line">   &#125;    public int getRunningSpeed() &#123;        return runningSpeed;</span><br><span class="line">   &#125;    public void setRunningSpeed(int runningSpeed) &#123;        this.runningSpeed = runningSpeed;</span><br><span class="line">   &#125;    public Lion() &#123;</span><br><span class="line">   &#125;    @Override</span><br><span class="line">   public String eatFood(String foodName) &#123;</span><br><span class="line">       String eat = this.name + &quot; Lion eat food. foodName = &quot; + foodName;</span><br><span class="line">       System.out.println(eat);        return eat;</span><br><span class="line">   &#125;    @Override</span><br><span class="line">   public boolean running() &#123;</span><br><span class="line">       System.out.println(this.name + &quot; Lion is running . Speed :&quot; + this.runningSpeed);        return false;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">代理类角色(FeederProxy)</span><br><span class="line">package org.vincent.proxy.staticproxy;/**</span><br><span class="line">* @author PengRong</span><br><span class="line">* @package org.vincent.proxy.staticproxy</span><br><span class="line">* @date 2018/12/15 - 17:19</span><br><span class="line">* @ProjectName JavaAopLearning</span><br><span class="line">* @Description: 饲养员 实现Cat接口，作为静态代理类实现。代理狮子的行为。</span><br><span class="line">* 代理类中可以新增一些其他行为，在实践中主要做的是参数校验的功能。</span><br><span class="line">*/public class FeederProxy implements Cat &#123;    private Cat cat;    public FeederProxy()&#123;&#125;    public FeederProxy(Cat cat) &#123;        if (cat instanceof Cat) &#123;            this.cat = cat;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;    public void setCat(Cat cat) &#123;        if (cat instanceof Cat) &#123;            this.cat = cat;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;    @Override</span><br><span class="line">   public String eatFood(String foodName) &#123;</span><br><span class="line">       System.out.println(&quot;proxy Lion exec eatFood &quot;);        return cat.eatFood(foodName);</span><br><span class="line">   &#125;    @Override</span><br><span class="line">   public boolean running() &#123;</span><br><span class="line">       System.out.println(&quot;proxy Lion exec running.&quot;);        return cat.running();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">静态代理类测试</span><br><span class="line">package org.vincent.proxy;import org.vincent.proxy.staticproxy.Cat;import org.vincent.proxy.staticproxy.FeederProxy;import org.vincent.proxy.staticproxy.Lion;/**</span><br><span class="line">* @author PengRong</span><br><span class="line">* @package org.vincent.proxy</span><br><span class="line">* @date 2018/12/15 - 18:31</span><br><span class="line">* @ProjectName JavaAopLearning</span><br><span class="line">* @Description: 静态代理类测试</span><br><span class="line">*/public class staticProxyTest &#123;    public static void main(String[] args) &#123;</span><br><span class="line">       Lion lion = new Lion();</span><br><span class="line">       lion.setName(&quot;狮子 小王&quot;);</span><br><span class="line">       lion.setRunningSpeed(100);        /**</span><br><span class="line">        * new 静态代理类，静态代理类在编译前已经创建好了，和动态代理的最大区别点</span><br><span class="line">        */</span><br><span class="line">       Cat proxy = new FeederProxy(lion);       System.out.println(Thread.currentThread().getName()+&quot; -- &quot; + proxy.eatFood(&quot;水牛&quot;));</span><br><span class="line">       proxy.running();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">静态代理很好的诠释了代理设计模式，代理模式最主要的就是有一个公共接口（Cat），一个委托类（Lion），一个代理类（FeederProxy）,代理类持有委托类的实例，代为执行具体类实例方法。 上面说到，代理模式就是在访问实际对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。这里的间接性就是指客户端不直接调用实际对象的方法，客户端依赖公共接口并使用代理类。 那么我们在代理过程中就可以加上一些其他用途。 就这个例子来说在 eatFood方法调用中，代理类在调用具体实现类之前添加System.out.println(&quot;proxy Lion exec eatFood &quot;);语句 就是添加间接性带来的收益。代理类存在的意义是为了增加一些公共的逻辑代码。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">动态代理类(基于接口实现)</span><br><span class="line">静态代理是代理类在代码运行前已经创建好，并生成class文件；动态代理类 是代理类在程序运行时创建的代理模式。</span><br><span class="line"></span><br><span class="line">动态代理类的代理类并不是在Java代码中定义的，而是在运行时根据我们在Java代码中的“指示”动态生成的。相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。 想想你有100个静态代理类，现在有一个需求，每个代理类都需要新增一个处理逻辑，你需要打开100个代理类在每个代理方法里面新增处理逻辑吗？ 有或者代理类有5个方法，每个方法都需要新增一个处理逻辑， 你需要在每个方法都手动新增处理逻辑吗？ 想想就挺无趣的。动态代理类帮你一键搞定。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">动态代理类涉及角色</span><br><span class="line">委托类和代理类实现的公共接口(Person.java)</span><br><span class="line">实现公共接口的具体委托类(SoftwareEngineer.java)</span><br><span class="line">InvocationHandler接口被Proxy类回调处理，一般实现 InvocationHandler 接口的类具有委托类引用，接口方法 invoke 中添加公共代码并调用委托类的接口方法。(PersonInvocationHandler.java)</span><br><span class="line">JDK提供生成动态代理类的核心类Proxy ( JDK 提供的Proxy.java)</span><br><span class="line">基于JDK技术 动态代理类技术核心 Proxy类和一个 InvocationHandler 接口</span><br><span class="line">java的java.lang.reflect包下提供了Proxy类和一个 InvocationHandler 接口，这个类Proxy定义了生成JDK动态代理类的方法 getProxyClass(ClassLoader loader,Class&lt;?&gt;... interfaces)生成动态代理类,返回class实例代表一个class文件。可以保存该 class 文件查看jdk生成的代理类文件长什么样</span><br><span class="line"></span><br><span class="line">该生成的动态代理类继承Proxy类，(重要特性) ，并实现公共接口。</span><br><span class="line"></span><br><span class="line">InvocationHandler这个接口 是被动态代理类回调的接口，我们所有需要增加的针对委托类的统一处理逻辑都增加到invoke 方法里面在调用委托类接口方法之前或之后 结束战斗。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">案例</span><br><span class="line">公共接口</span><br><span class="line">package org.vincent.proxy.dynamicproxy;/**</span><br><span class="line">* Created by PengRong on 2018/12/25.</span><br><span class="line">* 创建Person 接口 用于定义 委托类和代理类之间的约束行为</span><br><span class="line">*/public interface Person&#123;    /**</span><br><span class="line">    *</span><br><span class="line">    * @param name 人名</span><br><span class="line">    * @param dst 工作目的地</span><br><span class="line">    */</span><br><span class="line">   void goWorking(String name, String dst);    /**</span><br><span class="line">    * 获取名称</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   String getName( );    /**</span><br><span class="line">    * 设置名称</span><br><span class="line">    * @param name</span><br><span class="line">    */</span><br><span class="line">   void  setName(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">具体实现类，等下被委托，被代理的类 SoftwareEngineer.java</span><br><span class="line">package org.vincent.proxy.dynamicproxy;/**</span><br><span class="line">* Created by PengRong on 2018/12/25.</span><br><span class="line">* 动态代理委托类实现， 实现接口 Person。 被动态生成的代理类代理</span><br><span class="line">*/public class SoftwareEngineer implements Person&#123;    public  SoftwareEngineer()&#123;&#125;    public  SoftwareEngineer(String name)&#123;        this.name=name;</span><br><span class="line">   &#125;    private  String name;    public String getName() &#123;        return name;</span><br><span class="line">   &#125;    public void setName(String name) &#123;        this.name = name;</span><br><span class="line">   &#125;    @Override</span><br><span class="line">   public void goWorking(String name, String dst) &#123;</span><br><span class="line">       System.out.println(&quot;name =&quot;+name+&quot; ， 去 &quot;+dst +&quot; 工作&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">InvocationHandler 接口实现 PersonInvocationHandler.java</span><br><span class="line">package org.vincent.proxy.dynamicproxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.util.Arrays;/**</span><br><span class="line">* Created by PengRong on 2018/12/25.</span><br><span class="line">* PersonInvocationHandler 类 实现InvocationHandler接口，这个类中持有一个被代理对象(委托类)的实例target。该类别JDK Proxy类回调</span><br><span class="line">* InvocationHandler 接口中有一个invoke方法，当一个代理实例的方法被调用时，代理方法将被编码并分发到 InvocationHandler接口的invoke方法执行。</span><br><span class="line">*/public class PersonInvocationHandler&lt;T&gt; implements InvocationHandler &#123;    /**</span><br><span class="line">    * 被代理对象引用，invoke 方法里面method 需要使用这个 被代理对象</span><br><span class="line">    */</span><br><span class="line">   T target;    public PersonInvocationHandler(T target) &#123;        this.target = target;</span><br><span class="line">   &#125;    /**</span><br><span class="line">    * 在</span><br><span class="line">    * @param proxy  代表动态生成的 动态代理 对象实例</span><br><span class="line">    * @param method 代表被调用委托类的接口方法，和生成的代理类实例调用的接口方法是一致的，它对应的Method 实例</span><br><span class="line">    * @param args   代表调用接口方法对应的Object参数数组，如果接口是无参，则为null； 对于原始数据类型返回的他的包装类型。</span><br><span class="line">    * @return</span><br><span class="line">    * @throws Throwable</span><br><span class="line">    */</span><br><span class="line">   @Override</span><br><span class="line">   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;        /**</span><br><span class="line">        * 在转调具体目标对象之前，可以执行一些功能处理</span><br><span class="line">        */</span><br><span class="line">       System.out.println(&quot;被动态代理类回调执行, 代理类 proxyClass =&quot;+proxy.getClass()+&quot; 方法名: &quot; + method.getName() + &quot;方法. 方法返回类型：&quot;+method.getReturnType()</span><br><span class="line">       +&quot; 接口方法入参数组: &quot;+(args ==null ? &quot;null&quot; : Arrays.toString(args)));        /**</span><br><span class="line">        * 代理过程中插入监测方法,计算该方法耗时</span><br><span class="line">        */</span><br><span class="line">       MonitorUtil.start();</span><br><span class="line">       Thread.sleep(1);        /** 调用呗代理对象的真实方法，*/</span><br><span class="line">       Object result = method.invoke(target, args);</span><br><span class="line">       MonitorUtil.finish(method.getName());        return result;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PersonInvocationHandler invoke 方法中添加的公共代码，这里简单以统计方法执行时间为逻辑</span><br><span class="line">package org.vincent.proxy.dynamicproxy;/**</span><br><span class="line">* Created by PengRong on 2018/12/25.</span><br><span class="line">* 方法用时监控类</span><br><span class="line">*/public class MonitorUtil &#123;    private static ThreadLocal&lt;Long&gt; tl = new ThreadLocal&lt;&gt;();    public static void start() &#123;</span><br><span class="line">       tl.set(System.currentTimeMillis());</span><br><span class="line">   &#125;    /**</span><br><span class="line">    * 结束时打印耗时</span><br><span class="line">    * @param methodName 方法名</span><br><span class="line">    */</span><br><span class="line">   public static void finish(String methodName) &#123;        long finishTime = System.currentTimeMillis();</span><br><span class="line">       System.out.println(methodName + &quot;方法执行耗时&quot; + (finishTime - tl.get()) + &quot;ms&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">最后的是 怎么创建代理类</span><br><span class="line">package org.vincent.proxy.jdkdynamicProxy;import org.vincent.proxy.dynamicproxy.Person;import org.vincent.proxy.dynamicproxy.PersonInvocationHandler;import org.vincent.proxy.dynamicproxy.SoftwareEngineer;import sun.misc.ProxyGenerator;import java.io.FileOutputStream;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;import java.nio.file.Path;import java.nio.file.Paths;import java.util.Arrays;import java.util.Properties;/**</span><br><span class="line">* 动态代理类测试</span><br><span class="line">* Created by PengRong on 2018/12/25.</span><br><span class="line">*/public class JdkDynamicProxyTest &#123;    public static void main(String[] args) throws Exception &#123;        // 打开保存JDK动态代理生成的类文件</span><br><span class="line">       saveGeneratedJdkProxyFiles();        /**</span><br><span class="line">        * 第一种方法: 通过 Proxy.newProxyInstance 方法 获取代理对象</span><br><span class="line">        */</span><br><span class="line">       System.out.println(&quot;-------------------第一种创建代理类方法--------------&quot;);        //创建一个实例对象，这个对象是被代理的对象，委托类</span><br><span class="line">       Person person = new SoftwareEngineer(&quot;Vincent&quot;);        //创建一个与代理类相关联的InvocationHandler,每一个代理类都有一个关联的 InvocationHandler，并将代理类引用传递进去</span><br><span class="line">       InvocationHandler Handler = new PersonInvocationHandler&lt;&gt;(person);        //创建一个 代理对象 personProxy 来代理 person，创建的代理对象的每个执行方法都会被替换执行Invocation接口中的invoke方法</span><br><span class="line">       Person personProxy = (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), new Class&lt;?&gt;[]&#123;Person.class&#125;, Handler);        /** 代理类信息 */</span><br><span class="line">       System.out.println(&quot;package = &quot; + personProxy.getClass().getPackage() + &quot; SimpleName = &quot; + personProxy.getClass().getSimpleName() + &quot; name =&quot; + personProxy.getClass().getName() + &quot; CanonicalName = &quot; +                &quot;&quot; + personProxy.getClass().getCanonicalName() + &quot; 实现的接口 Interfaces = &quot; + Arrays.toString(personProxy.getClass().getInterfaces()) +                &quot; superClass = &quot; + personProxy.getClass().getSuperclass() + &quot; methods =&quot; + Arrays.toString(personProxy.getClass().getMethods()));        // 通过 代理类 执行 委托类的代码逻辑</span><br><span class="line">       personProxy.goWorking(personProxy.getName(), &quot;深圳&quot;);       System.out.println(&quot;-------------------第二种创建代理类方法--------------&quot;);        /**</span><br><span class="line">        *  动态代理对象步骤</span><br><span class="line">        *      1、 创建一个与代理对象相关联的 InvocationHandler，以及真实的委托类实例</span><br><span class="line">        *      2、Proxy类的getProxyClass静态方法生成一个动态代理类stuProxyClass，该类继承Proxy类，实现 Person.java接口；JDK动态代理的特点是代理类必须继承Proxy类</span><br><span class="line">        *      3、通过代理类 proxyClass 获得他的带InvocationHandler 接口的构造函数 ProxyConstructor</span><br><span class="line">        *      4、通过 构造函数实例 ProxyConstructor 实例化一个代理对象，并将  InvocationHandler 接口实例传递给代理类。</span><br><span class="line">        */</span><br><span class="line">       // 1、创建 InvocationHandler 实例并设置代理的目标类对象</span><br><span class="line">       Person persontwo = new SoftwareEngineer(&quot;Vincent&quot;);</span><br><span class="line">       InvocationHandler Handlertwo = new PersonInvocationHandler&lt;&gt;(persontwo);        // 2 创建代理类,是一个字节码文件, 把 proxyClass 保存起来就能看到 他继承Proxy 类，实现Person接口</span><br><span class="line">       Class&lt;?&gt; proxyClass = Proxy.getProxyClass(Person.class.getClassLoader(), new Class&lt;?&gt;[]&#123;Person.class&#125;);        /** 代理类信息 */</span><br><span class="line">       System.out.println(&quot;package = &quot; + proxyClass.getPackage() + &quot; SimpleName = &quot; + proxyClass.getSimpleName() + &quot; name =&quot; + proxyClass.getName() + &quot; CanonicalName = &quot; +                &quot;&quot; + proxyClass.getCanonicalName() + &quot; 实现的接口 Interfaces = &quot; + Arrays.toString(proxyClass.getInterfaces()) +                &quot; superClass = &quot; + proxyClass.getSuperclass() + &quot; methods =&quot; + Arrays.toString(proxyClass.getMethods()));        // 3、  通过 proxyClass 获得 一个带有InvocationHandler参数的构造器constructor</span><br><span class="line">       Constructor&lt;?&gt; ProxyConstructor = proxyClass.getConstructor(InvocationHandler.class);        // 4、通过构造器创建一个  动态代理类 实例</span><br><span class="line">       Person stuProxy = (Person) ProxyConstructor.newInstance(Handlertwo);        /** 检测生成的类是否是代理类 */</span><br><span class="line">       System.out.println(&quot;stuProxy isProxy &quot;+Proxy.isProxyClass(stuProxy.getClass()));        /** 获取 代理类关联的 InvocationHandler 是哪个*/</span><br><span class="line">       InvocationHandler handlerObject = Proxy.getInvocationHandler(stuProxy);</span><br><span class="line">       System.out.println(handlerObject.getClass().getName());</span><br><span class="line">       stuProxy.goWorking(stuProxy.getName(), &quot;广州&quot;);        // 保存代理類</span><br><span class="line">       saveClass(&quot;$PersonProxy0&quot;, proxyClass.getInterfaces(), &quot;D:/123/&quot;);</span><br><span class="line">   &#125;    /**</span><br><span class="line">    * 生成代理类 class 并保持到文件中</span><br><span class="line">    *</span><br><span class="line">    * @param className  生成的代理类名称</span><br><span class="line">    * @param interfaces 代理类需要实现的接口</span><br><span class="line">    * @param pathdir    代理类保存的目录路径,以目录分隔符结尾</span><br><span class="line">    */</span><br><span class="line">   public static void saveClass(String className, Class&lt;?&gt;[] interfaces, String pathdir) &#123;        /**</span><br><span class="line">        * 第一个参数是 代理类 名 。</span><br><span class="line">        * 第二个参数是 代理类需要实现的接口</span><br><span class="line">        */</span><br><span class="line">       byte[] classFile = ProxyGenerator.generateProxyClass(className, interfaces);        /**</span><br><span class="line">        * 如果目录不存在就新建所有子目录</span><br><span class="line">        */</span><br><span class="line">       Path path1 = Paths.get(pathdir);        if (!path1.toFile().exists())&#123;</span><br><span class="line">           path1.toFile().mkdirs();</span><br><span class="line">       &#125;</span><br><span class="line">       String path = pathdir + className + &quot;.class&quot;;        try (FileOutputStream fos = new FileOutputStream(path)) &#123;</span><br><span class="line">           fos.write(classFile);</span><br><span class="line">           fos.flush();</span><br><span class="line">           System.out.println(&quot;代理类class文件写入成功&quot;);</span><br><span class="line">       &#125; catch (Exception e) &#123;</span><br><span class="line">           System.out.println(&quot;写文件错误&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;    /**</span><br><span class="line">    * 设置保存Java动态代理生成的类文件。</span><br><span class="line">    *</span><br><span class="line">    * @throws Exception</span><br><span class="line">    */</span><br><span class="line">   public static void saveGeneratedJdkProxyFiles() throws Exception &#123;</span><br><span class="line">       Field field = System.class.getDeclaredField(&quot;props&quot;);</span><br><span class="line">       field.setAccessible(true);</span><br><span class="line">       Properties props = (Properties) field.get(null);</span><br><span class="line">       props.put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</span><br><span class="line">   &#125;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">解析JDK生成的动态代理类</span><br><span class="line">saveGeneratedJdkProxyFiles方法 打开了存储jdk生成的动态代理类 以 接口方法 goWorking 为例讲解</span><br><span class="line"></span><br><span class="line">//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//package com.sun.proxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;import org.vincent.proxy.dynamicproxy.Person;public final class $Proxy0 extends Proxy implements Person &#123;    private static Method m1;    private static Method m4;    private static Method m3;    private static Method m2;    private static Method m5;    private static Method m0;    public $Proxy0(InvocationHandler var1) throws  &#123;        super(var1);</span><br><span class="line">   &#125;    public final boolean equals(Object var1) throws  &#123;        try &#123;            return ((Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;)).booleanValue();</span><br><span class="line">       &#125; catch (RuntimeException | Error var3) &#123;            throw var3;</span><br><span class="line">       &#125; catch (Throwable var4) &#123;            throw new UndeclaredThrowableException(var4);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;    public final void setName(String var1) throws  &#123;        try &#123;            super.h.invoke(this, m4, new Object[]&#123;var1&#125;);</span><br><span class="line">       &#125; catch (RuntimeException | Error var3) &#123;            throw var3;</span><br><span class="line">       &#125; catch (Throwable var4) &#123;            throw new UndeclaredThrowableException(var4);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;    public final String getName() throws  &#123;        try &#123;            return (String)super.h.invoke(this, m3, (Object[])null);</span><br><span class="line">       &#125; catch (RuntimeException | Error var2) &#123;            throw var2;</span><br><span class="line">       &#125; catch (Throwable var3) &#123;            throw new UndeclaredThrowableException(var3);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;    public final String toString() throws  &#123;        try &#123;            return (String)super.h.invoke(this, m2, (Object[])null);</span><br><span class="line">       &#125; catch (RuntimeException | Error var2) &#123;            throw var2;</span><br><span class="line">       &#125; catch (Throwable var3) &#123;            throw new UndeclaredThrowableException(var3);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;    /**</span><br><span class="line">   * 对接口  goWorking 的调用 转变成   super.h.invoke(this, m5, new Object[]&#123;var1, var2&#125;); 调用。</span><br><span class="line">   * h 就是Proxy.java类的一个 InvocationHandler 接口 属性，</span><br><span class="line">   * 我们在创建 动态代理类实例时候都必须 传一个 InvocationHandler 接口的实例过去。 这里就是刚才我们定义的 PersonInvocationHandler 。</span><br><span class="line">   * 回到过后是不是就回到了 PersonInvocationHandler.invoke方法里面，所以 PersonInvocationHandler 是我们生成的动态代理类的拦截器，拦截所有方法调用。</span><br><span class="line">   */</span><br><span class="line">   public final void goWorking(String var1, String var2) throws  &#123;        try &#123;            super.h.invoke(this, m5, new Object[]&#123;var1, var2&#125;);</span><br><span class="line">       &#125; catch (RuntimeException | Error var4) &#123;            throw var4;</span><br><span class="line">       &#125; catch (Throwable var5) &#123;            throw new UndeclaredThrowableException(var5);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;    public final int hashCode() throws  &#123;        try &#123;            return ((Integer)super.h.invoke(this, m0, (Object[])null)).intValue();</span><br><span class="line">       &#125; catch (RuntimeException | Error var2) &#123;            throw var2;</span><br><span class="line">       &#125; catch (Throwable var3) &#123;            throw new UndeclaredThrowableException(var3);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;/**</span><br><span class="line">* 静态代码块，根据动态代理实现的公共接口类接口方法 获取到所有接口方法 的 Method 实例*/</span><br><span class="line">   static &#123;        try &#123;</span><br><span class="line">           m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[]&#123;Class.forName(&quot;java.lang.Object&quot;)&#125;);</span><br><span class="line">           m4 = Class.forName(&quot;org.vincent.proxy.dynamicproxy.Person&quot;).getMethod(&quot;setName&quot;, new Class[]&#123;Class.forName(&quot;java.lang.String&quot;)&#125;);</span><br><span class="line">           m3 = Class.forName(&quot;org.vincent.proxy.dynamicproxy.Person&quot;).getMethod(&quot;getName&quot;, new Class[0]);</span><br><span class="line">           m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]);</span><br><span class="line">           m5 = Class.forName(&quot;org.vincent.proxy.dynamicproxy.Person&quot;).getMethod(&quot;goWorking&quot;, new Class[]&#123;Class.forName(&quot;java.lang.String&quot;), Class.forName(&quot;java.lang.String&quot;)&#125;);</span><br><span class="line">           m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]);</span><br><span class="line">       &#125; catch (NoSuchMethodException var2) &#123;            throw new NoSuchMethodError(var2.getMessage());</span><br><span class="line">       &#125; catch (ClassNotFoundException var3) &#123;            throw new NoClassDefFoundError(var3.getMessage());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Jdk为我们的生成了一个叫$Proxy0（这个名字后面的0是编号，有多个代理类会一次递增）的代理类，这个类文件时默认不会保存在文件，放在内存中的，我们在创建代理对象时，就是通过反射获得这个类的构造方法，然后创建代理对象实例。通过对这个生成的代理类源码的查看，我们很容易能看出，动态代理实现的具体过程。</span><br><span class="line"></span><br><span class="line">我们可以对 InvocationHandler 看做一个中介类，中介类持有一个被代理对象，被Proxy类回调。在invoke方法中调用了被代理对象的相应方法。通过聚合方式持有被代理对象的引用，把客户端对invoke的调用最终都转为对被代理对象的调用。</span><br><span class="line"></span><br><span class="line">客户端代码通过代理类引用调用接口方法时，通过代理类关联的中介类对象引用来调用中介类对象的invoke方法，从而达到代理执行被代理对象的方法。也就是说，动态代理Proxy类提供了模板实现，对外提供扩展点，外部通过实现InvocationHandler接口将被代理类纳入JDK代理类Proxy。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">一个典型的基于JDK动态代理创建对象过程可分为以下四个步骤：</span><br><span class="line">1、通过实现InvocationHandler接口创建自己的调用处理器 IvocationHandler handler = new InvocationHandlerImpl(...);</span><br><span class="line"></span><br><span class="line">2、通过为Proxy类指定ClassLoader对象和一组interface代理类需要实现的接口，创建动态代理类类文件，默认JDK并不会保存这个文件到文件中；可以保存起来观察生成的代理类结构Class clazz = Proxy.getProxyClass(classLoader,new Class[]&#123;...&#125;);</span><br><span class="line"></span><br><span class="line">3、通过上面新建的代理clazz的反射机制获取动态代理类的一个构造函数，其构造函数入参类型是调用处理器接口(IvocationHandler)类型 Constructor constructor = clazz.getConstructor(new Class[]&#123;InvocationHandler.class&#125;);</span><br><span class="line"></span><br><span class="line">4、通过构造函数实例创建代理类实例，此时需将调用处理器对象作为参数被传入 Interface Proxy = (Interface)constructor.newInstance(new Object[] (handler)); 为了简化对象创建过程，Proxy类中的newInstance工具方法封装了2~4，只需两步即可完成代理对象的创建。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JDK动态代理特点总结</span><br><span class="line">生成的代理类：$Proxy0 extends Proxy implements Person，我们看到代理类继承了Proxy类，Java的继承机制决定了JDK动态代理类们无法实现对 类 的动态代理。所以也就决定了java动态代理只能对接口进行代理，</span><br><span class="line">每个生成的动态代理实例都会关联一个调用处理器对象，可以通过 Proxy 提供的静态方法 getInvocationHandler 去获得代理类实例的调用处理器对象。在代理类实例上调用其代理的接口中所声明的方法时，这些方法最终都会由调用处理器的 invoke 方法执行</span><br><span class="line">代理类的根类 java.lang.Object 中有三个方法也同样会被分派到调用处理器的 invoke 方法执行，它们是 hashCode，equals 和 toString，可能的原因有：一是因为这些方法为 public 且非 final 类型，能够被代理类覆盖； 二是因为这些方法往往呈现出一个类的某种特征属性，具有一定的区分度，所以为了保证代理类与委托类对外的一致性，这三个方法也应该被调用处理器分派到委托类执行。</span><br><span class="line">JDK动态代理不足</span><br><span class="line">JDK动态代理的代理类字节码在创建时，需要实现业务实现类所实现的接口作为参数。如果业务实现类是没有实现接口而是直接定义业务方法的话，就无法使用JDK动态代理了。(JDK动态代理重要特点是代理接口) 并且，如果业务实现类中新增了接口中没有的方法，这些方法是无法被代理的（因为无法被调用）。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">动态代理只能对接口产生代理，不能对类产生代理</span><br><span class="line"></span><br><span class="line">基于CGlib 技术动态代理代理类实现 (基于继承)</span><br><span class="line">Cglib是针对类来实现代理的，他的原理是对代理的目标类生成一个子类，并覆盖其中方法实现增强，因为底层是基于创建被代理类的一个子类，所以它避免了JDK动态代理类的缺陷。</span><br><span class="line"></span><br><span class="line">但因为采用的是继承，所以不能对final修饰的类进行代理。final修饰的类不可继承。</span><br><span class="line"></span><br><span class="line">导入maven 依赖</span><br><span class="line">cglib 是基于asm 字节修改技术。导入 cglib 会间接导入 asm, ant, ant-launcher 三个jar 包。</span><br><span class="line"></span><br><span class="line">&lt;!-- cglib 动态代理依赖 begin --&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;cglib&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;3.2.5&lt;/version&gt;&lt;/dependency&gt;&lt;!-- cglib 动态代理依赖 stop --&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">业务类实现</span><br><span class="line">cglib是针对类来实现代理的，原理是对指定的业务类生成他的一个子类，并覆盖其中的业务方法来实现代理。因为采用的是继承，所以不能对final修饰的类进行代理。</span><br><span class="line"></span><br><span class="line">package org.vincent.proxy.cglibproxy;/**</span><br><span class="line">* @Package: org.vincent.proxy.cglibproxy &lt;br/&gt;</span><br><span class="line">* @Description： Cglib 代理模式中 被代理的委托类 &lt;br/&gt;</span><br><span class="line">* @author: lenovo &lt;br/&gt;</span><br><span class="line">* @Company: PLCC &lt;br/&gt;</span><br><span class="line">* @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line">* @Version: 1.0 &lt;br/&gt;</span><br><span class="line">* @Modified By: &lt;br/&gt;</span><br><span class="line">* @Created by lenovo on 2018/12/26-17:55 &lt;br/&gt;</span><br><span class="line">*/public class Dog &#123;    public String  call() &#123;</span><br><span class="line">       System.out.println(&quot;wang wang wang&quot;);        return &quot;Dog ..&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">方法拦截器 实现 MethodInterceptor 接口</span><br><span class="line">package org.vincent.proxy.cglibproxy;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import java.lang.reflect.Method;/**</span><br><span class="line">* @Package: org.vincent.proxy.cglibproxy &lt;br/&gt;</span><br><span class="line">* @Description： Cglib 方法拦截器,不用依赖被代理业务类的引用。  &lt;br/&gt;</span><br><span class="line">* @author: lenovo &lt;br/&gt;</span><br><span class="line">* @Company: PLCC &lt;br/&gt;</span><br><span class="line">* @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line">* @Version: 1.0 &lt;br/&gt;</span><br><span class="line">* @Modified By: &lt;br/&gt;</span><br><span class="line">* @Created by lenovo on 2018/12/26-17:56 &lt;br/&gt;</span><br><span class="line">*/public class CglibMethodInterceptor implements MethodInterceptor &#123;    /**</span><br><span class="line">    * 用于生成 Cglib 动态代理类工具方法</span><br><span class="line">    * @param target 代表需要 被代理的 委托类的 Class 对象</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   public Object CglibProxyGeneratory(Class target) &#123;        /** 创建cglib 代理类 start */</span><br><span class="line">       // 创建加强器，用来创建动态代理类</span><br><span class="line">       Enhancer enhancer = new Enhancer();        // 为代理类指定需要代理的类，也即是父类</span><br><span class="line">       enhancer.setSuperclass(target);        // 设置方法拦截器回调引用，对于代理类上所有方法的调用，都会调用CallBack，而Callback则需要实现intercept() 方法进行拦截</span><br><span class="line">       enhancer.setCallback(this);        // 获取动态代理类对象并返回</span><br><span class="line">       return enhancer.create();        /** 创建cglib 代理类 end */</span><br><span class="line">   &#125;    /**</span><br><span class="line">    * 功能主要是在调用业务类方法之前 之后添加统计时间的方法逻辑.</span><br><span class="line">    * intercept 因为  具有 MethodProxy proxy 参数的原因 不再需要代理类的引用对象了,直接通过proxy 对象访问被代理对象的方法(这种方式更快)。</span><br><span class="line">    * 当然 也可以通过反射机制，通过 method 引用实例    Object result = method.invoke(target, args); 形式反射调用被代理类方法，</span><br><span class="line">    * target 实例代表被代理类对象引用, 初始化 CglibMethodInterceptor 时候被赋值 。但是Cglib不推荐使用这种方式</span><br><span class="line">    * @param obj    代表Cglib 生成的动态代理类 对象本身</span><br><span class="line">    * @param method 代理类中被拦截的接口方法 Method 实例</span><br><span class="line">    * @param args   接口方法参数</span><br><span class="line">    * @param proxy  用于调用父类真正的业务类方法。可以直接调用被代理类接口方法</span><br><span class="line">    * @return</span><br><span class="line">    * @throws Throwable</span><br><span class="line">    */</span><br><span class="line">   @Override</span><br><span class="line">   public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;</span><br><span class="line">       System.out.println(&quot;before&quot;);</span><br><span class="line">       MonitorUtil.start();</span><br><span class="line">       Object result = proxy.invokeSuper(obj, args);        //Object result = method.invoke(target, args);</span><br><span class="line">       System.out.println(&quot;after&quot;);</span><br><span class="line">       MonitorUtil.finish(method.getName());        return result;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">一个切面，用于在方法拦截器中intercept 方法中调用真正业务方法之前 之后处理逻辑</span><br><span class="line">package org.vincent.proxy.cglibproxy;/**</span><br><span class="line">* Created by PengRong on 2018/12/25.</span><br><span class="line">* 方法用时监控类,作为一个切面 ，具有两个方法</span><br><span class="line">*/public class MonitorUtil &#123;    private static ThreadLocal&lt;Long&gt; tl = new ThreadLocal&lt;&gt;();    public static void start() &#123;</span><br><span class="line">       tl.set(System.currentTimeMillis());</span><br><span class="line">   &#125;    /**</span><br><span class="line">    * 结束时打印耗时</span><br><span class="line">    * @param methodName 方法名</span><br><span class="line">    */</span><br><span class="line">   public static void finish(String methodName) &#123;        long finishTime = System.currentTimeMillis();</span><br><span class="line">       System.out.println(methodName + &quot;方法执行耗时&quot; + (finishTime - tl.get()) + &quot;ms&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Cglib测试类</span><br><span class="line">package org.vincent.proxy.cglibproxy;import net.sf.cglib.core.DebuggingClassWriter;import net.sf.cglib.proxy.Enhancer;import org.junit.Test;import java.lang.reflect.Field;import java.util.Properties;/**</span><br><span class="line">* @Package: org.vincent.proxy.cglibproxy &lt;br/&gt;</span><br><span class="line">* @Description： TODO &lt;br/&gt;</span><br><span class="line">* @author: lenovo &lt;br/&gt;</span><br><span class="line">* @Company: PLCC &lt;br/&gt;</span><br><span class="line">* @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line">* @Version: 1.0 &lt;br/&gt;</span><br><span class="line">* @Modified By: &lt;br/&gt;</span><br><span class="line">* @Created by lenovo on 2018/12/26-18:05 &lt;br/&gt;</span><br><span class="line">*/public class CglibTest &#123;    @Test</span><br><span class="line">   public void testCglib() throws Exception &#123;       System.out.println(System.getProperty(&quot;user.dir&quot;));        /** 开启 保存cglib生成的动态代理类类文件*/</span><br><span class="line">       saveGeneratedCGlibProxyFiles(System.getProperty(&quot;user.dir&quot;));        /** 第一种方法: 创建cglib 代理类 start */</span><br><span class="line">       // 创建加强器，用来创建动态代理类</span><br><span class="line">       Enhancer enhancer = new Enhancer();        // 为代理类指定需要代理的类，也即是父类</span><br><span class="line">       enhancer.setSuperclass(Dog.class);        // new 一个新的方法拦截器</span><br><span class="line">       CglibMethodInterceptor cglibMethodInterceptor = new CglibMethodInterceptor();        // 设置方法拦截器回调引用，对于代理类上所有方法的调用，都会调用CallBack，而Callback则需要实现intercept() 方法进行拦截</span><br><span class="line">       enhancer.setCallback(cglibMethodInterceptor);        // 获取动态代理类对象并返回</span><br><span class="line">       Dog dog = (Dog) enhancer.create();        /** 创建cglib 代理类 end */</span><br><span class="line">       System.out.println(dog.call());        // 对于上面这几步，可以新增一个工具方法 放置在 CglibMethodInterceptor 里面；也就有了第二种方法</span><br><span class="line">       // new 一个新的方法拦截器，该拦截器还顺带一个用于创建代理类的工具方法。看起来简单很多</span><br><span class="line">       cglibMethodInterceptor = new CglibMethodInterceptor();</span><br><span class="line">       dog = (Dog) cglibMethodInterceptor.CglibProxyGeneratory(Dog.class);</span><br><span class="line">       System.out.println(dog.call());   &#125;    /**</span><br><span class="line">    * 设置保存Cglib代理生成的类文件。</span><br><span class="line">    *</span><br><span class="line">    * @throws Exception</span><br><span class="line">    */</span><br><span class="line">   public void saveGeneratedCGlibProxyFiles(String dir) throws Exception &#123;</span><br><span class="line">       Field field = System.class.getDeclaredField(&quot;props&quot;);</span><br><span class="line">       field.setAccessible(true);</span><br><span class="line">       Properties props = (Properties) field.get(null);</span><br><span class="line">       System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, dir);//dir为保存文件路径</span><br><span class="line">       props.put(&quot;net.sf.cglib.core.DebuggingClassWriter.traceEnabled&quot;, &quot;true&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Cglib 总结</span><br><span class="line">CGlib可以传入接口也可以传入普通的类，接口使用实现的方式,普通类使用会使用继承的方式生成代理类.</span><br><span class="line">由于是继承方式,如果是 static方法,private方法,final方法等描述的方法是不能被代理的</span><br><span class="line">做了方法访问优化，使用建立方法索引的方式避免了传统JDK动态代理需要通过Method方法反射调用.</span><br><span class="line">提供callback 和filter设计，可以灵活地给不同的方法绑定不同的callback。编码更方便灵活。</span><br><span class="line">CGLIB会默认代理Object中equals,toString,hashCode,clone等方法。比JDK代理多了clone。</span><br><span class="line">静态代理 基于JDK动态代理 基于Cglib 动态代理</span><br><span class="line">静态代理是通过在代码中显式编码定义一个业务实现类的代理类，在代理类中对同名的业务方法进行包装，用户通过代理类调用被包装过的业务方法；</span><br><span class="line"></span><br><span class="line">JDK动态代理是通过接口中的方法名，在动态生成的代理类中调用业务实现类的同名方法；</span><br><span class="line"></span><br><span class="line">CGlib动态代理是通过继承业务类，生成的动态代理类是业务类的子类，通过重写业务方法进行代理；</span><br><span class="line"></span><br><span class="line">静态代理在编译时产生class字节码文件，可以直接使用，效率高。动态代理必须实现InvocationHandler接口，通过invoke调用被委托类接口方法是通过反射方式，比较消耗系统性能，但可以减少代理类的数量，使用更灵活。 cglib代理无需实现接口，通过生成类字节码实现代理，比反射稍快，不存在性能问题，但cglib会继承目标对象，需要重写方法，所以目标对象不能为final类。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AOP 实现案例</span><br><span class="line">AOP的源码中用到了两种动态代理来实现拦截切入功能：jdk动态代理和cglib动态代理。两种方法同时存在，各有优劣。 jdk动态代理是由java内部的反射机制来实现的，cglib动态代理底层则是借助asm来实现的。 总的来说，反射机制在生成类的过程中比较高效，执行时候通过反射调用委托类接口方法比较慢；而asm在生成类之后的相关代理类执行过程中比较高效（可以通过将asm生成的类进行缓存，这样解决asm生成类过程低效问题）。 还有一点必须注意：jdk动态代理的应用前提，必须是委托类基于统一的接口。如果没有上述前提，jdk动态代理不能应用。 由此可以看出，jdk动态代理有一定的局限性，cglib这种第三方类库实现的动态代理应用更加广泛，且在效率上更有优势。</span><br><span class="line"></span><br><span class="line">实现AOP关键特点是定义好两个角色 切点 和 切面 。 代理模式中被代理类 委托类处于切点角色，需要添加的其他比如 校验逻辑，事务，审计逻辑 属于非功能实现逻辑通过 切面类定义的方法插入进去。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">JDK动态代理 aop 实现方式</span><br><span class="line">定义切面接口，完成将通用公共方法注入到被代理类接口调用处理中</span><br><span class="line">package org.vincent.aop.dynamicproxy;/**</span><br><span class="line">* @Package: org.vincent.aop.dynamicproxy &lt;br/&gt;</span><br><span class="line">* @Description： 定义切面接口，切面接口定义了两个切面方法，分别在切点接口方法执行前和执行后执行 &lt;br/&gt;</span><br><span class="line">* @author: lenovo &lt;br/&gt;</span><br><span class="line">* @Company: PLCC &lt;br/&gt;</span><br><span class="line">* @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line">* @Version: 1.0 &lt;br/&gt;</span><br><span class="line">* @Modified By: &lt;br/&gt;</span><br><span class="line">* @Created by lenovo on 2018/12/26 &lt;br/&gt;</span><br><span class="line">*/public interface IAspect &#123;    /**</span><br><span class="line">    * 在切点接口方法执行之前执行</span><br><span class="line">    * @param args 切点参数列表</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   boolean startTransaction(Object... args);    /**</span><br><span class="line">    * 在切点接口方法执行之后执行</span><br><span class="line">    */</span><br><span class="line">   void endTrasaction();</span><br><span class="line">&#125;</span><br><span class="line">定义切面实现类</span><br><span class="line">package org.vincent.aop.dynamicproxy;import java.util.Objects;/**</span><br><span class="line">* @Package: org.vincent.aop.dynamicproxy &lt;br/&gt;</span><br><span class="line">* @Description： 改类作为AOP 模型中切面角色类， 实现切面接口，切面接口定义了两个切面方法，分别在切点接口方法执行前和执行后执行 。 &lt;br/&gt;</span><br><span class="line">* @author: lenovo &lt;br/&gt;</span><br><span class="line">* @Company: PLCC &lt;br/&gt;</span><br><span class="line">* @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line">* @Version: 1.0 &lt;br/&gt;</span><br><span class="line">* @Modified By: &lt;br/&gt;</span><br><span class="line">* @Created by lenovo on 2018/12/26 &lt;br/&gt;</span><br><span class="line">*/public class CustomAspect implements IAspect &#123;    /**</span><br><span class="line">    * 对参数 做判空处理</span><br><span class="line">    * @param args 切点参数列表</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   @Override</span><br><span class="line">   public boolean startTransaction(Object... args) &#123;</span><br><span class="line">       Objects.nonNull(args);        boolean result = true;        for (Object temp :args) &#123;            if (Objects.isNull(temp))&#123;</span><br><span class="line">                result =false;                 break;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;        return result;</span><br><span class="line">   &#125;    public void endTrasaction() &#123;</span><br><span class="line">       System.out.println(&quot;I get datasource here and end transaction&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">定义切点角色接口 因为是基于JDK实现的Aop ，所以委托类需要基于接口实现。</span><br><span class="line">package org.vincent.aop.dynamicproxy;/**</span><br><span class="line">* @Package: org.vincent.aop.dynamicproxy &lt;br/&gt;</span><br><span class="line">* @Description： AOP基于动态代理 实现  &lt;br/&gt;</span><br><span class="line">* @author: lenovo &lt;br/&gt;</span><br><span class="line">* @Company: PLCC &lt;br/&gt;</span><br><span class="line">* @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line">* @Version: 1.0 &lt;br/&gt;</span><br><span class="line">* @Modified By: &lt;br/&gt;</span><br><span class="line">* @Created by lenovo on 2018/12/26 &lt;br/&gt;</span><br><span class="line">*/public interface IUserService &#123;    void saveUser(String username, String password) throws Exception;</span><br><span class="line">&#125;</span><br><span class="line">委托类实现</span><br><span class="line">package org.vincent.aop.dynamicproxy;/**</span><br><span class="line">* @Package: org.vincent.aop.dynamicproxy &lt;br/&gt;</span><br><span class="line">* @Description： UserService接口实现类UserServiceImpl 该类 作为AOP中切点角色，切面定义的方法插入到切点的接口方法 执行前和执行后执行。 &lt;br/&gt;</span><br><span class="line">* @author: lenovo &lt;br/&gt;</span><br><span class="line">* @Company: PLCC &lt;br/&gt;</span><br><span class="line">* @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line">* @Version: 1.0 &lt;br/&gt;</span><br><span class="line">* @Modified By: &lt;br/&gt;</span><br><span class="line">* @Created by lenovo on 2018/12/26 &lt;br/&gt;</span><br><span class="line">*/public class UserServiceImpl implements IUserService&#123;    @Override</span><br><span class="line">   public void saveUser(String username, String password) throws Exception &#123;</span><br><span class="line">       System.out.println(&quot;save user[username=&quot; + username + &quot;,password=&quot; + password + &quot;]&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">JDK动态代理生成器工具类</span><br><span class="line">可以看到 generatorJDKProxy 方法入参只有两个参数 一个切点接口引用，一个切面接口引用；在InvocationHandler 内部类中可以完整看到切面类方法是怎么影响切点代码执行逻辑的。</span><br><span class="line"></span><br><span class="line">package org.vincent.aop.dynamicproxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.util.Arrays;/**</span><br><span class="line">* @Package: org.vincent.aop.dynamicproxy &lt;br/&gt;</span><br><span class="line">* @Description： JDK动态代理类生成器 &lt;br/&gt;</span><br><span class="line">* @author: lenovo &lt;br/&gt;</span><br><span class="line">* @Company: PLCC &lt;br/&gt;</span><br><span class="line">* @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line">* @Version: 1.0 &lt;br/&gt;</span><br><span class="line">* @Modified By: &lt;br/&gt;</span><br><span class="line">* @Created by lenovo on 2018/12/26-16:48 &lt;br/&gt;</span><br><span class="line">*/public class JDKDynamicProxyGenerator &#123;    /**</span><br><span class="line">    * @param targetPoint 需要被代理的委托类对象</span><br><span class="line">    * @param aspect 切面对象,该对象方法将在切点方法之前或之后执行</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   public static Object generatorJDKProxy(IUserService targetPoint, final IAspect aspect) &#123;        return Proxy.newProxyInstance(                /**</span><br><span class="line">                *   委托类使用的类加载器</span><br><span class="line">                */</span><br><span class="line">               targetPoint.getClass().getClassLoader(),                /**</span><br><span class="line">                * 委托类实现的接口</span><br><span class="line">                */</span><br><span class="line">               targetPoint.getClass().getInterfaces(),                /**</span><br><span class="line">                * 生成的动态代理类关联的 执行处理器，代理我们的业务逻辑被生成的动态代理类回调</span><br><span class="line">                * 具体逻辑代码执行,返回值为方法执行结果, 在aop模型中，委托类的接口方法称为切点。</span><br><span class="line">                */</span><br><span class="line">               new InvocationHandler() &#123;                    @Override</span><br><span class="line">                   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                        // 执行切面方法,对入参进行校验</span><br><span class="line">                      boolean prepareAction = aspect.startTransaction(args);                       if (prepareAction)&#123;                           // 具体逻辑代码执行,返回值为方法执行结果</span><br><span class="line">                          Object result = method.invoke(targetPoint, args);</span><br><span class="line">                          aspect.endTrasaction();                           return result;</span><br><span class="line">                      &#125;else &#123;                           throw  new RuntimeException(&quot;args: &quot;+ Arrays.toString(args)+&quot;不能为null &quot;);</span><br><span class="line">                      &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">测试类</span><br><span class="line">package org.vincent.aop;import org.junit.Test;import org.vincent.aop.dynamicproxy.CustomAspect;import org.vincent.aop.dynamicproxy.IUserService;import org.vincent.aop.dynamicproxy.JDKDynamicProxyGenerator;import org.vincent.aop.dynamicproxy.UserServiceImpl;/**</span><br><span class="line">* @Package: org.vincent &lt;br/&gt;</span><br><span class="line">* @Description： 基于动态代理类AOP测试案例 &lt;br/&gt;</span><br><span class="line">* @author: lenovo &lt;br/&gt;</span><br><span class="line">* @Company: PLCC &lt;br/&gt;</span><br><span class="line">* @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line">* @Version: 1.0 &lt;br/&gt;</span><br><span class="line">* @Modified By: &lt;br/&gt;</span><br><span class="line">* @Created by lenovo on 2018/12/26-16:56 &lt;br/&gt;</span><br><span class="line">*/public class testAopJDKProxy &#123;    @Test</span><br><span class="line">   public void testJDKProxy() throws Exception &#123;</span><br><span class="line">       System.out.println(&quot;无代理前 调用方法 userService.saveUser 输出......&quot;);</span><br><span class="line">       IUserService userService = new UserServiceImpl();</span><br><span class="line">       userService.saveUser(&quot;zby&quot;, &quot;1234567890&quot;);       System.out.println(&quot;有代理后AOP 是怎么样的？ Proxy......&quot;);</span><br><span class="line">       IUserService proxyUserService = (IUserService) JDKDynamicProxyGenerator.generatorJDKProxy(userService, new CustomAspect());</span><br><span class="line">       proxyUserService.saveUser(&quot;zby&quot;, &quot;1234567890&quot;);        /** 制造异常,两个入参都是null   */</span><br><span class="line">       proxyUserService.saveUser(null, null);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Cglib aop 实现方式</span><br><span class="line">定义切面接口</span><br><span class="line">package org.vincent.aop.cglib;/**</span><br><span class="line">* @Package: org.vincent.aop.dynamicproxy &lt;br/&gt;</span><br><span class="line">* @Description： 定义切面接口，切面接口定义了两个切面方法，分别在切点接口方法执行前和执行后执行 &lt;br/&gt;</span><br><span class="line">* @author: lenovo &lt;br/&gt;</span><br><span class="line">* @Company: PLCC &lt;br/&gt;</span><br><span class="line">* @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line">* @Version: 1.0 &lt;br/&gt;</span><br><span class="line">* @Modified By: &lt;br/&gt;</span><br><span class="line">* @Created by lenovo on 2018/12/26 &lt;br/&gt;</span><br><span class="line">*/public interface IAspect &#123;    /**</span><br><span class="line">    * 在切点接口方法执行之前执行</span><br><span class="line">    */</span><br><span class="line">   void startTransaction();    /**</span><br><span class="line">    * 在切点接口方法执行之后执行</span><br><span class="line">    */</span><br><span class="line">   void endTrasaction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">切面实现</span><br><span class="line">package org.vincent.aop.cglib;/**</span><br><span class="line">* @Package: org.vincent.aop.dynamicproxy &lt;br/&gt;</span><br><span class="line">* @Description： 改类作为AOP 模型中切面角色类， 实现切面接口，切面接口定义了两个切面方法，分别在切点接口方法执行前和执行后执行 。 &lt;br/&gt;</span><br><span class="line">* @author: lenovo &lt;br/&gt;</span><br><span class="line">* @Company: PLCC &lt;br/&gt;</span><br><span class="line">* @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line">* @Version: 1.0 &lt;br/&gt;</span><br><span class="line">* @Modified By: &lt;br/&gt;</span><br><span class="line">* @Created by lenovo on 2018/12/26 &lt;br/&gt;</span><br><span class="line">*/public class CustomAspect implements IAspect &#123;    @Override</span><br><span class="line">   public void startTransaction() &#123;</span><br><span class="line">       System.out.println(&quot;cglib. I get datasource here and start transaction&quot;);</span><br><span class="line">   &#125;    public void endTrasaction() &#123;</span><br><span class="line">       System.out.println(&quot;cglib I get datasource here and end transaction&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">Cglib 是基于类实现的动态代理即业务类只需要实现类即可，不用强制必须实现某个接口为了突出这个优点这里没有实现接口</span><br><span class="line">package org.vincent.aop.cglib;/**</span><br><span class="line">* @Package: org.vincent.aop.dynamicproxy &lt;br/&gt;</span><br><span class="line">* @Description： 业务实现类UserServiceImpl 该类 作为AOP中切点角色，切面定义的方法插入到切点的接口方法 执行前和执行后执行。 &lt;br/&gt;</span><br><span class="line">* @author: lenovo &lt;br/&gt;</span><br><span class="line">* @Company: PLCC &lt;br/&gt;</span><br><span class="line">* @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line">* @Version: 1.0 &lt;br/&gt;</span><br><span class="line">* @Modified By: &lt;br/&gt;</span><br><span class="line">* @Created by lenovo on 2018/12/26 &lt;br/&gt;</span><br><span class="line">*/public class UserServiceImpl &#123;    public void saveUser(String username, String password) &#123;</span><br><span class="line">       System.out.println(&quot;cglib save user[username=&quot; + username + &quot;,password=&quot; + password + &quot;]&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Cglib 动态代理生成器工具类</span><br><span class="line">package org.vincent.aop.cglib;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import java.lang.reflect.Method;/**</span><br><span class="line">* @Package: org.vincent.aop.cglib &lt;br/&gt;</span><br><span class="line">* @Description： 基于Cglib代理类生成器工具类 &lt;br/&gt;</span><br><span class="line">* @author: lenovo &lt;br/&gt;</span><br><span class="line">* @Company: PLCC &lt;br/&gt;</span><br><span class="line">* @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line">* @Version: 1.0 &lt;br/&gt;</span><br><span class="line">* @Modified By: &lt;br/&gt;</span><br><span class="line">* @Created by lenovo on 2018/12/26-17:04 &lt;br/&gt;</span><br><span class="line">*/public class CglibProxyGenerator &#123;    /**</span><br><span class="line">    * @param target 需要被代理的委托类对象，Cglib需要继承该类生成子类</span><br><span class="line">    * @param aspect 切面对象,改对象方法将在切点方法之前或之后执行</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   public static  Object generatorCglibProxy(final Object target, final IAspect aspect)&#123;        //3.1 new Enhancer</span><br><span class="line">       Enhancer enhancer = new Enhancer();        //3.2 设置需要代理的父类</span><br><span class="line">       enhancer.setSuperclass(target.getClass());        //3.3 设置回调</span><br><span class="line">       enhancer.setCallback(new MethodInterceptor() &#123;            @Override</span><br><span class="line">           public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span><br><span class="line">                   throws Throwable &#123;                // 执行切面方法</span><br><span class="line">               aspect.startTransaction();                // 具体逻辑代码执行,返回值为方法执行结果</span><br><span class="line">               Object result = methodProxy.invokeSuper(proxy, args);                // 执行切面方法</span><br><span class="line">               aspect.endTrasaction();                // 返回方法执行结果</span><br><span class="line">               return result;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);        // 3.4 创建代理对象</span><br><span class="line">       return enhancer.create();</span><br><span class="line">   &#125;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">测试类</span><br><span class="line">package org.vincent.aop;import org.junit.Test;import org.vincent.aop.cglib.CglibProxyGenerator;import org.vincent.aop.cglib.CustomAspect;import org.vincent.aop.cglib.UserServiceImpl;/**</span><br><span class="line">* @Package: org.vincent &lt;br/&gt;</span><br><span class="line">* @Description： 基于动态代理类AOP测试案例 &lt;br/&gt;</span><br><span class="line">* @author: lenovo &lt;br/&gt;</span><br><span class="line">* @Company: PLCC &lt;br/&gt;</span><br><span class="line">* @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line">* @Version: 1.0 &lt;br/&gt;</span><br><span class="line">* @Modified By: &lt;br/&gt;</span><br><span class="line">* @Created by lenovo on 2018/12/26-16:56 &lt;br/&gt;</span><br><span class="line">*/public class testAopCglibKProxy &#123;    @Test</span><br><span class="line">   public void testCglibProxy() &#123;</span><br><span class="line">       System.out.println(&quot;before Proxy......&quot;);</span><br><span class="line">       UserServiceImpl userService = new UserServiceImpl();</span><br><span class="line">       userService.saveUser(&quot;zby&quot;, &quot;1234567890&quot;);</span><br><span class="line">       System.out.println(&quot;引入Cglib  Proxy代理库 后......&quot;);</span><br><span class="line">       UserServiceImpl proxyUserService = (UserServiceImpl) CglibProxyGenerator.generatorCglibProxy(userService, new CustomAspect());</span><br><span class="line">       proxyUserService.saveUser(&quot;zby&quot;, &quot;1234567890&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">AspectJ 实现 AOP 效果</span><br><span class="line">AOP 实现的关键就在于 AOP 框架自动创建的 AOP 代理，AOP 代理则可分为静态代理和动态代理两大类:</span><br><span class="line"></span><br><span class="line">静态代理是指使用 AOP 框架提供的命令进行编译，从而在编译阶段通过AOP框架指令生成 AOP 代理类，因此也称为编译时增强；还有一种静态代理是编写代码实现不用工具；这种方式一般是代理模式会使用。</span><br><span class="line">动态代理则在运行时借助于 JDK 动态代理、CGLIB 等在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。</span><br><span class="line">基于 AspectJ 的编译时增强进行 AOP POM 依赖</span><br><span class="line">原生 AspectJ 不依赖Spring案例, 基于 AspectJ 的编译时增强进行 AOP 它是在编译期修改字节码，增强功能；并不会生成新的代理类字节码。</span><br><span class="line"></span><br><span class="line">&lt;!-- AspectJ begin--&gt;&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- AspectJ stop--&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">动态代理 使用场景</span><br><span class="line">日志集中打印</span><br><span class="line">事务</span><br><span class="line">权限管理</span><br><span class="line">AOP</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">SpringAop 什么时候调用jdk动态代理？什么时候调用cglib</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">1.导入log4j.jar，开启log4j DEBUG模式</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">2.查看打印日志，可以发现一个重要信息：</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">2020-03-03 15:13:31,870 DEBUG [org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator] - Creating implicit proxy for bean &apos;userService&apos; with 0 common interceptors and 4 specific interceptors</span><br><span class="line">spring再执行aop时，执行了 AnnotationAwareAspectJAutoProxyCreator 类中的某个方法</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">3.通过 AnnotationAwareAspectJAutoProxyCreator 找到最终执行的是其父类 AbstractAutoProxyCreator 中的 protected Advisor[] buildAdvisors(String beanName, Object[] specificInterceptors) 方法</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">4. 重新在 buildAdvisors 这个方法打断点进行调试</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">5.AbstractAutoProxyCreator 类中发现有一个重要的方法createProxy 如下：</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">protected Object createProxy(</span><br><span class="line">    Class&lt;?&gt; beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource) &#123;</span><br><span class="line"></span><br><span class="line">    if (this.beanFactory instanceof ConfigurableListableBeanFactory) &#123;</span><br><span class="line">        AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) this.beanFactory, beanName, beanClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ProxyFactory proxyFactory = new ProxyFactory();</span><br><span class="line">    proxyFactory.copyFrom(this);</span><br><span class="line"></span><br><span class="line">    if (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">        if (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">            proxyFactory.setProxyTargetClass(true);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">    proxyFactory.addAdvisors(advisors);</span><br><span class="line">    proxyFactory.setTargetSource(targetSource);</span><br><span class="line">    customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">    proxyFactory.setFrozen(this.freezeProxy);</span><br><span class="line">    if (advisorsPreFiltered()) &#123;</span><br><span class="line">        proxyFactory.setPreFiltered(true);</span><br><span class="line">    &#125;</span><br><span class="line">    // 核心代码</span><br><span class="line">    return proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">接着进入 ProxyFactory 中的 getProxy 方法</span><br><span class="line"></span><br><span class="line">public Object getProxy(ClassLoader classLoader) &#123;</span><br><span class="line">    // createAopProxy 方法中判断是选择jdk动态代理还是cglib方式代理</span><br><span class="line">    return createAopProxy().getProxy(classLoader);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">再进入到 ProxyCreatorSupport 中的 createAopProxy 方法</span><br><span class="line"></span><br><span class="line">复制代码</span><br><span class="line">protected final synchronized AopProxy createAopProxy() &#123;</span><br><span class="line">    if (!this.active) &#123;</span><br><span class="line">        activate();</span><br><span class="line">    &#125;</span><br><span class="line">    // getAopProxyFactory() 返回的是 DefaultAopProxyFactory对象，所以重点还是在 createAopProxy 方法上</span><br><span class="line">    return getAopProxyFactory().createAopProxy(this);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">6.进入到 DefaultAopProxyFactory 类中的 createAopProxy 方法，这个方法就是如何选择JDK动态代理还是Cglib代理</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException &#123;</span><br><span class="line">    // 1.config.isProxyTargetClass() 代表 配置中的proxy-target-class属性true/false，默认false</span><br><span class="line">    // </span><br><span class="line">    if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">        // 目标代理类，如 com.service.impl.UserServiceImpl</span><br><span class="line">        Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">        if (targetClass == null) &#123;</span><br><span class="line">            throw new AopConfigException(&quot;TargetSource cannot determine target class: &quot; +</span><br><span class="line">                                         &quot;Either an interface or a target is required for proxy creation.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        // 目标类如果是一个接口 或 </span><br><span class="line">        if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">            return new JdkDynamicAopProxy(config);</span><br><span class="line">        &#125;</span><br><span class="line">        return new ObjenesisCglibAopProxy(config);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        return new JdkDynamicAopProxy(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">方法中参数config 是一个 AdvisedSupport类型， AdvisedSupport 继承了 ProxyConfig 类，</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class ProxyConfig implements Serializable &#123;</span><br><span class="line">    // 代表 配置中的proxy-target-class，如果设置true，则使用Cglib方式代理</span><br><span class="line">    private boolean proxyTargetClass = false;</span><br><span class="line"></span><br><span class="line">    private boolean optimize = false;</span><br><span class="line"></span><br><span class="line">    boolean opaque = false;</span><br><span class="line"></span><br><span class="line">    boolean exposeProxy = false;</span><br><span class="line"></span><br><span class="line">    private boolean frozen = false;</span><br><span class="line"></span><br><span class="line">    // 省略部分代码</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ThreadLocal/">ThreadLocal</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/高并发/">高并发</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="bolg-Session-Token-Cookie" class="article article-type-bolg" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/12/13/Session-Token-Cookie/"
    >Session Token Cookie</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2019/12/13/Session-Token-Cookie/" class="article-date">
  <time datetime="2019-12-13T02:09:01.000Z" itemprop="datePublished">2019-12-13</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/计算机网络/">计算机网络</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h4 id="本文记录一下Session-Token-Cookie到底是什么，以及有什么区别。按顺序来看保证登陆状态的演进的几种方式"><a href="#本文记录一下Session-Token-Cookie到底是什么，以及有什么区别。按顺序来看保证登陆状态的演进的几种方式" class="headerlink" title="本文记录一下Session Token Cookie到底是什么，以及有什么区别。按顺序来看保证登陆状态的演进的几种方式"></a>本文记录一下Session Token Cookie到底是什么，以及有什么区别。按顺序来看保证登陆状态的演进的几种方式</h4><h4 id="1-最开始互联网并没有那么大的体量，每个网站也没有那么多的用户，所以访问网站时，只需要做最简单的用户名密码进行校验就可以，但慢慢的随着用户量增加，体量增大，就面临一个问题，那就是要管理会话，必须记住哪些人登陆系统，也就是说必须要把每个人区分开，这就是一个不小的挑战，因为HTTP请求是无状态的，当时想出的办法是给大家发一个会话标识-session-id-，其实就是一个随机的字符串，每个人的都不一样，作为唯一区分。"><a href="#1-最开始互联网并没有那么大的体量，每个网站也没有那么多的用户，所以访问网站时，只需要做最简单的用户名密码进行校验就可以，但慢慢的随着用户量增加，体量增大，就面临一个问题，那就是要管理会话，必须记住哪些人登陆系统，也就是说必须要把每个人区分开，这就是一个不小的挑战，因为HTTP请求是无状态的，当时想出的办法是给大家发一个会话标识-session-id-，其实就是一个随机的字符串，每个人的都不一样，作为唯一区分。" class="headerlink" title="1.最开始互联网并没有那么大的体量，每个网站也没有那么多的用户，所以访问网站时，只需要做最简单的用户名密码进行校验就可以，但慢慢的随着用户量增加，体量增大，就面临一个问题，那就是要管理会话，必须记住哪些人登陆系统，也就是说必须要把每个人区分开，这就是一个不小的挑战，因为HTTP请求是无状态的，当时想出的办法是给大家发一个会话标识(session_id)，其实就是一个随机的字符串，每个人的都不一样，作为唯一区分。"></a>1.最开始互联网并没有那么大的体量，每个网站也没有那么多的用户，所以访问网站时，只需要做最简单的用户名密码进行校验就可以，但慢慢的随着用户量增加，体量增大，就面临一个问题，那就是要管理会话，必须记住哪些人登陆系统，也就是说必须要把每个人区分开，这就是一个不小的挑战，因为HTTP请求是无状态的，当时想出的办法是给大家发一个会话标识(session_id)，其实就是一个随机的字符串，每个人的都不一样，作为唯一区分。</h4><h4 id="2-这样大家很开心，但是服务器就不开心了，每个人只需要保存自己的session-id，但服务器需要保存所有人的session-id，如果访问服务器多了，就得由成千上万，甚至几十万个，这对服务器是一个巨大的开销，严重限制了服务器扩展的能力，比如说我用两个机器组成了一个集群，小F通过机器A登陆了系统，那session-id会保存在机器A上，假设小F的下一次请求被转发到机器B怎么办？机器B可没有小F的session-id"><a href="#2-这样大家很开心，但是服务器就不开心了，每个人只需要保存自己的session-id，但服务器需要保存所有人的session-id，如果访问服务器多了，就得由成千上万，甚至几十万个，这对服务器是一个巨大的开销，严重限制了服务器扩展的能力，比如说我用两个机器组成了一个集群，小F通过机器A登陆了系统，那session-id会保存在机器A上，假设小F的下一次请求被转发到机器B怎么办？机器B可没有小F的session-id" class="headerlink" title="2.这样大家很开心，但是服务器就不开心了，每个人只需要保存自己的session_id，但服务器需要保存所有人的session_id，如果访问服务器多了，就得由成千上万，甚至几十万个，这对服务器是一个巨大的开销，严重限制了服务器扩展的能力，比如说我用两个机器组成了一个集群，小F通过机器A登陆了系统，那session_id会保存在机器A上，假设小F的下一次请求被转发到机器B怎么办？机器B可没有小F的session_id"></a>2.这样大家很开心，但是服务器就不开心了，每个人只需要保存自己的session_id，但服务器需要保存所有人的session_id，如果访问服务器多了，就得由成千上万，甚至几十万个，这对服务器是一个巨大的开销，严重限制了服务器扩展的能力，比如说我用两个机器组成了一个集群，小F通过机器A登陆了系统，那session_id会保存在机器A上，假设小F的下一次请求被转发到机器B怎么办？机器B可没有小F的session_id</h4><h4 id="3-有时候会采用一点小伎俩，session-sticky，就是让小F的请求一直粘连在机器A上，但是这也不管用，要是机器A挂掉了，还得转到机器B去。"><a href="#3-有时候会采用一点小伎俩，session-sticky，就是让小F的请求一直粘连在机器A上，但是这也不管用，要是机器A挂掉了，还得转到机器B去。" class="headerlink" title="3.有时候会采用一点小伎俩，session sticky，就是让小F的请求一直粘连在机器A上，但是这也不管用，要是机器A挂掉了，还得转到机器B去。"></a>3.有时候会采用一点小伎俩，session sticky，就是让小F的请求一直粘连在机器A上，但是这也不管用，要是机器A挂掉了，还得转到机器B去。</h4><h4 id="4-那就只好做session-id的复制了，把session-id在两个机器之间搬来搬去，快累死了。"><a href="#4-那就只好做session-id的复制了，把session-id在两个机器之间搬来搬去，快累死了。" class="headerlink" title="4.那就只好做session_id的复制了，把session_id在两个机器之间搬来搬去，快累死了。"></a>4.那就只好做session_id的复制了，把session_id在两个机器之间搬来搬去，快累死了。</h4><h4 id="5-后来有个叫Memcached的支了招，把session-id集中存储到一个地方，所有的机器都来访问这个地方的数据，这样一来，就不用复制了，但是增加了单点失败的可能性，要是那个负责session的机器挂了，所有人就需要重新登陆一边，后来也尝试把这个单点的机器也搞出集群，增加可靠性，但不管如何，这小小的session对我来说是一个沉重的负担。"><a href="#5-后来有个叫Memcached的支了招，把session-id集中存储到一个地方，所有的机器都来访问这个地方的数据，这样一来，就不用复制了，但是增加了单点失败的可能性，要是那个负责session的机器挂了，所有人就需要重新登陆一边，后来也尝试把这个单点的机器也搞出集群，增加可靠性，但不管如何，这小小的session对我来说是一个沉重的负担。" class="headerlink" title="5.后来有个叫Memcached的支了招，把session_id集中存储到一个地方，所有的机器都来访问这个地方的数据，这样一来，就不用复制了，但是增加了单点失败的可能性，要是那个负责session的机器挂了，所有人就需要重新登陆一边，后来也尝试把这个单点的机器也搞出集群，增加可靠性，但不管如何，这小小的session对我来说是一个沉重的负担。"></a>5.后来有个叫Memcached的支了招，把session_id集中存储到一个地方，所有的机器都来访问这个地方的数据，这样一来，就不用复制了，但是增加了单点失败的可能性，要是那个负责session的机器挂了，所有人就需要重新登陆一边，后来也尝试把这个单点的机器也搞出集群，增加可靠性，但不管如何，这小小的session对我来说是一个沉重的负担。</h4><h4 id="6-于是有人就一直思考，我为什么要保存这可恶的session-id呢，只让每个客户端去保存该多好，可是如果不保存这些session-id，怎么验证客户端发给我的session-id的确是我生成的呢？如果不去验证，我们都不知道他们是不是合法的登陆用户，那些不怀好意的家伙就可以伪造session-id-为所欲为了。关键就是验证，这个时候token应运而生，用户登陆系统，最简单的token组成-uid-用户唯一的身份标识-、time-当前时间的时间戳-、sign-签名，由token的前几位-盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器-。"><a href="#6-于是有人就一直思考，我为什么要保存这可恶的session-id呢，只让每个客户端去保存该多好，可是如果不保存这些session-id，怎么验证客户端发给我的session-id的确是我生成的呢？如果不去验证，我们都不知道他们是不是合法的登陆用户，那些不怀好意的家伙就可以伪造session-id-为所欲为了。关键就是验证，这个时候token应运而生，用户登陆系统，最简单的token组成-uid-用户唯一的身份标识-、time-当前时间的时间戳-、sign-签名，由token的前几位-盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器-。" class="headerlink" title="6.于是有人就一直思考，我为什么要保存这可恶的session_id呢，只让每个客户端去保存该多好，可是如果不保存这些session_id，怎么验证客户端发给我的session_id的确是我生成的呢？如果不去验证，我们都不知道他们是不是合法的登陆用户，那些不怀好意的家伙就可以伪造session_id,为所欲为了。关键就是验证，这个时候token应运而生，用户登陆系统，最简单的token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器)。"></a>6.于是有人就一直思考，我为什么要保存这可恶的session_id呢，只让每个客户端去保存该多好，可是如果不保存这些session_id，怎么验证客户端发给我的session_id的确是我生成的呢？如果不去验证，我们都不知道他们是不是合法的登陆用户，那些不怀好意的家伙就可以伪造session_id,为所欲为了。关键就是验证，这个时候token应运而生，用户登陆系统，最简单的token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器)。</h4><h4 id="7-至此基本的登陆过程就讲完了，但是现在也出现了更加安全的便捷的方式，token更多用于单点登录，拿着token去sso验证，验证通过可以重定向到之前访问的网站。"><a href="#7-至此基本的登陆过程就讲完了，但是现在也出现了更加安全的便捷的方式，token更多用于单点登录，拿着token去sso验证，验证通过可以重定向到之前访问的网站。" class="headerlink" title="7.至此基本的登陆过程就讲完了，但是现在也出现了更加安全的便捷的方式，token更多用于单点登录，拿着token去sso验证，验证通过可以重定向到之前访问的网站。"></a>7.至此基本的登陆过程就讲完了，但是现在也出现了更加安全的便捷的方式，token更多用于单点登录，拿着token去sso验证，验证通过可以重定向到之前访问的网站。</h4><h4 id="8-总结一下cookie，session，token"><a href="#8-总结一下cookie，session，token" class="headerlink" title="8.总结一下cookie，session，token"></a>8.总结一下cookie，session，token</h4><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><h4 id="cookie存储在客户端，HTTP是无状态的，HTTP每次发出的时候会附上改域名下的cookie，从而可以给HTTP附上状态，最常见的就是登陆态。"><a href="#cookie存储在客户端，HTTP是无状态的，HTTP每次发出的时候会附上改域名下的cookie，从而可以给HTTP附上状态，最常见的就是登陆态。" class="headerlink" title="cookie存储在客户端，HTTP是无状态的，HTTP每次发出的时候会附上改域名下的cookie，从而可以给HTTP附上状态，最常见的就是登陆态。"></a>cookie存储在客户端，HTTP是无状态的，HTTP每次发出的时候会附上改域名下的cookie，从而可以给HTTP附上状态，最常见的就是登陆态。</h4><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><h4 id="1-客户端向服务器请求，发送用户名和密码"><a href="#1-客户端向服务器请求，发送用户名和密码" class="headerlink" title="1.客户端向服务器请求，发送用户名和密码"></a>1.客户端向服务器请求，发送用户名和密码</h4><h4 id="2-服务器生成session-id，绑定用户数据存储在数据库"><a href="#2-服务器生成session-id，绑定用户数据存储在数据库" class="headerlink" title="2.服务器生成session_id，绑定用户数据存储在数据库"></a>2.服务器生成session_id，绑定用户数据存储在数据库</h4><h4 id="3-服务器返回session-id给客户端"><a href="#3-服务器返回session-id给客户端" class="headerlink" title="3.服务器返回session_id给客户端"></a>3.服务器返回session_id给客户端</h4><h4 id="4-客户端用cookie存储session-id，以后请求都带上这个session-id"><a href="#4-客户端用cookie存储session-id，以后请求都带上这个session-id" class="headerlink" title="4.客户端用cookie存储session_id，以后请求都带上这个session_id"></a>4.客户端用cookie存储session_id，以后请求都带上这个session_id</h4><h4 id="5-服务器如果收到这个session-id，那么就去数据库查找用户数据，如果找到了说明验证通过"><a href="#5-服务器如果收到这个session-id，那么就去数据库查找用户数据，如果找到了说明验证通过" class="headerlink" title="5.服务器如果收到这个session_id，那么就去数据库查找用户数据，如果找到了说明验证通过"></a>5.服务器如果收到这个session_id，那么就去数据库查找用户数据，如果找到了说明验证通过</h4><h4 id="6-服务器把验证结果返回客户端"><a href="#6-服务器把验证结果返回客户端" class="headerlink" title="6.服务器把验证结果返回客户端"></a>6.服务器把验证结果返回客户端</h4><h3 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h3><h4 id="1-客户端向服务器请求，发送用户名和密码-1"><a href="#1-客户端向服务器请求，发送用户名和密码-1" class="headerlink" title="1.客户端向服务器请求，发送用户名和密码"></a>1.客户端向服务器请求，发送用户名和密码</h4><h4 id="2-服务器根据用户信息通过加密生成token，用户信息包括账号，token过期时间等，具体由服务器自定义"><a href="#2-服务器根据用户信息通过加密生成token，用户信息包括账号，token过期时间等，具体由服务器自定义" class="headerlink" title="2.服务器根据用户信息通过加密生成token，用户信息包括账号，token过期时间等，具体由服务器自定义"></a>2.服务器根据用户信息通过加密生成token，用户信息包括账号，token过期时间等，具体由服务器自定义</h4><h4 id="3-服务器返回token给客户端"><a href="#3-服务器返回token给客户端" class="headerlink" title="3.服务器返回token给客户端"></a>3.服务器返回token给客户端</h4><h4 id="4-客户端用cookie存储token，以后的请求都带上这个token"><a href="#4-客户端用cookie存储token，以后的请求都带上这个token" class="headerlink" title="4.客户端用cookie存储token，以后的请求都带上这个token"></a>4.客户端用cookie存储token，以后的请求都带上这个token</h4><h4 id="5-服务器拿到token，把token解密，确认用户信息是否正确"><a href="#5-服务器拿到token，把token解密，确认用户信息是否正确" class="headerlink" title="5.服务器拿到token，把token解密，确认用户信息是否正确"></a>5.服务器拿到token，把token解密，确认用户信息是否正确</h4><h4 id="6-服务器把验证结果返回给客户端"><a href="#6-服务器把验证结果返回给客户端" class="headerlink" title="6.服务器把验证结果返回给客户端"></a>6.服务器把验证结果返回给客户端</h4><h3 id="Session，token优劣"><a href="#Session，token优劣" class="headerlink" title="Session，token优劣"></a>Session，token优劣</h3><h4 id="session"><a href="#session" class="headerlink" title="session"></a>session</h4><h5 id="由于session-id和用户信息相互绑定的数据库存在服务器，所以服务器可以随时让发送出去的一个session-id失效，这是保障安全的一种重要手段"><a href="#由于session-id和用户信息相互绑定的数据库存在服务器，所以服务器可以随时让发送出去的一个session-id失效，这是保障安全的一种重要手段" class="headerlink" title="由于session_id和用户信息相互绑定的数据库存在服务器，所以服务器可以随时让发送出去的一个session_id失效，这是保障安全的一种重要手段"></a>由于session_id和用户信息相互绑定的数据库存在服务器，所以服务器可以随时让发送出去的一个session_id失效，这是保障安全的一种重要手段</h5><h4 id="token"><a href="#token" class="headerlink" title="token"></a>token</h4><h5 id="token的好处是比session更省空间和时间，服务器不需要去管理session-id和用户信息的数据库，服务器收到token直接解密就可以验证，不需要去数据库查找验证，但是token发出去之后，就只能等待它过期之后才会失效，后台服务器无法对其进行控制"><a href="#token的好处是比session更省空间和时间，服务器不需要去管理session-id和用户信息的数据库，服务器收到token直接解密就可以验证，不需要去数据库查找验证，但是token发出去之后，就只能等待它过期之后才会失效，后台服务器无法对其进行控制" class="headerlink" title="token的好处是比session更省空间和时间，服务器不需要去管理session_id和用户信息的数据库，服务器收到token直接解密就可以验证，不需要去数据库查找验证，但是token发出去之后，就只能等待它过期之后才会失效，后台服务器无法对其进行控制"></a>token的好处是比session更省空间和时间，服务器不需要去管理session_id和用户信息的数据库，服务器收到token直接解密就可以验证，不需要去数据库查找验证，但是token发出去之后，就只能等待它过期之后才会失效，后台服务器无法对其进行控制</h5><h4 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">加入jwt依赖</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.auth0&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;java-jwt&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">声明2个变量过期时间和token秘钥(UUID可能会更好，我是自己随便输的)，token秘钥用于后面解密</span><br><span class="line"></span><br><span class="line">    //设置30分钟过期</span><br><span class="line">    private static final long EXPIRE_DATE=30*60*1000;</span><br><span class="line">    //token秘钥</span><br><span class="line">    private static final String TOKEN_SECRET = &quot;EQIUBFKSJBFJH2367816BQWE&quot;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">加密</span><br><span class="line">public static String tokenTest (String username,String password)&#123;        </span><br><span class="line"> </span><br><span class="line">        String token = &quot;&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            //过期时间</span><br><span class="line">            Date date = new Date(System.currentTimeMillis()+EXPIRE_DATE);</span><br><span class="line">            //秘钥及加密算法</span><br><span class="line">            Algorithm algorithm = Algorithm.HMAC256(TOKEN_SECRET);</span><br><span class="line">            //设置头部信息</span><br><span class="line">            Map&lt;String,Object&gt; header = new HashMap&lt;&gt;();</span><br><span class="line">            header.put(&quot;typ&quot;,&quot;JWT&quot;);</span><br><span class="line">            header.put(&quot;alg&quot;,&quot;HS256&quot;);</span><br><span class="line">            //携带username，password信息，生成签名</span><br><span class="line">            token = JWT.create()</span><br><span class="line">                    .withHeader(header)</span><br><span class="line">                    .withClaim(&quot;username&quot;,username)</span><br><span class="line">                    .withClaim(&quot;password&quot;,password).withExpiresAt(date)</span><br><span class="line">                    .sign(algorithm);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return  null;</span><br><span class="line">        &#125;</span><br><span class="line">        return token;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">解密。该方法的参数token是加密方法的返回值</span><br><span class="line">public static boolean verify(String token)&#123;</span><br><span class="line">        /**</span><br><span class="line">         * @desc   验证token，通过返回true</span><br><span class="line">         * @create 2019/1/18/018 9:39</span><br><span class="line">         * @params [token]需要校验的串</span><br><span class="line">        **/</span><br><span class="line">        try &#123;</span><br><span class="line">            Algorithm algorithm = Algorithm.HMAC256(TOKEN_SECRET);</span><br><span class="line">            JWTVerifier verifier = JWT.require(algorithm).build();</span><br><span class="line">            DecodedJWT jwt = verifier.verify(token);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return  false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">登陆接口</span><br><span class="line">@RequestMapping(value = &quot;/logon&quot;)</span><br><span class="line">    public JsonRESTResult getUserInfo(HttpSession session ,String userName, String password) &#123;</span><br><span class="line">        /**</span><br><span class="line">        * @author Syl</span><br><span class="line">        * @create 2019/12/13 9:55</span><br><span class="line">        * @params [session, userName, password]</span><br><span class="line">        **/</span><br><span class="line">        JsonRESTResult jsonRESTResult = new JsonRESTResult();        </span><br><span class="line">        //使用token工具类生成token串</span><br><span class="line">        String token  = TokenUtil.tokenTest(userName,password);</span><br><span class="line">        //根据用户名密码查找用户</span><br><span class="line">        User user = loginService.findUser(userName,password);</span><br><span class="line">        if (user !=null)&#123;</span><br><span class="line">            //将用户对象放到session中</span><br><span class="line">            session.setAttribute(&quot;USER_INFO&quot;,user);</span><br><span class="line">            //用户无操作30分钟需重新登录</span><br><span class="line">            session.setMaxInactiveInterval(60*30);</span><br><span class="line">            Map map = new HashMap&lt;&gt;();</span><br><span class="line">            map.put(&quot;USERINFO&quot;,user);</span><br><span class="line">            map.put(&quot;SESSIONID&quot;,session.getId());</span><br><span class="line">            map.put(&quot;token&quot;,token);</span><br><span class="line">            jsonRESTResult.setCode(JsonRESTResultMsg.CODE_800.getCode());</span><br><span class="line">            jsonRESTResult.setMsg(&quot;登录成功&quot;);</span><br><span class="line">            jsonRESTResult.setData(map);</span><br><span class="line">            return jsonRESTResult;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            jsonRESTResult.setCode(JsonRESTResultMsg.CODE_500.getCode());</span><br><span class="line">            jsonRESTResult.setMsg(&quot;登录失败,用户名密码错误&quot;);</span><br><span class="line">            jsonRESTResult.setData(null);</span><br><span class="line">            return jsonRESTResult;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">验证用户是否登陆接口</span><br><span class="line">@RequestMapping(&quot;/judgeLogin&quot;)</span><br><span class="line">    public JsonRESTResult judgeLogin(String token,HttpSession session)&#123;</span><br><span class="line">        JsonRESTResult jsonRESTResult = new JsonRESTResult();</span><br><span class="line">        if (TokenUtil.verify(token))&#123;</span><br><span class="line">            User user = (User)session.getAttribute(&quot;USER_INFO&quot;);</span><br><span class="line">            jsonRESTResult.setCode(JsonRESTResultMsg.CODE_800.getCode());</span><br><span class="line">            jsonRESTResult.setData(user);</span><br><span class="line">            jsonRESTResult.setMsg(&quot;用户登录成功&quot;);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            jsonRESTResult.setCode(JsonRESTResultMsg.CODE_500.getCode());</span><br><span class="line">            jsonRESTResult.setMsg(&quot;未登录或已过期&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonRESTResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Session-Token-Cookie/">Session Token Cookie</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/计算机网络/">计算机网络</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="blog-深入浅出索引" class="article article-type-blog" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/10/26/深入浅出索引/"
    >深入浅出索引</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2019/10/26/深入浅出索引/" class="article-date">
  <time datetime="2019-10-26T15:46:47.000Z" itemprop="datePublished">2019-10-26</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库/">数据库</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>这节讲的是索引的相关知识，提到索引相信大家都不会陌生，在工作中或多或少都会接触过，建立索引主要是用来提升SQL查询速度的一种解决方案。<br>那么索引是什么？<br>一句话简单来说，索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。  </p>
<h3 id="索引的常见模型"><a href="#索引的常见模型" class="headerlink" title="索引的常见模型"></a>索引的常见模型</h3><p>这里引入三种模型，哈希表有序数组和搜索树  </p>
<p>哈希表是一种以建-值（key-value）存储的数据结构，我们只要输入待查找的key，就能找到value。哈希的思路很简单，把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置。<br>不可避免的，多个key经过哈希函数的换算会出现同一个值的情况，处理这种情况的方式是，拉出一个链表。<br>假设，你现在维护着一个身份证信息和姓名的表，需要根据身份证号查找对应的名字。这时对应的哈希索引的示意图如下所示。  </p>
<p><img src="../image/%E5%93%88%E5%B8%8C%E8%A1%A8.png" alt="哈希表.png" title="哈希表">  </p>
<p>需要注意的是，图中四个ID_card_n的值并不是递增的，这样做的好处是增加新的User时速度会很快，只需要往后追加。但缺点是，因为不是有序的，所以哈希索引做区间查询速度是很慢的。  </p>
<p>所以，哈希表这种结构适用于只有等值查询的场景，比如 Memcached 及其他一些 NoSQL 引擎。  </p>
<p>而有序数组在等值查询和范围查询场景的性能就都非常优秀。还是根据上面这个例子，如果用有序数组来实现的话，示意图如下所示：  </p>
<p><img src="../image/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84.png" alt="有序数组.png" title="有序数组">  </p>
<p>这里假设身份证号没有重复，这个数组就是按照身份证号递增的顺序保存的，这个时候如果你要查ID_card_n2对应的名字，用二分法就可以快速得到，这个时间复杂度是O(log(N)).<br>同时很显然，这个索引结构支持范围查询。你要查身份证号在[ID_card_X,ID_card_Y]区间的User，可以先用二分法找到ID_card_X(如果不存在ID_card_X，就找到大于ID_card_X的第一个User)，然后向右遍历，直到查到第一个大于ID_card_Y的身份证号，推出循环。<br>如果仅仅看查询效率，有序数组就是最好的数据结构了，但是在更新数据的时候，如果有新增的数据，就需要挪动后续所有的记录，成本太高。<br>所以，有序数组只适用于静态存储引擎，比如你要保存的是2019年某个城市所有人口的信息，这类不会再修改的数据。<br>二叉搜索树是经典的数据结构了，还是根据上面的例子，如果我们用二叉搜索树来实现的话，示意图如下所示，</p>
<p><img src="../image/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.png" alt="二叉搜索树.png" title="二叉搜索树">  </p>
<p>二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子，这样如果你要查ID_card_2的话按照图中的顺序就是按照UserA -&gt; UserC -&gt; UserF -&gt; User2这个路径得到。这个时间复杂度是O(log(N))。<br>当然为了维持O(log(N))的查询复杂度，你就需要保持这颗树是平衡二叉树，为了做这个保证，更新的时间复杂度也是O(log(N))。<br>树可以有二叉，也可以有多叉，多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右递增。二叉搜索树的效率是最高的，但是实际上大多数数据库存储却并不适用二叉树。其原因是，索引不止存在于内存中，还要写到磁盘上。<br>你可以想象一下一棵100万节点的平衡二叉树，树高20，一次查询可能需要访问20个数据块，在机械硬盘时代，从磁盘随机读取一个数据块需要10ms的寻址时间，也就是说，对于一个100万行的表，如果使用二叉树来存储，单独访问一个行可能需要20个10ms的时间，这个查询可真够慢的，为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N 叉”树。这里，“N 叉”树中的“N”取决于数据块的大小。以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。考虑到树根的数据块总是在内存中的，一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。</p>
<p>N 叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。  </p>
<h3 id="InnoDB的索引模型"><a href="#InnoDB的索引模型" class="headerlink" title="InnoDB的索引模型"></a>InnoDB的索引模型</h3><p>大家都知道InnoDB的索引模型是B+树，假设我们有一个主键列为ID的表，表中有字段K，并且在K上有索引，如下图所示：  </p>
<p><img src="../image/InnoDB%E7%B4%A2%E5%BC%95.png" alt="InnoDB索引.png" title="InnoDB索引">  </p>
<p>从图中不难看出，根据叶子节点的内容，索引类型分为主键索引和非主键索引。</p>
<p>主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。  </p>
<p>非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。</p>
<p>根据上面的索引结构说明，我们来讨论一个问题：基于主键索引和普通索引的查询有什么区别？</p>
<p>如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；<br>如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为_回表_。<br>也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。   </p>
<p>除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。</p>
<p>当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。</p>
<p>基于上面的索引维护过程说明，我们来讨论一个案例：</p>
<p>你可能在一些建表规范里面见到过类似的描述，要求建表语句里一定要有自增主键。当然事无绝对，我们来分析一下哪些场景下应该使用自增主键，而哪些场景下不应该。</p>
<p>自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。</p>
<p>插入新记录的时候可以不指定 ID 的值，系统会获取当前 ID 最大值加 1 作为下一条记录的 ID 值。</p>
<p>也就是说，自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。</p>
<p>而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。</p>
<p>除了考虑性能外，我们还可以从存储空间的角度来看。假设你的表中确实有一个唯一字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？</p>
<p>由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约 20 个字节，而如果用整型做主键，则只要 4 个字节，如果是长整型（bigint）则是 8 个字节。</p>
<p>显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</p>
<p>所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。</p>
<p>有没有什么场景适合用业务字段直接做主键的呢？还是有的。比如，有些业务的场景需求是这样的：</p>
<p>只有一个索引；</p>
<p>该索引必须是唯一索引。</p>
<p>你一定看出来了，这就是典型的 KV 场景。</p>
<p>由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。</p>
<p>这时候我们就要优先考虑上一段提到的“尽量使用主键查询”原则，直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。 </p>
<p>对于一张表可以这么理解：<br>每一张表其实就是好几个B+树，树结点的key值就是某一行的主键，value是该行的其他数据。新建索引就是新增一个B+树，查询不走索引就是遍历主B+树。</p>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>如果执行的语句是 select ID from T where k between 3 and 5，这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引 k 已经“覆盖了”我们的查询需求，我们称为覆盖索引。</p>
<p>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</p>
<p>需要注意的是，在引擎内部使用覆盖索引在索引 k 上其实读了三个记录，R3~R5（对应的索引 k 上的记录项），但是对于 MySQL 的 Server 层来说，它就是找引擎拿到了两条记录，因此 MySQL 认为扫描行数是 2。  </p>
<p>基于上面覆盖索引的说明，我们来讨论一个问题：在一个市民信息表上，是否有必要将身份证号和名字建立联合索引？  </p>
<p>我们知道，身份证号是市民的唯一标识。也就是说，如果有根据身份证号查询市民信息的需求，我们只要在身份证号字段上建立索引就够了。而再建立一个（身份证号、姓名）的联合索引，是不是浪费空间？</p>
<p>如果现在有一个高频请求，要根据市民的身份证号查询他的姓名，这个联合索引就有意义了。它可以在这个高频请求上用到覆盖索引，不再需要回表查整行记录，减少语句的执行时间。</p>
<p>当然，索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这正是业务 DBA，或者称为业务数据架构师的工作。  </p>
<h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>对于最左前缀原则大家都应该轻车熟路了，就不过多介绍，有些重点内容可以考虑一下：<br>基于上面对最左前缀索引的说明，我们来讨论一个问题：在建立联合索引的时候，如何安排索引内的字段顺序。</p>
<p>这里我们的评估标准是，索引的复用能力。因为可以支持最左前缀，所以当已经有了 (a,b) 这个联合索引后，一般就不需要单独在 a 上建立索引了。因此，第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。  </p>
<p>所以现在你知道了，这段开头的问题里，我们要为高频请求创建 (身份证号，姓名）这个联合索引，并用这个索引支持“根据身份证号查询地址”的需求。</p>
<p>那么，如果既有联合查询，又有基于 a、b 各自的查询呢？查询条件里面只有 b 的语句，是无法使用 (a,b) 这个联合索引的，这时候你不得不维护另外一个索引，也就是说你需要同时维护 (a,b)、(b) 这两个索引。</p>
<p>这时候，我们要考虑的原则就是空间了。比如上面这个市民表的情况，name 字段是比 age 字段大的 ，那我就建议你创建一个（name,age) 的联合索引和一个 (age) 的单字段索引。  </p>
<h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>上一段我们说到满足最左前缀原则的时候，最左前缀可以用于在索引中定位记录。这时，你可能要问，那些不符合最左前缀的部分，会怎么样呢？</p>
<p>我们还是以市民表的联合索引（name, age）为例。如果现在有一个需求：检索出表中“名字第一个字是张，而且年龄是 10 岁的所有男孩”。那么，SQL 语句是这么写的：   </p>
<p><code>mysql&gt; select * from tuser where name like &#39;张 %&#39; and age=10 and ismale=1;</code></p>
<p>你已经知道了前缀索引规则，所以这个语句在搜索索引树的时候，只能用 “张”，找到第一个满足条件的记录 ID3。当然，这还不错，总比全表扫描要好。</p>
<p>然后呢？</p>
<p>当然是判断其他条件是否满足。</p>
<p>在 MySQL 5.6 之前，只能从 ID3 开始一个个回表。到主键索引上找出数据行，再对比字段值。</p>
<p>而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p>
<p>图 3 和图 4，是这两个过程的执行流程图。</p>
<p><img src="../image/%E5%9B%BE3.png" alt="图3.png" title="图3">  </p>
<p><img src="../image/%E5%9B%BE3.png" alt="图3.png" title="图3">  </p>
<p>在图 3 和 4 这两个图里面，每一个虚线箭头表示回表一次。</p>
<p>图 3 中，在 (name,age) 索引里面我特意去掉了 age 的值，这个过程 InnoDB 并不会去看 age 的值，只是按顺序把“name 第一个字是’张’”的记录一条条取出来回表。因此，需要回表 4 次。</p>
<p>图 4 跟图 3 的区别是，InnoDB 在 (name,age) 索引内部就判断了 age 是否等于 10，对于不等于 10 的记录，直接判断并跳过。在我们的这个例子中，只需要对 ID4、ID5 这两条记录回表取数据判断，就只需要回表 2 次。</p>
<h3 id="课后问题"><a href="#课后问题" class="headerlink" title="课后问题"></a>课后问题</h3><p>实际上主键索引也是可以使用多个字段的。DBA 小吕在入职新公司的时候，就发现自己接手维护的库里面，有这么一个表，表结构定义类似这样的：</p>
<figure class="highlight plain"><figcaption><span>TABLE `geek` (</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  `a` int(11) NOT NULL,</span><br><span class="line">  `b` int(11) NOT NULL,</span><br><span class="line">  `c` int(11) NOT NULL,</span><br><span class="line">  `d` int(11) NOT NULL,</span><br><span class="line">  PRIMARY KEY (`a`,`b`),</span><br><span class="line">  KEY `c` (`c`),</span><br><span class="line">  KEY `ca` (`c`,`a`),</span><br><span class="line">  KEY `cb` (`c`,`b`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">公司的同事告诉他说，由于历史原因，这个表需要 a、b 做联合主键，这个小吕理解了。</span><br><span class="line"></span><br><span class="line">但是，学过本章内容的小吕又纳闷了，既然主键包含了 a、b 这两个字段，那意味着单独在字段 c 上创建一个索引，就已经包含了三个字段了呀，为什么要创建“ca”“cb”这两个索引？</span><br><span class="line"></span><br><span class="line">同事告诉他，是因为他们的业务里面有这样的两种语句：</span><br></pre></td></tr></table></figure>

<p>select * from geek where c=N order by a limit 1;<br>select * from geek where c=N order by b limit 1;<br>```  </p>
<p>我给你的问题是，这位同事的解释对吗，为了这两个查询模式，这两个索引是否都是必须的？为什么呢？  </p>
<p>解答：  </p>
<p>表记录<br>–a–|–b–|–c–|–d–<br>1 2 3 d<br>1 3 2 d<br>1 4 3 d<br>2 1 3 d<br>2 2 2 d<br>2 3 4 d<br>主键 a，b 的聚簇索引组织顺序相当于 order by a,b ，也就是先按 a 排序，再按 b 排序，c 无序。</p>
<p>索引 ca 的组织是先按 c 排序，再按 a 排序，同时记录主键<br>–c–|–a–|–主键部分b– （注意，这里不是 ab，而是只有 b）<br>2 1 3<br>2 2 2<br>3 1 2<br>3 1 4<br>3 2 1<br>4 2 3<br>这个跟索引 c 的数据是一模一样的。</p>
<p>索引 cb 的组织是先按 c 排序，在按 b 排序，同时记录主键<br>–c–|–b–|–主键部分a– （同上）<br>2 2 2<br>2 3 1<br>3 1 2<br>3 2 1<br>3 4 1<br>4 3 2  </p>
<p>所以，结论是 ca 可以去掉，cb 需要保留。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据库/">数据库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/索引/">索引</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="blog-leetcode338" class="article article-type-blog" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/10/20/leetcode338/"
    >leetcode338</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2019/10/20/leetcode338/" class="article-date">
  <time datetime="2019-10-20T15:52:18.000Z" itemprop="datePublished">2019-10-20</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/leetcode/">leetcode</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: 2</span><br><span class="line">输出: [0,1,1]</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: 5</span><br><span class="line">输出: [0,1,1,2,1,2]</span><br></pre></td></tr></table></figure>

<p>进阶:<br>给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？<br>要求算法的空间复杂度为O(n)。<br>你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount）来执行此操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int[] countBits(int num) &#123;</span><br><span class="line">        int[] result = new int[num+1];</span><br><span class="line">        for (int i = 1; i &lt;= num; i++) &#123;</span><br><span class="line">            result[i] = result[i&amp;(i-1)] + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] ints = new Solution().countBits(2);</span><br><span class="line">        for(int i : ints)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最主要的是i&amp;(i-1)是将二进制的最后的1去掉，举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">24的二进制是11000</span><br><span class="line">24-1=23的二进制是10111</span><br><span class="line">11000&amp;10111 = 10000</span><br><span class="line">这样就把24的最后的1去掉了 </span><br><span class="line">result[i] = result[i&amp;(i-1)] + 1;</span><br><span class="line">首先i&amp;(i-1)一定比i小，所以这段代码可以保证result[i&amp;(i-1)]一定是之前计算过的，然后在后面加上1就是一共有的1的个数</span><br></pre></td></tr></table></figure>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode338/">leetcode338</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/二进制数/">二进制数</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2015-2020
        Gavin
      </li>
      <li>
        
        Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV:<span id="busuanzi_value_page_pv"></span></i>
  <i>UV:<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="孙云龙的技术博客"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">目录</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/lazyload.min.js"></script>

<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
      startDelay: 0,
      typeSpeed: 200,
      loop: true,
      backSpeed: 100,
      showCursor: true
    });
  } catch (err) {
  }

</script>





<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>
<script src="/dist/main.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>




<script src="/js/busuanzi-2.3.pure.min.js"></script>


<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>


    
  </div>
</body>

</html>