<!DOCTYPE html>


<html lang="en" >


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     孙云龙的技术博客
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  <link rel="stylesheet" href="/dist/main.css">
  <link rel="stylesheet" href="/css/custom.css">
  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

<link rel="alternate" href="/atom.xml" title="孙云龙的技术博客" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">孙云龙的技术博客</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="blog-静态代理-动态代理-AOP" class="article article-type-blog" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/07/静态代理-动态代理-AOP/"
    >静态代理/动态代理/AOP</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/07/静态代理-动态代理-AOP/" class="article-date">
  <time datetime="2020-03-07T09:04:35.000Z" itemprop="datePublished">2020-03-07</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java基础/">Java基础</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">本文是看过的一篇文章做的记录</span><br><span class="line">Java 代理模式实现方式，主要有如下五种方法</span><br><span class="line">静态代理，工程师编辑代理类代码，实现代理模式；在编译期就生成了代理类。</span><br><span class="line">基于 JDK 实现动态代理，通过jdk提供的工具方法Proxy.newProxyInstance动态构建全新的代理类(继承Proxy类，并持有InvocationHandler接口引用 )字节码文件并实例化对象返回。(jdk动态代理是由java内部的反射机制来实例化代理对象，并代理的调用委托类方法)</span><br><span class="line">基于CGlib 动态代理模式 基于继承被代理类生成代理子类，不用实现接口。只需要被代理类是非final 类即可。(cglib动态代理底层是借助asm字节码技术</span><br><span class="line">基于 Aspectj 实现动态代理（修改目标类的字节，织入代理的字节，在程序编译的时候 插入动态代理的字节码，不会生成全新的Class ）</span><br><span class="line">基于 instrumentation 实现动态代理（修改目标类的字节码、类装载的时候动态拦截去修改，基于javaagent） -javaagent:spring-instrument-4.3.8.RELEASE.jar （类装载的时候 插入动态代理的字节码，不会生成全新的Class ）</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Notes</span><br><span class="line">委托类 即指的是代理模式中的被代理对象</span><br><span class="line">代理类 指的是生成的代表委托类的一个角色</span><br><span class="line">静态代理实现</span><br><span class="line">静态代理是代理类在编译期间就创建好了，不是编译器生成的代理类，而是手动创建的类。在编译时就已经将接口，被代理类，代理类等确定下来。，软件设计中所指的代理一般是指静态代理，也就是在代码中显式指定的代理。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">实现步骤</span><br><span class="line">委托类和代理类之间的约束接口Cat</span><br><span class="line">约束接口实现类 Lion，实现 Cat 接口，委托角色</span><br><span class="line">代理类实现 FeederProxy，实现Cat 接口，并含有一个 Cat接口引用属性。 代理角色，代理 cat接口属性引用实例的行为并可以新增公共逻辑</span><br><span class="line">Cat接口</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">package org.vincent.proxy.staticproxy;/**</span><br><span class="line">* @author PengRong</span><br><span class="line">* @package org.vincent.proxy.staticproxy</span><br><span class="line">* @date 2018/12/15 - 17:12</span><br><span class="line">* @ProjectName JavaAopLearning</span><br><span class="line">* @Description: 静态代理类接口, 委托类和代理类都需要实现的接口规范。</span><br><span class="line">* 定义了一个猫科动物的两个行为接口，吃东西，奔跑。</span><br><span class="line">* 作为代理类 和委托类之间的约束接口</span><br><span class="line">*/public interface Cat &#123;    public String eatFood(String foodName);    public boolean running();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">委托类 Lion</span><br><span class="line">package org.vincent.proxy.staticproxy;/**</span><br><span class="line">* @author PengRong</span><br><span class="line">* @package org.vincent.proxy.staticproxy</span><br><span class="line">* @date 2018/12/15 - 17:15</span><br><span class="line">* @ProjectName JavaAopLearning</span><br><span class="line">* @Description: 狮子 实现了猫科动物接口Cat， 并实现了具体的行为。作为委托类实现</span><br><span class="line">*/public class Lion implements Cat &#123;    private String name;    private int runningSpeed;    public String getName() &#123;        return name;</span><br><span class="line">   &#125;    public void setName(String name) &#123;        this.name = name;</span><br><span class="line">   &#125;    public int getRunningSpeed() &#123;        return runningSpeed;</span><br><span class="line">   &#125;    public void setRunningSpeed(int runningSpeed) &#123;        this.runningSpeed = runningSpeed;</span><br><span class="line">   &#125;    public Lion() &#123;</span><br><span class="line">   &#125;    @Override</span><br><span class="line">   public String eatFood(String foodName) &#123;</span><br><span class="line">       String eat = this.name + &quot; Lion eat food. foodName = &quot; + foodName;</span><br><span class="line">       System.out.println(eat);        return eat;</span><br><span class="line">   &#125;    @Override</span><br><span class="line">   public boolean running() &#123;</span><br><span class="line">       System.out.println(this.name + &quot; Lion is running . Speed :&quot; + this.runningSpeed);        return false;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">代理类角色(FeederProxy)</span><br><span class="line">package org.vincent.proxy.staticproxy;/**</span><br><span class="line">* @author PengRong</span><br><span class="line">* @package org.vincent.proxy.staticproxy</span><br><span class="line">* @date 2018/12/15 - 17:19</span><br><span class="line">* @ProjectName JavaAopLearning</span><br><span class="line">* @Description: 饲养员 实现Cat接口，作为静态代理类实现。代理狮子的行为。</span><br><span class="line">* 代理类中可以新增一些其他行为，在实践中主要做的是参数校验的功能。</span><br><span class="line">*/public class FeederProxy implements Cat &#123;    private Cat cat;    public FeederProxy()&#123;&#125;    public FeederProxy(Cat cat) &#123;        if (cat instanceof Cat) &#123;            this.cat = cat;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;    public void setCat(Cat cat) &#123;        if (cat instanceof Cat) &#123;            this.cat = cat;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;    @Override</span><br><span class="line">   public String eatFood(String foodName) &#123;</span><br><span class="line">       System.out.println(&quot;proxy Lion exec eatFood &quot;);        return cat.eatFood(foodName);</span><br><span class="line">   &#125;    @Override</span><br><span class="line">   public boolean running() &#123;</span><br><span class="line">       System.out.println(&quot;proxy Lion exec running.&quot;);        return cat.running();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">静态代理类测试</span><br><span class="line">package org.vincent.proxy;import org.vincent.proxy.staticproxy.Cat;import org.vincent.proxy.staticproxy.FeederProxy;import org.vincent.proxy.staticproxy.Lion;/**</span><br><span class="line">* @author PengRong</span><br><span class="line">* @package org.vincent.proxy</span><br><span class="line">* @date 2018/12/15 - 18:31</span><br><span class="line">* @ProjectName JavaAopLearning</span><br><span class="line">* @Description: 静态代理类测试</span><br><span class="line">*/public class staticProxyTest &#123;    public static void main(String[] args) &#123;</span><br><span class="line">       Lion lion = new Lion();</span><br><span class="line">       lion.setName(&quot;狮子 小王&quot;);</span><br><span class="line">       lion.setRunningSpeed(100);        /**</span><br><span class="line">        * new 静态代理类，静态代理类在编译前已经创建好了，和动态代理的最大区别点</span><br><span class="line">        */</span><br><span class="line">       Cat proxy = new FeederProxy(lion);       System.out.println(Thread.currentThread().getName()+&quot; -- &quot; + proxy.eatFood(&quot;水牛&quot;));</span><br><span class="line">       proxy.running();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">静态代理很好的诠释了代理设计模式，代理模式最主要的就是有一个公共接口（Cat），一个委托类（Lion），一个代理类（FeederProxy）,代理类持有委托类的实例，代为执行具体类实例方法。 上面说到，代理模式就是在访问实际对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。这里的间接性就是指客户端不直接调用实际对象的方法，客户端依赖公共接口并使用代理类。 那么我们在代理过程中就可以加上一些其他用途。 就这个例子来说在 eatFood方法调用中，代理类在调用具体实现类之前添加System.out.println(&quot;proxy Lion exec eatFood &quot;);语句 就是添加间接性带来的收益。代理类存在的意义是为了增加一些公共的逻辑代码。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">动态代理类(基于接口实现)</span><br><span class="line">静态代理是代理类在代码运行前已经创建好，并生成class文件；动态代理类 是代理类在程序运行时创建的代理模式。</span><br><span class="line"></span><br><span class="line">动态代理类的代理类并不是在Java代码中定义的，而是在运行时根据我们在Java代码中的“指示”动态生成的。相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。 想想你有100个静态代理类，现在有一个需求，每个代理类都需要新增一个处理逻辑，你需要打开100个代理类在每个代理方法里面新增处理逻辑吗？ 有或者代理类有5个方法，每个方法都需要新增一个处理逻辑， 你需要在每个方法都手动新增处理逻辑吗？ 想想就挺无趣的。动态代理类帮你一键搞定。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">动态代理类涉及角色</span><br><span class="line">委托类和代理类实现的公共接口(Person.java)</span><br><span class="line">实现公共接口的具体委托类(SoftwareEngineer.java)</span><br><span class="line">InvocationHandler接口被Proxy类回调处理，一般实现 InvocationHandler 接口的类具有委托类引用，接口方法 invoke 中添加公共代码并调用委托类的接口方法。(PersonInvocationHandler.java)</span><br><span class="line">JDK提供生成动态代理类的核心类Proxy ( JDK 提供的Proxy.java)</span><br><span class="line">基于JDK技术 动态代理类技术核心 Proxy类和一个 InvocationHandler 接口</span><br><span class="line">java的java.lang.reflect包下提供了Proxy类和一个 InvocationHandler 接口，这个类Proxy定义了生成JDK动态代理类的方法 getProxyClass(ClassLoader loader,Class&lt;?&gt;... interfaces)生成动态代理类,返回class实例代表一个class文件。可以保存该 class 文件查看jdk生成的代理类文件长什么样</span><br><span class="line"></span><br><span class="line">该生成的动态代理类继承Proxy类，(重要特性) ，并实现公共接口。</span><br><span class="line"></span><br><span class="line">InvocationHandler这个接口 是被动态代理类回调的接口，我们所有需要增加的针对委托类的统一处理逻辑都增加到invoke 方法里面在调用委托类接口方法之前或之后 结束战斗。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">案例</span><br><span class="line">公共接口</span><br><span class="line">package org.vincent.proxy.dynamicproxy;/**</span><br><span class="line">* Created by PengRong on 2018/12/25.</span><br><span class="line">* 创建Person 接口 用于定义 委托类和代理类之间的约束行为</span><br><span class="line">*/public interface Person&#123;    /**</span><br><span class="line">    *</span><br><span class="line">    * @param name 人名</span><br><span class="line">    * @param dst 工作目的地</span><br><span class="line">    */</span><br><span class="line">   void goWorking(String name, String dst);    /**</span><br><span class="line">    * 获取名称</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   String getName( );    /**</span><br><span class="line">    * 设置名称</span><br><span class="line">    * @param name</span><br><span class="line">    */</span><br><span class="line">   void  setName(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">具体实现类，等下被委托，被代理的类 SoftwareEngineer.java</span><br><span class="line">package org.vincent.proxy.dynamicproxy;/**</span><br><span class="line">* Created by PengRong on 2018/12/25.</span><br><span class="line">* 动态代理委托类实现， 实现接口 Person。 被动态生成的代理类代理</span><br><span class="line">*/public class SoftwareEngineer implements Person&#123;    public  SoftwareEngineer()&#123;&#125;    public  SoftwareEngineer(String name)&#123;        this.name=name;</span><br><span class="line">   &#125;    private  String name;    public String getName() &#123;        return name;</span><br><span class="line">   &#125;    public void setName(String name) &#123;        this.name = name;</span><br><span class="line">   &#125;    @Override</span><br><span class="line">   public void goWorking(String name, String dst) &#123;</span><br><span class="line">       System.out.println(&quot;name =&quot;+name+&quot; ， 去 &quot;+dst +&quot; 工作&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">InvocationHandler 接口实现 PersonInvocationHandler.java</span><br><span class="line">package org.vincent.proxy.dynamicproxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.util.Arrays;/**</span><br><span class="line">* Created by PengRong on 2018/12/25.</span><br><span class="line">* PersonInvocationHandler 类 实现InvocationHandler接口，这个类中持有一个被代理对象(委托类)的实例target。该类别JDK Proxy类回调</span><br><span class="line">* InvocationHandler 接口中有一个invoke方法，当一个代理实例的方法被调用时，代理方法将被编码并分发到 InvocationHandler接口的invoke方法执行。</span><br><span class="line">*/public class PersonInvocationHandler&lt;T&gt; implements InvocationHandler &#123;    /**</span><br><span class="line">    * 被代理对象引用，invoke 方法里面method 需要使用这个 被代理对象</span><br><span class="line">    */</span><br><span class="line">   T target;    public PersonInvocationHandler(T target) &#123;        this.target = target;</span><br><span class="line">   &#125;    /**</span><br><span class="line">    * 在</span><br><span class="line">    * @param proxy  代表动态生成的 动态代理 对象实例</span><br><span class="line">    * @param method 代表被调用委托类的接口方法，和生成的代理类实例调用的接口方法是一致的，它对应的Method 实例</span><br><span class="line">    * @param args   代表调用接口方法对应的Object参数数组，如果接口是无参，则为null； 对于原始数据类型返回的他的包装类型。</span><br><span class="line">    * @return</span><br><span class="line">    * @throws Throwable</span><br><span class="line">    */</span><br><span class="line">   @Override</span><br><span class="line">   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;        /**</span><br><span class="line">        * 在转调具体目标对象之前，可以执行一些功能处理</span><br><span class="line">        */</span><br><span class="line">       System.out.println(&quot;被动态代理类回调执行, 代理类 proxyClass =&quot;+proxy.getClass()+&quot; 方法名: &quot; + method.getName() + &quot;方法. 方法返回类型：&quot;+method.getReturnType()</span><br><span class="line">       +&quot; 接口方法入参数组: &quot;+(args ==null ? &quot;null&quot; : Arrays.toString(args)));        /**</span><br><span class="line">        * 代理过程中插入监测方法,计算该方法耗时</span><br><span class="line">        */</span><br><span class="line">       MonitorUtil.start();</span><br><span class="line">       Thread.sleep(1);        /** 调用呗代理对象的真实方法，*/</span><br><span class="line">       Object result = method.invoke(target, args);</span><br><span class="line">       MonitorUtil.finish(method.getName());        return result;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PersonInvocationHandler invoke 方法中添加的公共代码，这里简单以统计方法执行时间为逻辑</span><br><span class="line">package org.vincent.proxy.dynamicproxy;/**</span><br><span class="line">* Created by PengRong on 2018/12/25.</span><br><span class="line">* 方法用时监控类</span><br><span class="line">*/public class MonitorUtil &#123;    private static ThreadLocal&lt;Long&gt; tl = new ThreadLocal&lt;&gt;();    public static void start() &#123;</span><br><span class="line">       tl.set(System.currentTimeMillis());</span><br><span class="line">   &#125;    /**</span><br><span class="line">    * 结束时打印耗时</span><br><span class="line">    * @param methodName 方法名</span><br><span class="line">    */</span><br><span class="line">   public static void finish(String methodName) &#123;        long finishTime = System.currentTimeMillis();</span><br><span class="line">       System.out.println(methodName + &quot;方法执行耗时&quot; + (finishTime - tl.get()) + &quot;ms&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">最后的是 怎么创建代理类</span><br><span class="line">package org.vincent.proxy.jdkdynamicProxy;import org.vincent.proxy.dynamicproxy.Person;import org.vincent.proxy.dynamicproxy.PersonInvocationHandler;import org.vincent.proxy.dynamicproxy.SoftwareEngineer;import sun.misc.ProxyGenerator;import java.io.FileOutputStream;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;import java.nio.file.Path;import java.nio.file.Paths;import java.util.Arrays;import java.util.Properties;/**</span><br><span class="line">* 动态代理类测试</span><br><span class="line">* Created by PengRong on 2018/12/25.</span><br><span class="line">*/public class JdkDynamicProxyTest &#123;    public static void main(String[] args) throws Exception &#123;        // 打开保存JDK动态代理生成的类文件</span><br><span class="line">       saveGeneratedJdkProxyFiles();        /**</span><br><span class="line">        * 第一种方法: 通过 Proxy.newProxyInstance 方法 获取代理对象</span><br><span class="line">        */</span><br><span class="line">       System.out.println(&quot;-------------------第一种创建代理类方法--------------&quot;);        //创建一个实例对象，这个对象是被代理的对象，委托类</span><br><span class="line">       Person person = new SoftwareEngineer(&quot;Vincent&quot;);        //创建一个与代理类相关联的InvocationHandler,每一个代理类都有一个关联的 InvocationHandler，并将代理类引用传递进去</span><br><span class="line">       InvocationHandler Handler = new PersonInvocationHandler&lt;&gt;(person);        //创建一个 代理对象 personProxy 来代理 person，创建的代理对象的每个执行方法都会被替换执行Invocation接口中的invoke方法</span><br><span class="line">       Person personProxy = (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), new Class&lt;?&gt;[]&#123;Person.class&#125;, Handler);        /** 代理类信息 */</span><br><span class="line">       System.out.println(&quot;package = &quot; + personProxy.getClass().getPackage() + &quot; SimpleName = &quot; + personProxy.getClass().getSimpleName() + &quot; name =&quot; + personProxy.getClass().getName() + &quot; CanonicalName = &quot; +                &quot;&quot; + personProxy.getClass().getCanonicalName() + &quot; 实现的接口 Interfaces = &quot; + Arrays.toString(personProxy.getClass().getInterfaces()) +                &quot; superClass = &quot; + personProxy.getClass().getSuperclass() + &quot; methods =&quot; + Arrays.toString(personProxy.getClass().getMethods()));        // 通过 代理类 执行 委托类的代码逻辑</span><br><span class="line">       personProxy.goWorking(personProxy.getName(), &quot;深圳&quot;);       System.out.println(&quot;-------------------第二种创建代理类方法--------------&quot;);        /**</span><br><span class="line">        *  动态代理对象步骤</span><br><span class="line">        *      1、 创建一个与代理对象相关联的 InvocationHandler，以及真实的委托类实例</span><br><span class="line">        *      2、Proxy类的getProxyClass静态方法生成一个动态代理类stuProxyClass，该类继承Proxy类，实现 Person.java接口；JDK动态代理的特点是代理类必须继承Proxy类</span><br><span class="line">        *      3、通过代理类 proxyClass 获得他的带InvocationHandler 接口的构造函数 ProxyConstructor</span><br><span class="line">        *      4、通过 构造函数实例 ProxyConstructor 实例化一个代理对象，并将  InvocationHandler 接口实例传递给代理类。</span><br><span class="line">        */</span><br><span class="line">       // 1、创建 InvocationHandler 实例并设置代理的目标类对象</span><br><span class="line">       Person persontwo = new SoftwareEngineer(&quot;Vincent&quot;);</span><br><span class="line">       InvocationHandler Handlertwo = new PersonInvocationHandler&lt;&gt;(persontwo);        // 2 创建代理类,是一个字节码文件, 把 proxyClass 保存起来就能看到 他继承Proxy 类，实现Person接口</span><br><span class="line">       Class&lt;?&gt; proxyClass = Proxy.getProxyClass(Person.class.getClassLoader(), new Class&lt;?&gt;[]&#123;Person.class&#125;);        /** 代理类信息 */</span><br><span class="line">       System.out.println(&quot;package = &quot; + proxyClass.getPackage() + &quot; SimpleName = &quot; + proxyClass.getSimpleName() + &quot; name =&quot; + proxyClass.getName() + &quot; CanonicalName = &quot; +                &quot;&quot; + proxyClass.getCanonicalName() + &quot; 实现的接口 Interfaces = &quot; + Arrays.toString(proxyClass.getInterfaces()) +                &quot; superClass = &quot; + proxyClass.getSuperclass() + &quot; methods =&quot; + Arrays.toString(proxyClass.getMethods()));        // 3、  通过 proxyClass 获得 一个带有InvocationHandler参数的构造器constructor</span><br><span class="line">       Constructor&lt;?&gt; ProxyConstructor = proxyClass.getConstructor(InvocationHandler.class);        // 4、通过构造器创建一个  动态代理类 实例</span><br><span class="line">       Person stuProxy = (Person) ProxyConstructor.newInstance(Handlertwo);        /** 检测生成的类是否是代理类 */</span><br><span class="line">       System.out.println(&quot;stuProxy isProxy &quot;+Proxy.isProxyClass(stuProxy.getClass()));        /** 获取 代理类关联的 InvocationHandler 是哪个*/</span><br><span class="line">       InvocationHandler handlerObject = Proxy.getInvocationHandler(stuProxy);</span><br><span class="line">       System.out.println(handlerObject.getClass().getName());</span><br><span class="line">       stuProxy.goWorking(stuProxy.getName(), &quot;广州&quot;);        // 保存代理類</span><br><span class="line">       saveClass(&quot;$PersonProxy0&quot;, proxyClass.getInterfaces(), &quot;D:/123/&quot;);</span><br><span class="line">   &#125;    /**</span><br><span class="line">    * 生成代理类 class 并保持到文件中</span><br><span class="line">    *</span><br><span class="line">    * @param className  生成的代理类名称</span><br><span class="line">    * @param interfaces 代理类需要实现的接口</span><br><span class="line">    * @param pathdir    代理类保存的目录路径,以目录分隔符结尾</span><br><span class="line">    */</span><br><span class="line">   public static void saveClass(String className, Class&lt;?&gt;[] interfaces, String pathdir) &#123;        /**</span><br><span class="line">        * 第一个参数是 代理类 名 。</span><br><span class="line">        * 第二个参数是 代理类需要实现的接口</span><br><span class="line">        */</span><br><span class="line">       byte[] classFile = ProxyGenerator.generateProxyClass(className, interfaces);        /**</span><br><span class="line">        * 如果目录不存在就新建所有子目录</span><br><span class="line">        */</span><br><span class="line">       Path path1 = Paths.get(pathdir);        if (!path1.toFile().exists())&#123;</span><br><span class="line">           path1.toFile().mkdirs();</span><br><span class="line">       &#125;</span><br><span class="line">       String path = pathdir + className + &quot;.class&quot;;        try (FileOutputStream fos = new FileOutputStream(path)) &#123;</span><br><span class="line">           fos.write(classFile);</span><br><span class="line">           fos.flush();</span><br><span class="line">           System.out.println(&quot;代理类class文件写入成功&quot;);</span><br><span class="line">       &#125; catch (Exception e) &#123;</span><br><span class="line">           System.out.println(&quot;写文件错误&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;    /**</span><br><span class="line">    * 设置保存Java动态代理生成的类文件。</span><br><span class="line">    *</span><br><span class="line">    * @throws Exception</span><br><span class="line">    */</span><br><span class="line">   public static void saveGeneratedJdkProxyFiles() throws Exception &#123;</span><br><span class="line">       Field field = System.class.getDeclaredField(&quot;props&quot;);</span><br><span class="line">       field.setAccessible(true);</span><br><span class="line">       Properties props = (Properties) field.get(null);</span><br><span class="line">       props.put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</span><br><span class="line">   &#125;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">解析JDK生成的动态代理类</span><br><span class="line">saveGeneratedJdkProxyFiles方法 打开了存储jdk生成的动态代理类 以 接口方法 goWorking 为例讲解</span><br><span class="line"></span><br><span class="line">//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//package com.sun.proxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;import org.vincent.proxy.dynamicproxy.Person;public final class $Proxy0 extends Proxy implements Person &#123;    private static Method m1;    private static Method m4;    private static Method m3;    private static Method m2;    private static Method m5;    private static Method m0;    public $Proxy0(InvocationHandler var1) throws  &#123;        super(var1);</span><br><span class="line">   &#125;    public final boolean equals(Object var1) throws  &#123;        try &#123;            return ((Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;)).booleanValue();</span><br><span class="line">       &#125; catch (RuntimeException | Error var3) &#123;            throw var3;</span><br><span class="line">       &#125; catch (Throwable var4) &#123;            throw new UndeclaredThrowableException(var4);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;    public final void setName(String var1) throws  &#123;        try &#123;            super.h.invoke(this, m4, new Object[]&#123;var1&#125;);</span><br><span class="line">       &#125; catch (RuntimeException | Error var3) &#123;            throw var3;</span><br><span class="line">       &#125; catch (Throwable var4) &#123;            throw new UndeclaredThrowableException(var4);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;    public final String getName() throws  &#123;        try &#123;            return (String)super.h.invoke(this, m3, (Object[])null);</span><br><span class="line">       &#125; catch (RuntimeException | Error var2) &#123;            throw var2;</span><br><span class="line">       &#125; catch (Throwable var3) &#123;            throw new UndeclaredThrowableException(var3);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;    public final String toString() throws  &#123;        try &#123;            return (String)super.h.invoke(this, m2, (Object[])null);</span><br><span class="line">       &#125; catch (RuntimeException | Error var2) &#123;            throw var2;</span><br><span class="line">       &#125; catch (Throwable var3) &#123;            throw new UndeclaredThrowableException(var3);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;    /**</span><br><span class="line">   * 对接口  goWorking 的调用 转变成   super.h.invoke(this, m5, new Object[]&#123;var1, var2&#125;); 调用。</span><br><span class="line">   * h 就是Proxy.java类的一个 InvocationHandler 接口 属性，</span><br><span class="line">   * 我们在创建 动态代理类实例时候都必须 传一个 InvocationHandler 接口的实例过去。 这里就是刚才我们定义的 PersonInvocationHandler 。</span><br><span class="line">   * 回到过后是不是就回到了 PersonInvocationHandler.invoke方法里面，所以 PersonInvocationHandler 是我们生成的动态代理类的拦截器，拦截所有方法调用。</span><br><span class="line">   */</span><br><span class="line">   public final void goWorking(String var1, String var2) throws  &#123;        try &#123;            super.h.invoke(this, m5, new Object[]&#123;var1, var2&#125;);</span><br><span class="line">       &#125; catch (RuntimeException | Error var4) &#123;            throw var4;</span><br><span class="line">       &#125; catch (Throwable var5) &#123;            throw new UndeclaredThrowableException(var5);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;    public final int hashCode() throws  &#123;        try &#123;            return ((Integer)super.h.invoke(this, m0, (Object[])null)).intValue();</span><br><span class="line">       &#125; catch (RuntimeException | Error var2) &#123;            throw var2;</span><br><span class="line">       &#125; catch (Throwable var3) &#123;            throw new UndeclaredThrowableException(var3);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;/**</span><br><span class="line">* 静态代码块，根据动态代理实现的公共接口类接口方法 获取到所有接口方法 的 Method 实例*/</span><br><span class="line">   static &#123;        try &#123;</span><br><span class="line">           m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[]&#123;Class.forName(&quot;java.lang.Object&quot;)&#125;);</span><br><span class="line">           m4 = Class.forName(&quot;org.vincent.proxy.dynamicproxy.Person&quot;).getMethod(&quot;setName&quot;, new Class[]&#123;Class.forName(&quot;java.lang.String&quot;)&#125;);</span><br><span class="line">           m3 = Class.forName(&quot;org.vincent.proxy.dynamicproxy.Person&quot;).getMethod(&quot;getName&quot;, new Class[0]);</span><br><span class="line">           m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]);</span><br><span class="line">           m5 = Class.forName(&quot;org.vincent.proxy.dynamicproxy.Person&quot;).getMethod(&quot;goWorking&quot;, new Class[]&#123;Class.forName(&quot;java.lang.String&quot;), Class.forName(&quot;java.lang.String&quot;)&#125;);</span><br><span class="line">           m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]);</span><br><span class="line">       &#125; catch (NoSuchMethodException var2) &#123;            throw new NoSuchMethodError(var2.getMessage());</span><br><span class="line">       &#125; catch (ClassNotFoundException var3) &#123;            throw new NoClassDefFoundError(var3.getMessage());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Jdk为我们的生成了一个叫$Proxy0（这个名字后面的0是编号，有多个代理类会一次递增）的代理类，这个类文件时默认不会保存在文件，放在内存中的，我们在创建代理对象时，就是通过反射获得这个类的构造方法，然后创建代理对象实例。通过对这个生成的代理类源码的查看，我们很容易能看出，动态代理实现的具体过程。</span><br><span class="line"></span><br><span class="line">我们可以对 InvocationHandler 看做一个中介类，中介类持有一个被代理对象，被Proxy类回调。在invoke方法中调用了被代理对象的相应方法。通过聚合方式持有被代理对象的引用，把客户端对invoke的调用最终都转为对被代理对象的调用。</span><br><span class="line"></span><br><span class="line">客户端代码通过代理类引用调用接口方法时，通过代理类关联的中介类对象引用来调用中介类对象的invoke方法，从而达到代理执行被代理对象的方法。也就是说，动态代理Proxy类提供了模板实现，对外提供扩展点，外部通过实现InvocationHandler接口将被代理类纳入JDK代理类Proxy。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">一个典型的基于JDK动态代理创建对象过程可分为以下四个步骤：</span><br><span class="line">1、通过实现InvocationHandler接口创建自己的调用处理器 IvocationHandler handler = new InvocationHandlerImpl(...);</span><br><span class="line"></span><br><span class="line">2、通过为Proxy类指定ClassLoader对象和一组interface代理类需要实现的接口，创建动态代理类类文件，默认JDK并不会保存这个文件到文件中；可以保存起来观察生成的代理类结构Class clazz = Proxy.getProxyClass(classLoader,new Class[]&#123;...&#125;);</span><br><span class="line"></span><br><span class="line">3、通过上面新建的代理clazz的反射机制获取动态代理类的一个构造函数，其构造函数入参类型是调用处理器接口(IvocationHandler)类型 Constructor constructor = clazz.getConstructor(new Class[]&#123;InvocationHandler.class&#125;);</span><br><span class="line"></span><br><span class="line">4、通过构造函数实例创建代理类实例，此时需将调用处理器对象作为参数被传入 Interface Proxy = (Interface)constructor.newInstance(new Object[] (handler)); 为了简化对象创建过程，Proxy类中的newInstance工具方法封装了2~4，只需两步即可完成代理对象的创建。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JDK动态代理特点总结</span><br><span class="line">生成的代理类：$Proxy0 extends Proxy implements Person，我们看到代理类继承了Proxy类，Java的继承机制决定了JDK动态代理类们无法实现对 类 的动态代理。所以也就决定了java动态代理只能对接口进行代理，</span><br><span class="line">每个生成的动态代理实例都会关联一个调用处理器对象，可以通过 Proxy 提供的静态方法 getInvocationHandler 去获得代理类实例的调用处理器对象。在代理类实例上调用其代理的接口中所声明的方法时，这些方法最终都会由调用处理器的 invoke 方法执行</span><br><span class="line">代理类的根类 java.lang.Object 中有三个方法也同样会被分派到调用处理器的 invoke 方法执行，它们是 hashCode，equals 和 toString，可能的原因有：一是因为这些方法为 public 且非 final 类型，能够被代理类覆盖； 二是因为这些方法往往呈现出一个类的某种特征属性，具有一定的区分度，所以为了保证代理类与委托类对外的一致性，这三个方法也应该被调用处理器分派到委托类执行。</span><br><span class="line">JDK动态代理不足</span><br><span class="line">JDK动态代理的代理类字节码在创建时，需要实现业务实现类所实现的接口作为参数。如果业务实现类是没有实现接口而是直接定义业务方法的话，就无法使用JDK动态代理了。(JDK动态代理重要特点是代理接口) 并且，如果业务实现类中新增了接口中没有的方法，这些方法是无法被代理的（因为无法被调用）。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">动态代理只能对接口产生代理，不能对类产生代理</span><br><span class="line"></span><br><span class="line">基于CGlib 技术动态代理代理类实现 (基于继承)</span><br><span class="line">Cglib是针对类来实现代理的，他的原理是对代理的目标类生成一个子类，并覆盖其中方法实现增强，因为底层是基于创建被代理类的一个子类，所以它避免了JDK动态代理类的缺陷。</span><br><span class="line"></span><br><span class="line">但因为采用的是继承，所以不能对final修饰的类进行代理。final修饰的类不可继承。</span><br><span class="line"></span><br><span class="line">导入maven 依赖</span><br><span class="line">cglib 是基于asm 字节修改技术。导入 cglib 会间接导入 asm, ant, ant-launcher 三个jar 包。</span><br><span class="line"></span><br><span class="line">&lt;!-- cglib 动态代理依赖 begin --&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;cglib&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;3.2.5&lt;/version&gt;&lt;/dependency&gt;&lt;!-- cglib 动态代理依赖 stop --&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">业务类实现</span><br><span class="line">cglib是针对类来实现代理的，原理是对指定的业务类生成他的一个子类，并覆盖其中的业务方法来实现代理。因为采用的是继承，所以不能对final修饰的类进行代理。</span><br><span class="line"></span><br><span class="line">package org.vincent.proxy.cglibproxy;/**</span><br><span class="line">* @Package: org.vincent.proxy.cglibproxy &lt;br/&gt;</span><br><span class="line">* @Description： Cglib 代理模式中 被代理的委托类 &lt;br/&gt;</span><br><span class="line">* @author: lenovo &lt;br/&gt;</span><br><span class="line">* @Company: PLCC &lt;br/&gt;</span><br><span class="line">* @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line">* @Version: 1.0 &lt;br/&gt;</span><br><span class="line">* @Modified By: &lt;br/&gt;</span><br><span class="line">* @Created by lenovo on 2018/12/26-17:55 &lt;br/&gt;</span><br><span class="line">*/public class Dog &#123;    public String  call() &#123;</span><br><span class="line">       System.out.println(&quot;wang wang wang&quot;);        return &quot;Dog ..&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">方法拦截器 实现 MethodInterceptor 接口</span><br><span class="line">package org.vincent.proxy.cglibproxy;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import java.lang.reflect.Method;/**</span><br><span class="line">* @Package: org.vincent.proxy.cglibproxy &lt;br/&gt;</span><br><span class="line">* @Description： Cglib 方法拦截器,不用依赖被代理业务类的引用。  &lt;br/&gt;</span><br><span class="line">* @author: lenovo &lt;br/&gt;</span><br><span class="line">* @Company: PLCC &lt;br/&gt;</span><br><span class="line">* @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line">* @Version: 1.0 &lt;br/&gt;</span><br><span class="line">* @Modified By: &lt;br/&gt;</span><br><span class="line">* @Created by lenovo on 2018/12/26-17:56 &lt;br/&gt;</span><br><span class="line">*/public class CglibMethodInterceptor implements MethodInterceptor &#123;    /**</span><br><span class="line">    * 用于生成 Cglib 动态代理类工具方法</span><br><span class="line">    * @param target 代表需要 被代理的 委托类的 Class 对象</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   public Object CglibProxyGeneratory(Class target) &#123;        /** 创建cglib 代理类 start */</span><br><span class="line">       // 创建加强器，用来创建动态代理类</span><br><span class="line">       Enhancer enhancer = new Enhancer();        // 为代理类指定需要代理的类，也即是父类</span><br><span class="line">       enhancer.setSuperclass(target);        // 设置方法拦截器回调引用，对于代理类上所有方法的调用，都会调用CallBack，而Callback则需要实现intercept() 方法进行拦截</span><br><span class="line">       enhancer.setCallback(this);        // 获取动态代理类对象并返回</span><br><span class="line">       return enhancer.create();        /** 创建cglib 代理类 end */</span><br><span class="line">   &#125;    /**</span><br><span class="line">    * 功能主要是在调用业务类方法之前 之后添加统计时间的方法逻辑.</span><br><span class="line">    * intercept 因为  具有 MethodProxy proxy 参数的原因 不再需要代理类的引用对象了,直接通过proxy 对象访问被代理对象的方法(这种方式更快)。</span><br><span class="line">    * 当然 也可以通过反射机制，通过 method 引用实例    Object result = method.invoke(target, args); 形式反射调用被代理类方法，</span><br><span class="line">    * target 实例代表被代理类对象引用, 初始化 CglibMethodInterceptor 时候被赋值 。但是Cglib不推荐使用这种方式</span><br><span class="line">    * @param obj    代表Cglib 生成的动态代理类 对象本身</span><br><span class="line">    * @param method 代理类中被拦截的接口方法 Method 实例</span><br><span class="line">    * @param args   接口方法参数</span><br><span class="line">    * @param proxy  用于调用父类真正的业务类方法。可以直接调用被代理类接口方法</span><br><span class="line">    * @return</span><br><span class="line">    * @throws Throwable</span><br><span class="line">    */</span><br><span class="line">   @Override</span><br><span class="line">   public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;</span><br><span class="line">       System.out.println(&quot;before&quot;);</span><br><span class="line">       MonitorUtil.start();</span><br><span class="line">       Object result = proxy.invokeSuper(obj, args);        //Object result = method.invoke(target, args);</span><br><span class="line">       System.out.println(&quot;after&quot;);</span><br><span class="line">       MonitorUtil.finish(method.getName());        return result;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">一个切面，用于在方法拦截器中intercept 方法中调用真正业务方法之前 之后处理逻辑</span><br><span class="line">package org.vincent.proxy.cglibproxy;/**</span><br><span class="line">* Created by PengRong on 2018/12/25.</span><br><span class="line">* 方法用时监控类,作为一个切面 ，具有两个方法</span><br><span class="line">*/public class MonitorUtil &#123;    private static ThreadLocal&lt;Long&gt; tl = new ThreadLocal&lt;&gt;();    public static void start() &#123;</span><br><span class="line">       tl.set(System.currentTimeMillis());</span><br><span class="line">   &#125;    /**</span><br><span class="line">    * 结束时打印耗时</span><br><span class="line">    * @param methodName 方法名</span><br><span class="line">    */</span><br><span class="line">   public static void finish(String methodName) &#123;        long finishTime = System.currentTimeMillis();</span><br><span class="line">       System.out.println(methodName + &quot;方法执行耗时&quot; + (finishTime - tl.get()) + &quot;ms&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Cglib测试类</span><br><span class="line">package org.vincent.proxy.cglibproxy;import net.sf.cglib.core.DebuggingClassWriter;import net.sf.cglib.proxy.Enhancer;import org.junit.Test;import java.lang.reflect.Field;import java.util.Properties;/**</span><br><span class="line">* @Package: org.vincent.proxy.cglibproxy &lt;br/&gt;</span><br><span class="line">* @Description： TODO &lt;br/&gt;</span><br><span class="line">* @author: lenovo &lt;br/&gt;</span><br><span class="line">* @Company: PLCC &lt;br/&gt;</span><br><span class="line">* @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line">* @Version: 1.0 &lt;br/&gt;</span><br><span class="line">* @Modified By: &lt;br/&gt;</span><br><span class="line">* @Created by lenovo on 2018/12/26-18:05 &lt;br/&gt;</span><br><span class="line">*/public class CglibTest &#123;    @Test</span><br><span class="line">   public void testCglib() throws Exception &#123;       System.out.println(System.getProperty(&quot;user.dir&quot;));        /** 开启 保存cglib生成的动态代理类类文件*/</span><br><span class="line">       saveGeneratedCGlibProxyFiles(System.getProperty(&quot;user.dir&quot;));        /** 第一种方法: 创建cglib 代理类 start */</span><br><span class="line">       // 创建加强器，用来创建动态代理类</span><br><span class="line">       Enhancer enhancer = new Enhancer();        // 为代理类指定需要代理的类，也即是父类</span><br><span class="line">       enhancer.setSuperclass(Dog.class);        // new 一个新的方法拦截器</span><br><span class="line">       CglibMethodInterceptor cglibMethodInterceptor = new CglibMethodInterceptor();        // 设置方法拦截器回调引用，对于代理类上所有方法的调用，都会调用CallBack，而Callback则需要实现intercept() 方法进行拦截</span><br><span class="line">       enhancer.setCallback(cglibMethodInterceptor);        // 获取动态代理类对象并返回</span><br><span class="line">       Dog dog = (Dog) enhancer.create();        /** 创建cglib 代理类 end */</span><br><span class="line">       System.out.println(dog.call());        // 对于上面这几步，可以新增一个工具方法 放置在 CglibMethodInterceptor 里面；也就有了第二种方法</span><br><span class="line">       // new 一个新的方法拦截器，该拦截器还顺带一个用于创建代理类的工具方法。看起来简单很多</span><br><span class="line">       cglibMethodInterceptor = new CglibMethodInterceptor();</span><br><span class="line">       dog = (Dog) cglibMethodInterceptor.CglibProxyGeneratory(Dog.class);</span><br><span class="line">       System.out.println(dog.call());   &#125;    /**</span><br><span class="line">    * 设置保存Cglib代理生成的类文件。</span><br><span class="line">    *</span><br><span class="line">    * @throws Exception</span><br><span class="line">    */</span><br><span class="line">   public void saveGeneratedCGlibProxyFiles(String dir) throws Exception &#123;</span><br><span class="line">       Field field = System.class.getDeclaredField(&quot;props&quot;);</span><br><span class="line">       field.setAccessible(true);</span><br><span class="line">       Properties props = (Properties) field.get(null);</span><br><span class="line">       System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, dir);//dir为保存文件路径</span><br><span class="line">       props.put(&quot;net.sf.cglib.core.DebuggingClassWriter.traceEnabled&quot;, &quot;true&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Cglib 总结</span><br><span class="line">CGlib可以传入接口也可以传入普通的类，接口使用实现的方式,普通类使用会使用继承的方式生成代理类.</span><br><span class="line">由于是继承方式,如果是 static方法,private方法,final方法等描述的方法是不能被代理的</span><br><span class="line">做了方法访问优化，使用建立方法索引的方式避免了传统JDK动态代理需要通过Method方法反射调用.</span><br><span class="line">提供callback 和filter设计，可以灵活地给不同的方法绑定不同的callback。编码更方便灵活。</span><br><span class="line">CGLIB会默认代理Object中equals,toString,hashCode,clone等方法。比JDK代理多了clone。</span><br><span class="line">静态代理 基于JDK动态代理 基于Cglib 动态代理</span><br><span class="line">静态代理是通过在代码中显式编码定义一个业务实现类的代理类，在代理类中对同名的业务方法进行包装，用户通过代理类调用被包装过的业务方法；</span><br><span class="line"></span><br><span class="line">JDK动态代理是通过接口中的方法名，在动态生成的代理类中调用业务实现类的同名方法；</span><br><span class="line"></span><br><span class="line">CGlib动态代理是通过继承业务类，生成的动态代理类是业务类的子类，通过重写业务方法进行代理；</span><br><span class="line"></span><br><span class="line">静态代理在编译时产生class字节码文件，可以直接使用，效率高。动态代理必须实现InvocationHandler接口，通过invoke调用被委托类接口方法是通过反射方式，比较消耗系统性能，但可以减少代理类的数量，使用更灵活。 cglib代理无需实现接口，通过生成类字节码实现代理，比反射稍快，不存在性能问题，但cglib会继承目标对象，需要重写方法，所以目标对象不能为final类。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AOP 实现案例</span><br><span class="line">AOP的源码中用到了两种动态代理来实现拦截切入功能：jdk动态代理和cglib动态代理。两种方法同时存在，各有优劣。 jdk动态代理是由java内部的反射机制来实现的，cglib动态代理底层则是借助asm来实现的。 总的来说，反射机制在生成类的过程中比较高效，执行时候通过反射调用委托类接口方法比较慢；而asm在生成类之后的相关代理类执行过程中比较高效（可以通过将asm生成的类进行缓存，这样解决asm生成类过程低效问题）。 还有一点必须注意：jdk动态代理的应用前提，必须是委托类基于统一的接口。如果没有上述前提，jdk动态代理不能应用。 由此可以看出，jdk动态代理有一定的局限性，cglib这种第三方类库实现的动态代理应用更加广泛，且在效率上更有优势。</span><br><span class="line"></span><br><span class="line">实现AOP关键特点是定义好两个角色 切点 和 切面 。 代理模式中被代理类 委托类处于切点角色，需要添加的其他比如 校验逻辑，事务，审计逻辑 属于非功能实现逻辑通过 切面类定义的方法插入进去。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">JDK动态代理 aop 实现方式</span><br><span class="line">定义切面接口，完成将通用公共方法注入到被代理类接口调用处理中</span><br><span class="line">package org.vincent.aop.dynamicproxy;/**</span><br><span class="line">* @Package: org.vincent.aop.dynamicproxy &lt;br/&gt;</span><br><span class="line">* @Description： 定义切面接口，切面接口定义了两个切面方法，分别在切点接口方法执行前和执行后执行 &lt;br/&gt;</span><br><span class="line">* @author: lenovo &lt;br/&gt;</span><br><span class="line">* @Company: PLCC &lt;br/&gt;</span><br><span class="line">* @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line">* @Version: 1.0 &lt;br/&gt;</span><br><span class="line">* @Modified By: &lt;br/&gt;</span><br><span class="line">* @Created by lenovo on 2018/12/26 &lt;br/&gt;</span><br><span class="line">*/public interface IAspect &#123;    /**</span><br><span class="line">    * 在切点接口方法执行之前执行</span><br><span class="line">    * @param args 切点参数列表</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   boolean startTransaction(Object... args);    /**</span><br><span class="line">    * 在切点接口方法执行之后执行</span><br><span class="line">    */</span><br><span class="line">   void endTrasaction();</span><br><span class="line">&#125;</span><br><span class="line">定义切面实现类</span><br><span class="line">package org.vincent.aop.dynamicproxy;import java.util.Objects;/**</span><br><span class="line">* @Package: org.vincent.aop.dynamicproxy &lt;br/&gt;</span><br><span class="line">* @Description： 改类作为AOP 模型中切面角色类， 实现切面接口，切面接口定义了两个切面方法，分别在切点接口方法执行前和执行后执行 。 &lt;br/&gt;</span><br><span class="line">* @author: lenovo &lt;br/&gt;</span><br><span class="line">* @Company: PLCC &lt;br/&gt;</span><br><span class="line">* @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line">* @Version: 1.0 &lt;br/&gt;</span><br><span class="line">* @Modified By: &lt;br/&gt;</span><br><span class="line">* @Created by lenovo on 2018/12/26 &lt;br/&gt;</span><br><span class="line">*/public class CustomAspect implements IAspect &#123;    /**</span><br><span class="line">    * 对参数 做判空处理</span><br><span class="line">    * @param args 切点参数列表</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   @Override</span><br><span class="line">   public boolean startTransaction(Object... args) &#123;</span><br><span class="line">       Objects.nonNull(args);        boolean result = true;        for (Object temp :args) &#123;            if (Objects.isNull(temp))&#123;</span><br><span class="line">                result =false;                 break;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;        return result;</span><br><span class="line">   &#125;    public void endTrasaction() &#123;</span><br><span class="line">       System.out.println(&quot;I get datasource here and end transaction&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">定义切点角色接口 因为是基于JDK实现的Aop ，所以委托类需要基于接口实现。</span><br><span class="line">package org.vincent.aop.dynamicproxy;/**</span><br><span class="line">* @Package: org.vincent.aop.dynamicproxy &lt;br/&gt;</span><br><span class="line">* @Description： AOP基于动态代理 实现  &lt;br/&gt;</span><br><span class="line">* @author: lenovo &lt;br/&gt;</span><br><span class="line">* @Company: PLCC &lt;br/&gt;</span><br><span class="line">* @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line">* @Version: 1.0 &lt;br/&gt;</span><br><span class="line">* @Modified By: &lt;br/&gt;</span><br><span class="line">* @Created by lenovo on 2018/12/26 &lt;br/&gt;</span><br><span class="line">*/public interface IUserService &#123;    void saveUser(String username, String password) throws Exception;</span><br><span class="line">&#125;</span><br><span class="line">委托类实现</span><br><span class="line">package org.vincent.aop.dynamicproxy;/**</span><br><span class="line">* @Package: org.vincent.aop.dynamicproxy &lt;br/&gt;</span><br><span class="line">* @Description： UserService接口实现类UserServiceImpl 该类 作为AOP中切点角色，切面定义的方法插入到切点的接口方法 执行前和执行后执行。 &lt;br/&gt;</span><br><span class="line">* @author: lenovo &lt;br/&gt;</span><br><span class="line">* @Company: PLCC &lt;br/&gt;</span><br><span class="line">* @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line">* @Version: 1.0 &lt;br/&gt;</span><br><span class="line">* @Modified By: &lt;br/&gt;</span><br><span class="line">* @Created by lenovo on 2018/12/26 &lt;br/&gt;</span><br><span class="line">*/public class UserServiceImpl implements IUserService&#123;    @Override</span><br><span class="line">   public void saveUser(String username, String password) throws Exception &#123;</span><br><span class="line">       System.out.println(&quot;save user[username=&quot; + username + &quot;,password=&quot; + password + &quot;]&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">JDK动态代理生成器工具类</span><br><span class="line">可以看到 generatorJDKProxy 方法入参只有两个参数 一个切点接口引用，一个切面接口引用；在InvocationHandler 内部类中可以完整看到切面类方法是怎么影响切点代码执行逻辑的。</span><br><span class="line"></span><br><span class="line">package org.vincent.aop.dynamicproxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.util.Arrays;/**</span><br><span class="line">* @Package: org.vincent.aop.dynamicproxy &lt;br/&gt;</span><br><span class="line">* @Description： JDK动态代理类生成器 &lt;br/&gt;</span><br><span class="line">* @author: lenovo &lt;br/&gt;</span><br><span class="line">* @Company: PLCC &lt;br/&gt;</span><br><span class="line">* @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line">* @Version: 1.0 &lt;br/&gt;</span><br><span class="line">* @Modified By: &lt;br/&gt;</span><br><span class="line">* @Created by lenovo on 2018/12/26-16:48 &lt;br/&gt;</span><br><span class="line">*/public class JDKDynamicProxyGenerator &#123;    /**</span><br><span class="line">    * @param targetPoint 需要被代理的委托类对象</span><br><span class="line">    * @param aspect 切面对象,该对象方法将在切点方法之前或之后执行</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   public static Object generatorJDKProxy(IUserService targetPoint, final IAspect aspect) &#123;        return Proxy.newProxyInstance(                /**</span><br><span class="line">                *   委托类使用的类加载器</span><br><span class="line">                */</span><br><span class="line">               targetPoint.getClass().getClassLoader(),                /**</span><br><span class="line">                * 委托类实现的接口</span><br><span class="line">                */</span><br><span class="line">               targetPoint.getClass().getInterfaces(),                /**</span><br><span class="line">                * 生成的动态代理类关联的 执行处理器，代理我们的业务逻辑被生成的动态代理类回调</span><br><span class="line">                * 具体逻辑代码执行,返回值为方法执行结果, 在aop模型中，委托类的接口方法称为切点。</span><br><span class="line">                */</span><br><span class="line">               new InvocationHandler() &#123;                    @Override</span><br><span class="line">                   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                        // 执行切面方法,对入参进行校验</span><br><span class="line">                      boolean prepareAction = aspect.startTransaction(args);                       if (prepareAction)&#123;                           // 具体逻辑代码执行,返回值为方法执行结果</span><br><span class="line">                          Object result = method.invoke(targetPoint, args);</span><br><span class="line">                          aspect.endTrasaction();                           return result;</span><br><span class="line">                      &#125;else &#123;                           throw  new RuntimeException(&quot;args: &quot;+ Arrays.toString(args)+&quot;不能为null &quot;);</span><br><span class="line">                      &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">测试类</span><br><span class="line">package org.vincent.aop;import org.junit.Test;import org.vincent.aop.dynamicproxy.CustomAspect;import org.vincent.aop.dynamicproxy.IUserService;import org.vincent.aop.dynamicproxy.JDKDynamicProxyGenerator;import org.vincent.aop.dynamicproxy.UserServiceImpl;/**</span><br><span class="line">* @Package: org.vincent &lt;br/&gt;</span><br><span class="line">* @Description： 基于动态代理类AOP测试案例 &lt;br/&gt;</span><br><span class="line">* @author: lenovo &lt;br/&gt;</span><br><span class="line">* @Company: PLCC &lt;br/&gt;</span><br><span class="line">* @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line">* @Version: 1.0 &lt;br/&gt;</span><br><span class="line">* @Modified By: &lt;br/&gt;</span><br><span class="line">* @Created by lenovo on 2018/12/26-16:56 &lt;br/&gt;</span><br><span class="line">*/public class testAopJDKProxy &#123;    @Test</span><br><span class="line">   public void testJDKProxy() throws Exception &#123;</span><br><span class="line">       System.out.println(&quot;无代理前 调用方法 userService.saveUser 输出......&quot;);</span><br><span class="line">       IUserService userService = new UserServiceImpl();</span><br><span class="line">       userService.saveUser(&quot;zby&quot;, &quot;1234567890&quot;);       System.out.println(&quot;有代理后AOP 是怎么样的？ Proxy......&quot;);</span><br><span class="line">       IUserService proxyUserService = (IUserService) JDKDynamicProxyGenerator.generatorJDKProxy(userService, new CustomAspect());</span><br><span class="line">       proxyUserService.saveUser(&quot;zby&quot;, &quot;1234567890&quot;);        /** 制造异常,两个入参都是null   */</span><br><span class="line">       proxyUserService.saveUser(null, null);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Cglib aop 实现方式</span><br><span class="line">定义切面接口</span><br><span class="line">package org.vincent.aop.cglib;/**</span><br><span class="line">* @Package: org.vincent.aop.dynamicproxy &lt;br/&gt;</span><br><span class="line">* @Description： 定义切面接口，切面接口定义了两个切面方法，分别在切点接口方法执行前和执行后执行 &lt;br/&gt;</span><br><span class="line">* @author: lenovo &lt;br/&gt;</span><br><span class="line">* @Company: PLCC &lt;br/&gt;</span><br><span class="line">* @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line">* @Version: 1.0 &lt;br/&gt;</span><br><span class="line">* @Modified By: &lt;br/&gt;</span><br><span class="line">* @Created by lenovo on 2018/12/26 &lt;br/&gt;</span><br><span class="line">*/public interface IAspect &#123;    /**</span><br><span class="line">    * 在切点接口方法执行之前执行</span><br><span class="line">    */</span><br><span class="line">   void startTransaction();    /**</span><br><span class="line">    * 在切点接口方法执行之后执行</span><br><span class="line">    */</span><br><span class="line">   void endTrasaction();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">切面实现</span><br><span class="line">package org.vincent.aop.cglib;/**</span><br><span class="line">* @Package: org.vincent.aop.dynamicproxy &lt;br/&gt;</span><br><span class="line">* @Description： 改类作为AOP 模型中切面角色类， 实现切面接口，切面接口定义了两个切面方法，分别在切点接口方法执行前和执行后执行 。 &lt;br/&gt;</span><br><span class="line">* @author: lenovo &lt;br/&gt;</span><br><span class="line">* @Company: PLCC &lt;br/&gt;</span><br><span class="line">* @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line">* @Version: 1.0 &lt;br/&gt;</span><br><span class="line">* @Modified By: &lt;br/&gt;</span><br><span class="line">* @Created by lenovo on 2018/12/26 &lt;br/&gt;</span><br><span class="line">*/public class CustomAspect implements IAspect &#123;    @Override</span><br><span class="line">   public void startTransaction() &#123;</span><br><span class="line">       System.out.println(&quot;cglib. I get datasource here and start transaction&quot;);</span><br><span class="line">   &#125;    public void endTrasaction() &#123;</span><br><span class="line">       System.out.println(&quot;cglib I get datasource here and end transaction&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">Cglib 是基于类实现的动态代理即业务类只需要实现类即可，不用强制必须实现某个接口为了突出这个优点这里没有实现接口</span><br><span class="line">package org.vincent.aop.cglib;/**</span><br><span class="line">* @Package: org.vincent.aop.dynamicproxy &lt;br/&gt;</span><br><span class="line">* @Description： 业务实现类UserServiceImpl 该类 作为AOP中切点角色，切面定义的方法插入到切点的接口方法 执行前和执行后执行。 &lt;br/&gt;</span><br><span class="line">* @author: lenovo &lt;br/&gt;</span><br><span class="line">* @Company: PLCC &lt;br/&gt;</span><br><span class="line">* @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line">* @Version: 1.0 &lt;br/&gt;</span><br><span class="line">* @Modified By: &lt;br/&gt;</span><br><span class="line">* @Created by lenovo on 2018/12/26 &lt;br/&gt;</span><br><span class="line">*/public class UserServiceImpl &#123;    public void saveUser(String username, String password) &#123;</span><br><span class="line">       System.out.println(&quot;cglib save user[username=&quot; + username + &quot;,password=&quot; + password + &quot;]&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Cglib 动态代理生成器工具类</span><br><span class="line">package org.vincent.aop.cglib;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import java.lang.reflect.Method;/**</span><br><span class="line">* @Package: org.vincent.aop.cglib &lt;br/&gt;</span><br><span class="line">* @Description： 基于Cglib代理类生成器工具类 &lt;br/&gt;</span><br><span class="line">* @author: lenovo &lt;br/&gt;</span><br><span class="line">* @Company: PLCC &lt;br/&gt;</span><br><span class="line">* @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line">* @Version: 1.0 &lt;br/&gt;</span><br><span class="line">* @Modified By: &lt;br/&gt;</span><br><span class="line">* @Created by lenovo on 2018/12/26-17:04 &lt;br/&gt;</span><br><span class="line">*/public class CglibProxyGenerator &#123;    /**</span><br><span class="line">    * @param target 需要被代理的委托类对象，Cglib需要继承该类生成子类</span><br><span class="line">    * @param aspect 切面对象,改对象方法将在切点方法之前或之后执行</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   public static  Object generatorCglibProxy(final Object target, final IAspect aspect)&#123;        //3.1 new Enhancer</span><br><span class="line">       Enhancer enhancer = new Enhancer();        //3.2 设置需要代理的父类</span><br><span class="line">       enhancer.setSuperclass(target.getClass());        //3.3 设置回调</span><br><span class="line">       enhancer.setCallback(new MethodInterceptor() &#123;            @Override</span><br><span class="line">           public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span><br><span class="line">                   throws Throwable &#123;                // 执行切面方法</span><br><span class="line">               aspect.startTransaction();                // 具体逻辑代码执行,返回值为方法执行结果</span><br><span class="line">               Object result = methodProxy.invokeSuper(proxy, args);                // 执行切面方法</span><br><span class="line">               aspect.endTrasaction();                // 返回方法执行结果</span><br><span class="line">               return result;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);        // 3.4 创建代理对象</span><br><span class="line">       return enhancer.create();</span><br><span class="line">   &#125;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">测试类</span><br><span class="line">package org.vincent.aop;import org.junit.Test;import org.vincent.aop.cglib.CglibProxyGenerator;import org.vincent.aop.cglib.CustomAspect;import org.vincent.aop.cglib.UserServiceImpl;/**</span><br><span class="line">* @Package: org.vincent &lt;br/&gt;</span><br><span class="line">* @Description： 基于动态代理类AOP测试案例 &lt;br/&gt;</span><br><span class="line">* @author: lenovo &lt;br/&gt;</span><br><span class="line">* @Company: PLCC &lt;br/&gt;</span><br><span class="line">* @Copyright: Copyright (c) 2019 &lt;br/&gt;</span><br><span class="line">* @Version: 1.0 &lt;br/&gt;</span><br><span class="line">* @Modified By: &lt;br/&gt;</span><br><span class="line">* @Created by lenovo on 2018/12/26-16:56 &lt;br/&gt;</span><br><span class="line">*/public class testAopCglibKProxy &#123;    @Test</span><br><span class="line">   public void testCglibProxy() &#123;</span><br><span class="line">       System.out.println(&quot;before Proxy......&quot;);</span><br><span class="line">       UserServiceImpl userService = new UserServiceImpl();</span><br><span class="line">       userService.saveUser(&quot;zby&quot;, &quot;1234567890&quot;);</span><br><span class="line">       System.out.println(&quot;引入Cglib  Proxy代理库 后......&quot;);</span><br><span class="line">       UserServiceImpl proxyUserService = (UserServiceImpl) CglibProxyGenerator.generatorCglibProxy(userService, new CustomAspect());</span><br><span class="line">       proxyUserService.saveUser(&quot;zby&quot;, &quot;1234567890&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">AspectJ 实现 AOP 效果</span><br><span class="line">AOP 实现的关键就在于 AOP 框架自动创建的 AOP 代理，AOP 代理则可分为静态代理和动态代理两大类:</span><br><span class="line"></span><br><span class="line">静态代理是指使用 AOP 框架提供的命令进行编译，从而在编译阶段通过AOP框架指令生成 AOP 代理类，因此也称为编译时增强；还有一种静态代理是编写代码实现不用工具；这种方式一般是代理模式会使用。</span><br><span class="line">动态代理则在运行时借助于 JDK 动态代理、CGLIB 等在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。</span><br><span class="line">基于 AspectJ 的编译时增强进行 AOP POM 依赖</span><br><span class="line">原生 AspectJ 不依赖Spring案例, 基于 AspectJ 的编译时增强进行 AOP 它是在编译期修改字节码，增强功能；并不会生成新的代理类字节码。</span><br><span class="line"></span><br><span class="line">&lt;!-- AspectJ begin--&gt;&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- AspectJ stop--&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">动态代理 使用场景</span><br><span class="line">日志集中打印</span><br><span class="line">事务</span><br><span class="line">权限管理</span><br><span class="line">AOP</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">SpringAop 什么时候调用jdk动态代理？什么时候调用cglib</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">1.导入log4j.jar，开启log4j DEBUG模式</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">2.查看打印日志，可以发现一个重要信息：</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line">2020-03-03 15:13:31,870 DEBUG [org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator] - Creating implicit proxy for bean &apos;userService&apos; with 0 common interceptors and 4 specific interceptors</span><br><span class="line">spring再执行aop时，执行了 AnnotationAwareAspectJAutoProxyCreator 类中的某个方法</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">3.通过 AnnotationAwareAspectJAutoProxyCreator 找到最终执行的是其父类 AbstractAutoProxyCreator 中的 protected Advisor[] buildAdvisors(String beanName, Object[] specificInterceptors) 方法</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">4. 重新在 buildAdvisors 这个方法打断点进行调试</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">5.AbstractAutoProxyCreator 类中发现有一个重要的方法createProxy 如下：</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">protected Object createProxy(</span><br><span class="line">    Class&lt;?&gt; beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource) &#123;</span><br><span class="line"></span><br><span class="line">    if (this.beanFactory instanceof ConfigurableListableBeanFactory) &#123;</span><br><span class="line">        AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) this.beanFactory, beanName, beanClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ProxyFactory proxyFactory = new ProxyFactory();</span><br><span class="line">    proxyFactory.copyFrom(this);</span><br><span class="line"></span><br><span class="line">    if (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">        if (shouldProxyTargetClass(beanClass, beanName)) &#123;</span><br><span class="line">            proxyFactory.setProxyTargetClass(true);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            evaluateProxyInterfaces(beanClass, proxyFactory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);</span><br><span class="line">    proxyFactory.addAdvisors(advisors);</span><br><span class="line">    proxyFactory.setTargetSource(targetSource);</span><br><span class="line">    customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">    proxyFactory.setFrozen(this.freezeProxy);</span><br><span class="line">    if (advisorsPreFiltered()) &#123;</span><br><span class="line">        proxyFactory.setPreFiltered(true);</span><br><span class="line">    &#125;</span><br><span class="line">    // 核心代码</span><br><span class="line">    return proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">接着进入 ProxyFactory 中的 getProxy 方法</span><br><span class="line"></span><br><span class="line">public Object getProxy(ClassLoader classLoader) &#123;</span><br><span class="line">    // createAopProxy 方法中判断是选择jdk动态代理还是cglib方式代理</span><br><span class="line">    return createAopProxy().getProxy(classLoader);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">再进入到 ProxyCreatorSupport 中的 createAopProxy 方法</span><br><span class="line"></span><br><span class="line">复制代码</span><br><span class="line">protected final synchronized AopProxy createAopProxy() &#123;</span><br><span class="line">    if (!this.active) &#123;</span><br><span class="line">        activate();</span><br><span class="line">    &#125;</span><br><span class="line">    // getAopProxyFactory() 返回的是 DefaultAopProxyFactory对象，所以重点还是在 createAopProxy 方法上</span><br><span class="line">    return getAopProxyFactory().createAopProxy(this);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">6.进入到 DefaultAopProxyFactory 类中的 createAopProxy 方法，这个方法就是如何选择JDK动态代理还是Cglib代理</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException &#123;</span><br><span class="line">    // 1.config.isProxyTargetClass() 代表 配置中的proxy-target-class属性true/false，默认false</span><br><span class="line">    // </span><br><span class="line">    if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">        // 目标代理类，如 com.service.impl.UserServiceImpl</span><br><span class="line">        Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">        if (targetClass == null) &#123;</span><br><span class="line">            throw new AopConfigException(&quot;TargetSource cannot determine target class: &quot; +</span><br><span class="line">                                         &quot;Either an interface or a target is required for proxy creation.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        // 目标类如果是一个接口 或 </span><br><span class="line">        if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">            return new JdkDynamicAopProxy(config);</span><br><span class="line">        &#125;</span><br><span class="line">        return new ObjenesisCglibAopProxy(config);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        return new JdkDynamicAopProxy(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">方法中参数config 是一个 AdvisedSupport类型， AdvisedSupport 继承了 ProxyConfig 类，</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class ProxyConfig implements Serializable &#123;</span><br><span class="line">    // 代表 配置中的proxy-target-class，如果设置true，则使用Cglib方式代理</span><br><span class="line">    private boolean proxyTargetClass = false;</span><br><span class="line"></span><br><span class="line">    private boolean optimize = false;</span><br><span class="line"></span><br><span class="line">    boolean opaque = false;</span><br><span class="line"></span><br><span class="line">    boolean exposeProxy = false;</span><br><span class="line"></span><br><span class="line">    private boolean frozen = false;</span><br><span class="line"></span><br><span class="line">    // 省略部分代码</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ThreadLocal/">ThreadLocal</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/高并发/">高并发</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="bolg-Session-Token-Cookie" class="article article-type-bolg" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/12/13/Session-Token-Cookie/"
    >Session Token Cookie</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2019/12/13/Session-Token-Cookie/" class="article-date">
  <time datetime="2019-12-13T02:09:01.000Z" itemprop="datePublished">2019-12-13</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/计算机网络/">计算机网络</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h4 id="本文记录一下Session-Token-Cookie到底是什么，以及有什么区别。按顺序来看保证登陆状态的演进的几种方式"><a href="#本文记录一下Session-Token-Cookie到底是什么，以及有什么区别。按顺序来看保证登陆状态的演进的几种方式" class="headerlink" title="本文记录一下Session Token Cookie到底是什么，以及有什么区别。按顺序来看保证登陆状态的演进的几种方式"></a>本文记录一下Session Token Cookie到底是什么，以及有什么区别。按顺序来看保证登陆状态的演进的几种方式</h4><h4 id="1-最开始互联网并没有那么大的体量，每个网站也没有那么多的用户，所以访问网站时，只需要做最简单的用户名密码进行校验就可以，但慢慢的随着用户量增加，体量增大，就面临一个问题，那就是要管理会话，必须记住哪些人登陆系统，也就是说必须要把每个人区分开，这就是一个不小的挑战，因为HTTP请求是无状态的，当时想出的办法是给大家发一个会话标识-session-id-，其实就是一个随机的字符串，每个人的都不一样，作为唯一区分。"><a href="#1-最开始互联网并没有那么大的体量，每个网站也没有那么多的用户，所以访问网站时，只需要做最简单的用户名密码进行校验就可以，但慢慢的随着用户量增加，体量增大，就面临一个问题，那就是要管理会话，必须记住哪些人登陆系统，也就是说必须要把每个人区分开，这就是一个不小的挑战，因为HTTP请求是无状态的，当时想出的办法是给大家发一个会话标识-session-id-，其实就是一个随机的字符串，每个人的都不一样，作为唯一区分。" class="headerlink" title="1.最开始互联网并没有那么大的体量，每个网站也没有那么多的用户，所以访问网站时，只需要做最简单的用户名密码进行校验就可以，但慢慢的随着用户量增加，体量增大，就面临一个问题，那就是要管理会话，必须记住哪些人登陆系统，也就是说必须要把每个人区分开，这就是一个不小的挑战，因为HTTP请求是无状态的，当时想出的办法是给大家发一个会话标识(session_id)，其实就是一个随机的字符串，每个人的都不一样，作为唯一区分。"></a>1.最开始互联网并没有那么大的体量，每个网站也没有那么多的用户，所以访问网站时，只需要做最简单的用户名密码进行校验就可以，但慢慢的随着用户量增加，体量增大，就面临一个问题，那就是要管理会话，必须记住哪些人登陆系统，也就是说必须要把每个人区分开，这就是一个不小的挑战，因为HTTP请求是无状态的，当时想出的办法是给大家发一个会话标识(session_id)，其实就是一个随机的字符串，每个人的都不一样，作为唯一区分。</h4><h4 id="2-这样大家很开心，但是服务器就不开心了，每个人只需要保存自己的session-id，但服务器需要保存所有人的session-id，如果访问服务器多了，就得由成千上万，甚至几十万个，这对服务器是一个巨大的开销，严重限制了服务器扩展的能力，比如说我用两个机器组成了一个集群，小F通过机器A登陆了系统，那session-id会保存在机器A上，假设小F的下一次请求被转发到机器B怎么办？机器B可没有小F的session-id"><a href="#2-这样大家很开心，但是服务器就不开心了，每个人只需要保存自己的session-id，但服务器需要保存所有人的session-id，如果访问服务器多了，就得由成千上万，甚至几十万个，这对服务器是一个巨大的开销，严重限制了服务器扩展的能力，比如说我用两个机器组成了一个集群，小F通过机器A登陆了系统，那session-id会保存在机器A上，假设小F的下一次请求被转发到机器B怎么办？机器B可没有小F的session-id" class="headerlink" title="2.这样大家很开心，但是服务器就不开心了，每个人只需要保存自己的session_id，但服务器需要保存所有人的session_id，如果访问服务器多了，就得由成千上万，甚至几十万个，这对服务器是一个巨大的开销，严重限制了服务器扩展的能力，比如说我用两个机器组成了一个集群，小F通过机器A登陆了系统，那session_id会保存在机器A上，假设小F的下一次请求被转发到机器B怎么办？机器B可没有小F的session_id"></a>2.这样大家很开心，但是服务器就不开心了，每个人只需要保存自己的session_id，但服务器需要保存所有人的session_id，如果访问服务器多了，就得由成千上万，甚至几十万个，这对服务器是一个巨大的开销，严重限制了服务器扩展的能力，比如说我用两个机器组成了一个集群，小F通过机器A登陆了系统，那session_id会保存在机器A上，假设小F的下一次请求被转发到机器B怎么办？机器B可没有小F的session_id</h4><h4 id="3-有时候会采用一点小伎俩，session-sticky，就是让小F的请求一直粘连在机器A上，但是这也不管用，要是机器A挂掉了，还得转到机器B去。"><a href="#3-有时候会采用一点小伎俩，session-sticky，就是让小F的请求一直粘连在机器A上，但是这也不管用，要是机器A挂掉了，还得转到机器B去。" class="headerlink" title="3.有时候会采用一点小伎俩，session sticky，就是让小F的请求一直粘连在机器A上，但是这也不管用，要是机器A挂掉了，还得转到机器B去。"></a>3.有时候会采用一点小伎俩，session sticky，就是让小F的请求一直粘连在机器A上，但是这也不管用，要是机器A挂掉了，还得转到机器B去。</h4><h4 id="4-那就只好做session-id的复制了，把session-id在两个机器之间搬来搬去，快累死了。"><a href="#4-那就只好做session-id的复制了，把session-id在两个机器之间搬来搬去，快累死了。" class="headerlink" title="4.那就只好做session_id的复制了，把session_id在两个机器之间搬来搬去，快累死了。"></a>4.那就只好做session_id的复制了，把session_id在两个机器之间搬来搬去，快累死了。</h4><h4 id="5-后来有个叫Memcached的支了招，把session-id集中存储到一个地方，所有的机器都来访问这个地方的数据，这样一来，就不用复制了，但是增加了单点失败的可能性，要是那个负责session的机器挂了，所有人就需要重新登陆一边，后来也尝试把这个单点的机器也搞出集群，增加可靠性，但不管如何，这小小的session对我来说是一个沉重的负担。"><a href="#5-后来有个叫Memcached的支了招，把session-id集中存储到一个地方，所有的机器都来访问这个地方的数据，这样一来，就不用复制了，但是增加了单点失败的可能性，要是那个负责session的机器挂了，所有人就需要重新登陆一边，后来也尝试把这个单点的机器也搞出集群，增加可靠性，但不管如何，这小小的session对我来说是一个沉重的负担。" class="headerlink" title="5.后来有个叫Memcached的支了招，把session_id集中存储到一个地方，所有的机器都来访问这个地方的数据，这样一来，就不用复制了，但是增加了单点失败的可能性，要是那个负责session的机器挂了，所有人就需要重新登陆一边，后来也尝试把这个单点的机器也搞出集群，增加可靠性，但不管如何，这小小的session对我来说是一个沉重的负担。"></a>5.后来有个叫Memcached的支了招，把session_id集中存储到一个地方，所有的机器都来访问这个地方的数据，这样一来，就不用复制了，但是增加了单点失败的可能性，要是那个负责session的机器挂了，所有人就需要重新登陆一边，后来也尝试把这个单点的机器也搞出集群，增加可靠性，但不管如何，这小小的session对我来说是一个沉重的负担。</h4><h4 id="6-于是有人就一直思考，我为什么要保存这可恶的session-id呢，只让每个客户端去保存该多好，可是如果不保存这些session-id，怎么验证客户端发给我的session-id的确是我生成的呢？如果不去验证，我们都不知道他们是不是合法的登陆用户，那些不怀好意的家伙就可以伪造session-id-为所欲为了。关键就是验证，这个时候token应运而生，用户登陆系统，最简单的token组成-uid-用户唯一的身份标识-、time-当前时间的时间戳-、sign-签名，由token的前几位-盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器-。"><a href="#6-于是有人就一直思考，我为什么要保存这可恶的session-id呢，只让每个客户端去保存该多好，可是如果不保存这些session-id，怎么验证客户端发给我的session-id的确是我生成的呢？如果不去验证，我们都不知道他们是不是合法的登陆用户，那些不怀好意的家伙就可以伪造session-id-为所欲为了。关键就是验证，这个时候token应运而生，用户登陆系统，最简单的token组成-uid-用户唯一的身份标识-、time-当前时间的时间戳-、sign-签名，由token的前几位-盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器-。" class="headerlink" title="6.于是有人就一直思考，我为什么要保存这可恶的session_id呢，只让每个客户端去保存该多好，可是如果不保存这些session_id，怎么验证客户端发给我的session_id的确是我生成的呢？如果不去验证，我们都不知道他们是不是合法的登陆用户，那些不怀好意的家伙就可以伪造session_id,为所欲为了。关键就是验证，这个时候token应运而生，用户登陆系统，最简单的token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器)。"></a>6.于是有人就一直思考，我为什么要保存这可恶的session_id呢，只让每个客户端去保存该多好，可是如果不保存这些session_id，怎么验证客户端发给我的session_id的确是我生成的呢？如果不去验证，我们都不知道他们是不是合法的登陆用户，那些不怀好意的家伙就可以伪造session_id,为所欲为了。关键就是验证，这个时候token应运而生，用户登陆系统，最简单的token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器)。</h4><h4 id="7-至此基本的登陆过程就讲完了，但是现在也出现了更加安全的便捷的方式，token更多用于单点登录，拿着token去sso验证，验证通过可以重定向到之前访问的网站。"><a href="#7-至此基本的登陆过程就讲完了，但是现在也出现了更加安全的便捷的方式，token更多用于单点登录，拿着token去sso验证，验证通过可以重定向到之前访问的网站。" class="headerlink" title="7.至此基本的登陆过程就讲完了，但是现在也出现了更加安全的便捷的方式，token更多用于单点登录，拿着token去sso验证，验证通过可以重定向到之前访问的网站。"></a>7.至此基本的登陆过程就讲完了，但是现在也出现了更加安全的便捷的方式，token更多用于单点登录，拿着token去sso验证，验证通过可以重定向到之前访问的网站。</h4><h4 id="8-总结一下cookie，session，token"><a href="#8-总结一下cookie，session，token" class="headerlink" title="8.总结一下cookie，session，token"></a>8.总结一下cookie，session，token</h4><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><h4 id="cookie存储在客户端，HTTP是无状态的，HTTP每次发出的时候会附上改域名下的cookie，从而可以给HTTP附上状态，最常见的就是登陆态。"><a href="#cookie存储在客户端，HTTP是无状态的，HTTP每次发出的时候会附上改域名下的cookie，从而可以给HTTP附上状态，最常见的就是登陆态。" class="headerlink" title="cookie存储在客户端，HTTP是无状态的，HTTP每次发出的时候会附上改域名下的cookie，从而可以给HTTP附上状态，最常见的就是登陆态。"></a>cookie存储在客户端，HTTP是无状态的，HTTP每次发出的时候会附上改域名下的cookie，从而可以给HTTP附上状态，最常见的就是登陆态。</h4><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><h4 id="1-客户端向服务器请求，发送用户名和密码"><a href="#1-客户端向服务器请求，发送用户名和密码" class="headerlink" title="1.客户端向服务器请求，发送用户名和密码"></a>1.客户端向服务器请求，发送用户名和密码</h4><h4 id="2-服务器生成session-id，绑定用户数据存储在数据库"><a href="#2-服务器生成session-id，绑定用户数据存储在数据库" class="headerlink" title="2.服务器生成session_id，绑定用户数据存储在数据库"></a>2.服务器生成session_id，绑定用户数据存储在数据库</h4><h4 id="3-服务器返回session-id给客户端"><a href="#3-服务器返回session-id给客户端" class="headerlink" title="3.服务器返回session_id给客户端"></a>3.服务器返回session_id给客户端</h4><h4 id="4-客户端用cookie存储session-id，以后请求都带上这个session-id"><a href="#4-客户端用cookie存储session-id，以后请求都带上这个session-id" class="headerlink" title="4.客户端用cookie存储session_id，以后请求都带上这个session_id"></a>4.客户端用cookie存储session_id，以后请求都带上这个session_id</h4><h4 id="5-服务器如果收到这个session-id，那么就去数据库查找用户数据，如果找到了说明验证通过"><a href="#5-服务器如果收到这个session-id，那么就去数据库查找用户数据，如果找到了说明验证通过" class="headerlink" title="5.服务器如果收到这个session_id，那么就去数据库查找用户数据，如果找到了说明验证通过"></a>5.服务器如果收到这个session_id，那么就去数据库查找用户数据，如果找到了说明验证通过</h4><h4 id="6-服务器把验证结果返回客户端"><a href="#6-服务器把验证结果返回客户端" class="headerlink" title="6.服务器把验证结果返回客户端"></a>6.服务器把验证结果返回客户端</h4><h3 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h3><h4 id="1-客户端向服务器请求，发送用户名和密码-1"><a href="#1-客户端向服务器请求，发送用户名和密码-1" class="headerlink" title="1.客户端向服务器请求，发送用户名和密码"></a>1.客户端向服务器请求，发送用户名和密码</h4><h4 id="2-服务器根据用户信息通过加密生成token，用户信息包括账号，token过期时间等，具体由服务器自定义"><a href="#2-服务器根据用户信息通过加密生成token，用户信息包括账号，token过期时间等，具体由服务器自定义" class="headerlink" title="2.服务器根据用户信息通过加密生成token，用户信息包括账号，token过期时间等，具体由服务器自定义"></a>2.服务器根据用户信息通过加密生成token，用户信息包括账号，token过期时间等，具体由服务器自定义</h4><h4 id="3-服务器返回token给客户端"><a href="#3-服务器返回token给客户端" class="headerlink" title="3.服务器返回token给客户端"></a>3.服务器返回token给客户端</h4><h4 id="4-客户端用cookie存储token，以后的请求都带上这个token"><a href="#4-客户端用cookie存储token，以后的请求都带上这个token" class="headerlink" title="4.客户端用cookie存储token，以后的请求都带上这个token"></a>4.客户端用cookie存储token，以后的请求都带上这个token</h4><h4 id="5-服务器拿到token，把token解密，确认用户信息是否正确"><a href="#5-服务器拿到token，把token解密，确认用户信息是否正确" class="headerlink" title="5.服务器拿到token，把token解密，确认用户信息是否正确"></a>5.服务器拿到token，把token解密，确认用户信息是否正确</h4><h4 id="6-服务器把验证结果返回给客户端"><a href="#6-服务器把验证结果返回给客户端" class="headerlink" title="6.服务器把验证结果返回给客户端"></a>6.服务器把验证结果返回给客户端</h4><h3 id="Session，token优劣"><a href="#Session，token优劣" class="headerlink" title="Session，token优劣"></a>Session，token优劣</h3><h4 id="session"><a href="#session" class="headerlink" title="session"></a>session</h4><h5 id="由于session-id和用户信息相互绑定的数据库存在服务器，所以服务器可以随时让发送出去的一个session-id失效，这是保障安全的一种重要手段"><a href="#由于session-id和用户信息相互绑定的数据库存在服务器，所以服务器可以随时让发送出去的一个session-id失效，这是保障安全的一种重要手段" class="headerlink" title="由于session_id和用户信息相互绑定的数据库存在服务器，所以服务器可以随时让发送出去的一个session_id失效，这是保障安全的一种重要手段"></a>由于session_id和用户信息相互绑定的数据库存在服务器，所以服务器可以随时让发送出去的一个session_id失效，这是保障安全的一种重要手段</h5><h4 id="token"><a href="#token" class="headerlink" title="token"></a>token</h4><h5 id="token的好处是比session更省空间和时间，服务器不需要去管理session-id和用户信息的数据库，服务器收到token直接解密就可以验证，不需要去数据库查找验证，但是token发出去之后，就只能等待它过期之后才会失效，后台服务器无法对其进行控制"><a href="#token的好处是比session更省空间和时间，服务器不需要去管理session-id和用户信息的数据库，服务器收到token直接解密就可以验证，不需要去数据库查找验证，但是token发出去之后，就只能等待它过期之后才会失效，后台服务器无法对其进行控制" class="headerlink" title="token的好处是比session更省空间和时间，服务器不需要去管理session_id和用户信息的数据库，服务器收到token直接解密就可以验证，不需要去数据库查找验证，但是token发出去之后，就只能等待它过期之后才会失效，后台服务器无法对其进行控制"></a>token的好处是比session更省空间和时间，服务器不需要去管理session_id和用户信息的数据库，服务器收到token直接解密就可以验证，不需要去数据库查找验证，但是token发出去之后，就只能等待它过期之后才会失效，后台服务器无法对其进行控制</h5><h4 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">加入jwt依赖</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.auth0&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;java-jwt&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">声明2个变量过期时间和token秘钥(UUID可能会更好，我是自己随便输的)，token秘钥用于后面解密</span><br><span class="line"></span><br><span class="line">    //设置30分钟过期</span><br><span class="line">    private static final long EXPIRE_DATE=30*60*1000;</span><br><span class="line">    //token秘钥</span><br><span class="line">    private static final String TOKEN_SECRET = &quot;EQIUBFKSJBFJH2367816BQWE&quot;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">加密</span><br><span class="line">public static String tokenTest (String username,String password)&#123;        </span><br><span class="line"> </span><br><span class="line">        String token = &quot;&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            //过期时间</span><br><span class="line">            Date date = new Date(System.currentTimeMillis()+EXPIRE_DATE);</span><br><span class="line">            //秘钥及加密算法</span><br><span class="line">            Algorithm algorithm = Algorithm.HMAC256(TOKEN_SECRET);</span><br><span class="line">            //设置头部信息</span><br><span class="line">            Map&lt;String,Object&gt; header = new HashMap&lt;&gt;();</span><br><span class="line">            header.put(&quot;typ&quot;,&quot;JWT&quot;);</span><br><span class="line">            header.put(&quot;alg&quot;,&quot;HS256&quot;);</span><br><span class="line">            //携带username，password信息，生成签名</span><br><span class="line">            token = JWT.create()</span><br><span class="line">                    .withHeader(header)</span><br><span class="line">                    .withClaim(&quot;username&quot;,username)</span><br><span class="line">                    .withClaim(&quot;password&quot;,password).withExpiresAt(date)</span><br><span class="line">                    .sign(algorithm);</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return  null;</span><br><span class="line">        &#125;</span><br><span class="line">        return token;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">解密。该方法的参数token是加密方法的返回值</span><br><span class="line">public static boolean verify(String token)&#123;</span><br><span class="line">        /**</span><br><span class="line">         * @desc   验证token，通过返回true</span><br><span class="line">         * @create 2019/1/18/018 9:39</span><br><span class="line">         * @params [token]需要校验的串</span><br><span class="line">        **/</span><br><span class="line">        try &#123;</span><br><span class="line">            Algorithm algorithm = Algorithm.HMAC256(TOKEN_SECRET);</span><br><span class="line">            JWTVerifier verifier = JWT.require(algorithm).build();</span><br><span class="line">            DecodedJWT jwt = verifier.verify(token);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return  false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">登陆接口</span><br><span class="line">@RequestMapping(value = &quot;/logon&quot;)</span><br><span class="line">    public JsonRESTResult getUserInfo(HttpSession session ,String userName, String password) &#123;</span><br><span class="line">        /**</span><br><span class="line">        * @author Syl</span><br><span class="line">        * @create 2019/12/13 9:55</span><br><span class="line">        * @params [session, userName, password]</span><br><span class="line">        **/</span><br><span class="line">        JsonRESTResult jsonRESTResult = new JsonRESTResult();        </span><br><span class="line">        //使用token工具类生成token串</span><br><span class="line">        String token  = TokenUtil.tokenTest(userName,password);</span><br><span class="line">        //根据用户名密码查找用户</span><br><span class="line">        User user = loginService.findUser(userName,password);</span><br><span class="line">        if (user !=null)&#123;</span><br><span class="line">            //将用户对象放到session中</span><br><span class="line">            session.setAttribute(&quot;USER_INFO&quot;,user);</span><br><span class="line">            //用户无操作30分钟需重新登录</span><br><span class="line">            session.setMaxInactiveInterval(60*30);</span><br><span class="line">            Map map = new HashMap&lt;&gt;();</span><br><span class="line">            map.put(&quot;USERINFO&quot;,user);</span><br><span class="line">            map.put(&quot;SESSIONID&quot;,session.getId());</span><br><span class="line">            map.put(&quot;token&quot;,token);</span><br><span class="line">            jsonRESTResult.setCode(JsonRESTResultMsg.CODE_800.getCode());</span><br><span class="line">            jsonRESTResult.setMsg(&quot;登录成功&quot;);</span><br><span class="line">            jsonRESTResult.setData(map);</span><br><span class="line">            return jsonRESTResult;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            jsonRESTResult.setCode(JsonRESTResultMsg.CODE_500.getCode());</span><br><span class="line">            jsonRESTResult.setMsg(&quot;登录失败,用户名密码错误&quot;);</span><br><span class="line">            jsonRESTResult.setData(null);</span><br><span class="line">            return jsonRESTResult;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">验证用户是否登陆接口</span><br><span class="line">@RequestMapping(&quot;/judgeLogin&quot;)</span><br><span class="line">    public JsonRESTResult judgeLogin(String token,HttpSession session)&#123;</span><br><span class="line">        JsonRESTResult jsonRESTResult = new JsonRESTResult();</span><br><span class="line">        if (TokenUtil.verify(token))&#123;</span><br><span class="line">            User user = (User)session.getAttribute(&quot;USER_INFO&quot;);</span><br><span class="line">            jsonRESTResult.setCode(JsonRESTResultMsg.CODE_800.getCode());</span><br><span class="line">            jsonRESTResult.setData(user);</span><br><span class="line">            jsonRESTResult.setMsg(&quot;用户登录成功&quot;);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            jsonRESTResult.setCode(JsonRESTResultMsg.CODE_500.getCode());</span><br><span class="line">            jsonRESTResult.setMsg(&quot;未登录或已过期&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return jsonRESTResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Session-Token-Cookie/">Session Token Cookie</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/计算机网络/">计算机网络</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="blog-深入浅出索引" class="article article-type-blog" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/10/26/深入浅出索引/"
    >深入浅出索引</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2019/10/26/深入浅出索引/" class="article-date">
  <time datetime="2019-10-26T15:46:47.000Z" itemprop="datePublished">2019-10-26</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库/">数据库</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>这节讲的是索引的相关知识，提到索引相信大家都不会陌生，在工作中或多或少都会接触过，建立索引主要是用来提升SQL查询速度的一种解决方案。<br>那么索引是什么？<br>一句话简单来说，索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。  </p>
<h3 id="索引的常见模型"><a href="#索引的常见模型" class="headerlink" title="索引的常见模型"></a>索引的常见模型</h3><p>这里引入三种模型，哈希表有序数组和搜索树  </p>
<p>哈希表是一种以建-值（key-value）存储的数据结构，我们只要输入待查找的key，就能找到value。哈希的思路很简单，把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置。<br>不可避免的，多个key经过哈希函数的换算会出现同一个值的情况，处理这种情况的方式是，拉出一个链表。<br>假设，你现在维护着一个身份证信息和姓名的表，需要根据身份证号查找对应的名字。这时对应的哈希索引的示意图如下所示。  </p>
<p><img src="../image/%E5%93%88%E5%B8%8C%E8%A1%A8.png" alt="哈希表.png" title="哈希表">  </p>
<p>需要注意的是，图中四个ID_card_n的值并不是递增的，这样做的好处是增加新的User时速度会很快，只需要往后追加。但缺点是，因为不是有序的，所以哈希索引做区间查询速度是很慢的。  </p>
<p>所以，哈希表这种结构适用于只有等值查询的场景，比如 Memcached 及其他一些 NoSQL 引擎。  </p>
<p>而有序数组在等值查询和范围查询场景的性能就都非常优秀。还是根据上面这个例子，如果用有序数组来实现的话，示意图如下所示：  </p>
<p><img src="../image/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84.png" alt="有序数组.png" title="有序数组">  </p>
<p>这里假设身份证号没有重复，这个数组就是按照身份证号递增的顺序保存的，这个时候如果你要查ID_card_n2对应的名字，用二分法就可以快速得到，这个时间复杂度是O(log(N)).<br>同时很显然，这个索引结构支持范围查询。你要查身份证号在[ID_card_X,ID_card_Y]区间的User，可以先用二分法找到ID_card_X(如果不存在ID_card_X，就找到大于ID_card_X的第一个User)，然后向右遍历，直到查到第一个大于ID_card_Y的身份证号，推出循环。<br>如果仅仅看查询效率，有序数组就是最好的数据结构了，但是在更新数据的时候，如果有新增的数据，就需要挪动后续所有的记录，成本太高。<br>所以，有序数组只适用于静态存储引擎，比如你要保存的是2019年某个城市所有人口的信息，这类不会再修改的数据。<br>二叉搜索树是经典的数据结构了，还是根据上面的例子，如果我们用二叉搜索树来实现的话，示意图如下所示，</p>
<p><img src="../image/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.png" alt="二叉搜索树.png" title="二叉搜索树">  </p>
<p>二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子，这样如果你要查ID_card_2的话按照图中的顺序就是按照UserA -&gt; UserC -&gt; UserF -&gt; User2这个路径得到。这个时间复杂度是O(log(N))。<br>当然为了维持O(log(N))的查询复杂度，你就需要保持这颗树是平衡二叉树，为了做这个保证，更新的时间复杂度也是O(log(N))。<br>树可以有二叉，也可以有多叉，多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右递增。二叉搜索树的效率是最高的，但是实际上大多数数据库存储却并不适用二叉树。其原因是，索引不止存在于内存中，还要写到磁盘上。<br>你可以想象一下一棵100万节点的平衡二叉树，树高20，一次查询可能需要访问20个数据块，在机械硬盘时代，从磁盘随机读取一个数据块需要10ms的寻址时间，也就是说，对于一个100万行的表，如果使用二叉树来存储，单独访问一个行可能需要20个10ms的时间，这个查询可真够慢的，为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N 叉”树。这里，“N 叉”树中的“N”取决于数据块的大小。以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。考虑到树根的数据块总是在内存中的，一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。</p>
<p>N 叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。  </p>
<h3 id="InnoDB的索引模型"><a href="#InnoDB的索引模型" class="headerlink" title="InnoDB的索引模型"></a>InnoDB的索引模型</h3><p>大家都知道InnoDB的索引模型是B+树，假设我们有一个主键列为ID的表，表中有字段K，并且在K上有索引，如下图所示：  </p>
<p><img src="../image/InnoDB%E7%B4%A2%E5%BC%95.png" alt="InnoDB索引.png" title="InnoDB索引">  </p>
<p>从图中不难看出，根据叶子节点的内容，索引类型分为主键索引和非主键索引。</p>
<p>主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。  </p>
<p>非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。</p>
<p>根据上面的索引结构说明，我们来讨论一个问题：基于主键索引和普通索引的查询有什么区别？</p>
<p>如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；<br>如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为_回表_。<br>也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。   </p>
<p>除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。</p>
<p>当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。</p>
<p>基于上面的索引维护过程说明，我们来讨论一个案例：</p>
<p>你可能在一些建表规范里面见到过类似的描述，要求建表语句里一定要有自增主键。当然事无绝对，我们来分析一下哪些场景下应该使用自增主键，而哪些场景下不应该。</p>
<p>自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。</p>
<p>插入新记录的时候可以不指定 ID 的值，系统会获取当前 ID 最大值加 1 作为下一条记录的 ID 值。</p>
<p>也就是说，自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。</p>
<p>而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。</p>
<p>除了考虑性能外，我们还可以从存储空间的角度来看。假设你的表中确实有一个唯一字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？</p>
<p>由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约 20 个字节，而如果用整型做主键，则只要 4 个字节，如果是长整型（bigint）则是 8 个字节。</p>
<p>显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</p>
<p>所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。</p>
<p>有没有什么场景适合用业务字段直接做主键的呢？还是有的。比如，有些业务的场景需求是这样的：</p>
<p>只有一个索引；</p>
<p>该索引必须是唯一索引。</p>
<p>你一定看出来了，这就是典型的 KV 场景。</p>
<p>由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。</p>
<p>这时候我们就要优先考虑上一段提到的“尽量使用主键查询”原则，直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。 </p>
<p>对于一张表可以这么理解：<br>每一张表其实就是好几个B+树，树结点的key值就是某一行的主键，value是该行的其他数据。新建索引就是新增一个B+树，查询不走索引就是遍历主B+树。</p>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>如果执行的语句是 select ID from T where k between 3 and 5，这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引 k 已经“覆盖了”我们的查询需求，我们称为覆盖索引。</p>
<p>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</p>
<p>需要注意的是，在引擎内部使用覆盖索引在索引 k 上其实读了三个记录，R3~R5（对应的索引 k 上的记录项），但是对于 MySQL 的 Server 层来说，它就是找引擎拿到了两条记录，因此 MySQL 认为扫描行数是 2。  </p>
<p>基于上面覆盖索引的说明，我们来讨论一个问题：在一个市民信息表上，是否有必要将身份证号和名字建立联合索引？  </p>
<p>我们知道，身份证号是市民的唯一标识。也就是说，如果有根据身份证号查询市民信息的需求，我们只要在身份证号字段上建立索引就够了。而再建立一个（身份证号、姓名）的联合索引，是不是浪费空间？</p>
<p>如果现在有一个高频请求，要根据市民的身份证号查询他的姓名，这个联合索引就有意义了。它可以在这个高频请求上用到覆盖索引，不再需要回表查整行记录，减少语句的执行时间。</p>
<p>当然，索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这正是业务 DBA，或者称为业务数据架构师的工作。  </p>
<h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>对于最左前缀原则大家都应该轻车熟路了，就不过多介绍，有些重点内容可以考虑一下：<br>基于上面对最左前缀索引的说明，我们来讨论一个问题：在建立联合索引的时候，如何安排索引内的字段顺序。</p>
<p>这里我们的评估标准是，索引的复用能力。因为可以支持最左前缀，所以当已经有了 (a,b) 这个联合索引后，一般就不需要单独在 a 上建立索引了。因此，第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。  </p>
<p>所以现在你知道了，这段开头的问题里，我们要为高频请求创建 (身份证号，姓名）这个联合索引，并用这个索引支持“根据身份证号查询地址”的需求。</p>
<p>那么，如果既有联合查询，又有基于 a、b 各自的查询呢？查询条件里面只有 b 的语句，是无法使用 (a,b) 这个联合索引的，这时候你不得不维护另外一个索引，也就是说你需要同时维护 (a,b)、(b) 这两个索引。</p>
<p>这时候，我们要考虑的原则就是空间了。比如上面这个市民表的情况，name 字段是比 age 字段大的 ，那我就建议你创建一个（name,age) 的联合索引和一个 (age) 的单字段索引。  </p>
<h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>上一段我们说到满足最左前缀原则的时候，最左前缀可以用于在索引中定位记录。这时，你可能要问，那些不符合最左前缀的部分，会怎么样呢？</p>
<p>我们还是以市民表的联合索引（name, age）为例。如果现在有一个需求：检索出表中“名字第一个字是张，而且年龄是 10 岁的所有男孩”。那么，SQL 语句是这么写的：   </p>
<p><code>mysql&gt; select * from tuser where name like &#39;张 %&#39; and age=10 and ismale=1;</code></p>
<p>你已经知道了前缀索引规则，所以这个语句在搜索索引树的时候，只能用 “张”，找到第一个满足条件的记录 ID3。当然，这还不错，总比全表扫描要好。</p>
<p>然后呢？</p>
<p>当然是判断其他条件是否满足。</p>
<p>在 MySQL 5.6 之前，只能从 ID3 开始一个个回表。到主键索引上找出数据行，再对比字段值。</p>
<p>而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p>
<p>图 3 和图 4，是这两个过程的执行流程图。</p>
<p><img src="../image/%E5%9B%BE3.png" alt="图3.png" title="图3">  </p>
<p><img src="../image/%E5%9B%BE3.png" alt="图3.png" title="图3">  </p>
<p>在图 3 和 4 这两个图里面，每一个虚线箭头表示回表一次。</p>
<p>图 3 中，在 (name,age) 索引里面我特意去掉了 age 的值，这个过程 InnoDB 并不会去看 age 的值，只是按顺序把“name 第一个字是’张’”的记录一条条取出来回表。因此，需要回表 4 次。</p>
<p>图 4 跟图 3 的区别是，InnoDB 在 (name,age) 索引内部就判断了 age 是否等于 10，对于不等于 10 的记录，直接判断并跳过。在我们的这个例子中，只需要对 ID4、ID5 这两条记录回表取数据判断，就只需要回表 2 次。</p>
<h3 id="课后问题"><a href="#课后问题" class="headerlink" title="课后问题"></a>课后问题</h3><p>实际上主键索引也是可以使用多个字段的。DBA 小吕在入职新公司的时候，就发现自己接手维护的库里面，有这么一个表，表结构定义类似这样的：</p>
<figure class="highlight plain"><figcaption><span>TABLE `geek` (</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  `a` int(11) NOT NULL,</span><br><span class="line">  `b` int(11) NOT NULL,</span><br><span class="line">  `c` int(11) NOT NULL,</span><br><span class="line">  `d` int(11) NOT NULL,</span><br><span class="line">  PRIMARY KEY (`a`,`b`),</span><br><span class="line">  KEY `c` (`c`),</span><br><span class="line">  KEY `ca` (`c`,`a`),</span><br><span class="line">  KEY `cb` (`c`,`b`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">公司的同事告诉他说，由于历史原因，这个表需要 a、b 做联合主键，这个小吕理解了。</span><br><span class="line"></span><br><span class="line">但是，学过本章内容的小吕又纳闷了，既然主键包含了 a、b 这两个字段，那意味着单独在字段 c 上创建一个索引，就已经包含了三个字段了呀，为什么要创建“ca”“cb”这两个索引？</span><br><span class="line"></span><br><span class="line">同事告诉他，是因为他们的业务里面有这样的两种语句：</span><br></pre></td></tr></table></figure>

<p>select * from geek where c=N order by a limit 1;<br>select * from geek where c=N order by b limit 1;<br>```  </p>
<p>我给你的问题是，这位同事的解释对吗，为了这两个查询模式，这两个索引是否都是必须的？为什么呢？  </p>
<p>解答：  </p>
<p>表记录<br>–a–|–b–|–c–|–d–<br>1 2 3 d<br>1 3 2 d<br>1 4 3 d<br>2 1 3 d<br>2 2 2 d<br>2 3 4 d<br>主键 a，b 的聚簇索引组织顺序相当于 order by a,b ，也就是先按 a 排序，再按 b 排序，c 无序。</p>
<p>索引 ca 的组织是先按 c 排序，再按 a 排序，同时记录主键<br>–c–|–a–|–主键部分b– （注意，这里不是 ab，而是只有 b）<br>2 1 3<br>2 2 2<br>3 1 2<br>3 1 4<br>3 2 1<br>4 2 3<br>这个跟索引 c 的数据是一模一样的。</p>
<p>索引 cb 的组织是先按 c 排序，在按 b 排序，同时记录主键<br>–c–|–b–|–主键部分a– （同上）<br>2 2 2<br>2 3 1<br>3 1 2<br>3 2 1<br>3 4 1<br>4 3 2  </p>
<p>所以，结论是 ca 可以去掉，cb 需要保留。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据库/">数据库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/索引/">索引</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="blog-leetcode338" class="article article-type-blog" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/10/20/leetcode338/"
    >leetcode338</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2019/10/20/leetcode338/" class="article-date">
  <time datetime="2019-10-20T15:52:18.000Z" itemprop="datePublished">2019-10-20</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/leetcode/">leetcode</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: 2</span><br><span class="line">输出: [0,1,1]</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: 5</span><br><span class="line">输出: [0,1,1,2,1,2]</span><br></pre></td></tr></table></figure>

<p>进阶:<br>给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？<br>要求算法的空间复杂度为O(n)。<br>你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount）来执行此操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int[] countBits(int num) &#123;</span><br><span class="line">        int[] result = new int[num+1];</span><br><span class="line">        for (int i = 1; i &lt;= num; i++) &#123;</span><br><span class="line">            result[i] = result[i&amp;(i-1)] + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] ints = new Solution().countBits(2);</span><br><span class="line">        for(int i : ints)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最主要的是i&amp;(i-1)是将二进制的最后的1去掉，举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">24的二进制是11000</span><br><span class="line">24-1=23的二进制是10111</span><br><span class="line">11000&amp;10111 = 10000</span><br><span class="line">这样就把24的最后的1去掉了 </span><br><span class="line">result[i] = result[i&amp;(i-1)] + 1;</span><br><span class="line">首先i&amp;(i-1)一定比i小，所以这段代码可以保证result[i&amp;(i-1)]一定是之前计算过的，然后在后面加上1就是一共有的1的个数</span><br></pre></td></tr></table></figure>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode338/">leetcode338</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/二进制数/">二进制数</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="blog-leetcode79" class="article article-type-blog" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/10/20/leetcode79/"
    >leetcode79</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2019/10/20/leetcode79/" class="article-date">
  <time datetime="2019-10-20T15:47:11.000Z" itemprop="datePublished">2019-10-20</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/leetcode/">leetcode</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">board =</span><br><span class="line">[</span><br><span class="line">  [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;],</span><br><span class="line">  [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;],</span><br><span class="line">  [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">给定 word = &quot;ABCCED&quot;, 返回 true.</span><br><span class="line">给定 word = &quot;SEE&quot;, 返回 true.</span><br><span class="line">给定 word = &quot;ABCB&quot;, 返回 false.</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line"></span><br><span class="line">    static int[] row = &#123;0,1,0,-1&#125;;</span><br><span class="line">    static int[] column = &#123;1,0,-1,0&#125;;</span><br><span class="line"></span><br><span class="line">    public  boolean exist(char[][] board, String word) &#123;</span><br><span class="line"></span><br><span class="line">        for (int i =0,rowLen = board.length;i&lt;rowLen;i++)&#123;</span><br><span class="line">            for (int j=0,columnLen = board[0].length;j&lt;columnLen;j++)&#123;</span><br><span class="line">                if (dfs(board,word,i,j,0)) return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean dfs(char[][] board,String word,int x,int y,int index)&#123;</span><br><span class="line">        if (x&lt;0 || x&gt;=board.length || y&lt;0 || y&gt;=board[0].length) return false;</span><br><span class="line"></span><br><span class="line">        if(board[x][y] != word.charAt(index)) return false;</span><br><span class="line"></span><br><span class="line">        if(index == word.length() - 1) return true;</span><br><span class="line"></span><br><span class="line">        board[x][y] = &apos;#&apos;;</span><br><span class="line"></span><br><span class="line">        for (int i = 0 ; i&lt;4;i++)&#123;</span><br><span class="line">            if (dfs(board,word,x+row[i],y+column[i],index+1)) return true;</span><br><span class="line">        &#125;</span><br><span class="line">        board[x][y] = word.charAt(index);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        char[][] borad = &#123;&#123;&apos;F&apos;,&apos;Y&apos;,&apos;C&apos;,&apos;E&apos;,&apos;N&apos;,&apos;R&apos;,&apos;D&apos;&#125;,&#123;&apos;K&apos;,&apos;L&apos;,&apos;N&apos;,&apos;F&apos;,&apos;I&apos;,&apos;N&apos;,&apos;U&apos;&#125;,&#123;&apos;A&apos;,&apos;A&apos;,&apos;A&apos;,&apos;R&apos;,&apos;A&apos;,&apos;H&apos;,&apos;R&apos;&#125;,&#123;&apos;N&apos;,&apos;D&apos;,&apos;K&apos;,&apos;L&apos;,&apos;P&apos;,&apos;N&apos;,&apos;E&apos;&#125;,&#123;&apos;A&apos;,&apos;L&apos;,&apos;A&apos;,&apos;N&apos;,&apos;S&apos;,&apos;A&apos;,&apos;P&apos;&#125;,&#123;&apos;O&apos;,&apos;O&apos;,&apos;G&apos;,&apos;O&apos;,&apos;T&apos;,&apos;P&apos;,&apos;N&apos;&#125;,&#123;&apos;H&apos;,&apos;P&apos;,&apos;O&apos;,&apos;L&apos;,&apos;A&apos;,&apos;N&apos;,&apos;O&apos;&#125;&#125;;</span><br><span class="line">        String word= &quot;poland&quot;;</span><br><span class="line">        System.out.println(new Solution().exist(borad,word));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要说明一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">board[x][y] = &apos;#&apos;;</span><br></pre></td></tr></table></figure>

<p>是将已经查找过的做一个标记，以及</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static int[] row = &#123;0,1,0,-1&#125;;</span><br><span class="line">static int[] column = &#123;1,0,-1,0&#125;;</span><br></pre></td></tr></table></figure>

<p>这段代码是指向四周遍历的坐标点。深度遍历的时候会经常用到，本道题用到了深度优先遍历和回溯。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode79/">leetcode79</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/二维网格/">二维网格</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="blog-leetcode208" class="article article-type-blog" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/10/20/leetcode208/"
    >leetcode208</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2019/10/20/leetcode208/" class="article-date">
  <time datetime="2019-10-20T15:43:10.000Z" itemprop="datePublished">2019-10-20</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/leetcode/">leetcode</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Trie trie = new Trie();</span><br><span class="line"></span><br><span class="line">trie.insert(&quot;apple&quot;);</span><br><span class="line">trie.search(&quot;apple&quot;);   // 返回 true</span><br><span class="line">trie.search(&quot;app&quot;);     // 返回 false</span><br><span class="line">trie.startsWith(&quot;app&quot;); // 返回 true</span><br><span class="line">trie.insert(&quot;app&quot;);   </span><br><span class="line">trie.search(&quot;app&quot;);     // 返回 true</span><br></pre></td></tr></table></figure>

<p>说明:你可以假设所有的输入都是由小写字母 a-z 构成的。<br>保证所有输入均为非空字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class TrieNode &#123;</span><br><span class="line"></span><br><span class="line">    public char val;</span><br><span class="line"></span><br><span class="line">    public TrieNode[] children = new TrieNode[26];</span><br><span class="line"></span><br><span class="line">    public boolean isWord;</span><br><span class="line"></span><br><span class="line">    public TrieNode() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public TrieNode(char c) &#123;</span><br><span class="line">        TrieNode node = new TrieNode();</span><br><span class="line">        node.val = c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public class Trie &#123;</span><br><span class="line">    private TrieNode root;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Initialize your data structure here.</span><br><span class="line">     */</span><br><span class="line">    public Trie() &#123;</span><br><span class="line">        root = new TrieNode();</span><br><span class="line">        root.val = &apos; &apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Inserts a word into the trie.</span><br><span class="line">     */</span><br><span class="line">    public void insert(String word) &#123;</span><br><span class="line">        TrieNode t = root;</span><br><span class="line">        for (int i = 0; i &lt; word.length(); i++) &#123;</span><br><span class="line">            char c = word.charAt(i);</span><br><span class="line">            if (t.children[c - &apos;a&apos;] == null) &#123;</span><br><span class="line">                t.children[c - &apos;a&apos;] = new TrieNode(c);</span><br><span class="line">            &#125;</span><br><span class="line">            t = t.children[c - &apos;a&apos;];</span><br><span class="line">        &#125;</span><br><span class="line">        t.isWord = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns if the word is in the trie.</span><br><span class="line">     */</span><br><span class="line">    public boolean search(String word) &#123;</span><br><span class="line">        TrieNode t = root;</span><br><span class="line">        for (int i = 0; i &lt; word.length(); i++) &#123;</span><br><span class="line">            char c = word.charAt(i);</span><br><span class="line">            if (t.children[c - &apos;a&apos;] == null) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            t = t.children[c - &apos;a&apos;];</span><br><span class="line">        &#125;</span><br><span class="line">        return t.isWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns if there is any word in the trie that starts with the given prefix.</span><br><span class="line">     */</span><br><span class="line">    public boolean startsWith(String prefix) &#123;</span><br><span class="line">        TrieNode t = root;</span><br><span class="line">        for (int i = 0; i&lt;prefix.length(); i++)&#123;</span><br><span class="line">            char c = prefix.charAt(i);</span><br><span class="line">            if (t.children[c - &apos;a&apos;] == null)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            t = t.children[c - &apos;a&apos;];</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Trie obj = new Trie();</span><br><span class="line">        obj.insert(&quot;trie&quot;);</span><br><span class="line">        boolean param_2 = obj.search(&quot;trie&quot;);</span><br><span class="line">        boolean param_3 = obj.startsWith(&quot;trie&quot;);</span><br><span class="line">        System.out.println(param_2);</span><br><span class="line">        System.out.println(param_3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Trie树/">Trie树</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode208/">leetcode208</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="blog-事务隔离：为什么你改了我看不见？" class="article article-type-blog" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/10/20/事务隔离：为什么你改了我看不见？/"
    >事务隔离：为什么你改了我看不见？</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2019/10/20/事务隔离：为什么你改了我看不见？/" class="article-date">
  <time datetime="2019-10-20T15:20:57.000Z" itemprop="datePublished">2019-10-20</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库/">数据库</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>这篇讲的是事务隔离，个人了解的还不够多，所以就把最基础的写上，后面的等搞懂了再重新更新下。<br>提到事务，你肯定不陌生，和数据库打交道的时候，我们总是会用到事务。最经典的例子就是转账，你要给朋友小王转 100 块钱，而此时你的银行卡只有 100 块钱。<br>转账过程具体到程序里会有一系列的操作，比如查询余额、做加减法、更新余额等，这些操作必须保证是一体的，不然等程序查完之后，还没做减法之前，你这 100 块钱，完全可以借着这个时间差再查一次，然后再给另外一个朋友转账，如果银行这么整，不就乱了么？这时就要用到“事务”这个概念了。<br>简单来说，事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在 MySQL 中，事务支持是在引擎层实现的。你现在知道，MySQL 是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如 MySQL 原生的 MyISAM 引擎就不支持事务，这也是 MyISAM 被 InnoDB 取代的重要原因之一。  </p>
<h3 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="headerlink" title="隔离性与隔离级别"></a>隔离性与隔离级别</h3><p>提到事务肯定会想到ACID（原子性，一致性，隔离性，持久性），这节主要讲的是隔离性。<br>当数据库有多个事务同时执行的时候，就可能会出现脏读，不可重复读，幻读的问题，为了解决这些问题，就有了“隔离级别”的概念。<br>在谈隔离级别之前，要了解的是隔离的越严实，效率就会越低，因此很多时候都要在二者之间寻找一个平衡点，SQL标准的隔离级别包括：读未提交，读已提交，可重复读，串行化。<br>读未提交是指，一个事务还没提交时，就能被其他的事务看见。<br>读已提交是指，一个事务提交后才能被其他的事务看见。<br>可重复读是指一个事务在执行过程中看到的数据总是和事务执行时看到的数据保持一致。<br>串行化，顾名思义对于同一行记录，“写”会加“写锁”，“读”会加“读锁”，当出现读写锁冲突的时候，后访问的事务必须等到前一个事务执行完成，才能继续执行。<br>下面举个例子来更好理解：  </p>
<p><img src="../image/%E4%BA%8B%E5%8A%A1.png" alt="事务.png" title="事务">  </p>
<p>来看一下，在不同隔离级别下，事务A会有哪些不同的返回结果，V1，V2，V3的返回值分别是什么。</p>
<p>若隔离级别是“读未提交”：V1就是2，事务B还没有提交就被A看到了，同样V2，V3也是2  </p>
<p>若隔离级别是“读已提交”：V1是1，V2，V3是2，事务B提交后A才能看见改变。  </p>
<p>若隔离级别是“可重复读”：V1，V2是1，V3是2，同一个事务才执行中和执行开始的值应该是一样的，V3在事务A提交后可以看到事务B的改变。  </p>
<p>若隔离级别是“串行化”：V1，V2是1，V3是2，当事务B执行“将1改为2的时候”会被锁住，直到事务A提交后才能改变。  </p>
<p>在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图实在事务启动时创建的，整个事务存在期间都用这个视图。在“读已提交”隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图的概念，而“串行化”隔离级别下直接用加锁的方式来避免并行访问。<br>我们可以看到在不同的隔离级别下，数据库行为是有所不同的。Oracle数据库的默认隔离级别其实就是“读提交”，因此对于一些从Oracle迁移到MySQL的应用，为保证数据库隔离级别的一致，你一定要记得将MySQL的隔离级别设置为“读提交”。  </p>
<p>配置的方式是，将启动参数transaction的值设置成READ-COMMITTED。你可以用show variables来查看当前的值。<br>总结来说，存在即合理，哪个隔离级别都有它自己的使用场景，你要根据自己的业务情况来定。那么什么时候需要“可重复读”的场景呢？我们来看一个校对逻辑的案例。<br>假设你在管理一个个人银行账户表。一个表存了每个月月底的余额，一个表存了账单明细。这时候你要做数据校对，也就是判断上个月的余额和当月余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。  </p>
<h3 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h3><p>理解了事务的隔离级别，我们再来看看事务隔离具体是怎么实现的。这里我们展开说明“可重复读”。  </p>
<p>在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。<br>假设一个值从1被按顺序改成了2，3，4，在回滚日志里面就会有类似下面的记录。  </p>
<p><img src="../image/%E5%9B%9E%E6%BB%9A%E6%AE%B5.png" alt="回滚段.png" title="回滚段">    </p>
<p>当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不用的read-view。如图中看到的，在视图A，B，C里面，这一个记录的值分别是1，2，4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）对于read-view，要得到1，就必须将当前值依次执行图中所有的回滚操作得到。<br>同时你会发现，即使现在有另外一个事务正在将4改成5，这个事务跟read-viewA，B，C对应的事务是不会冲突的。<br>你一定会问，回滚日志总不能一直保留吧，什么时候删除呢？答案是，在不需要的时候才删除，也就是说，系统会判断，当没有事务在需要用到这些回滚日志时，回滚日志会被删除。  </p>
<p>什么时候才不需要了呢？<br>就时当系统里没有比这个回滚日志更早的read-view的时候。<br>基于上面的说明，我们来讨论一下为什么建议你尽量不要使用长事务。<br>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。<br>在MySQL5.5及以前的版本，回滚日志时跟数据字典一起放在ibdata文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。我见过数只有20GB，而非回滚段有200GB的库，最终只好为了清理回滚段，重建整个库。<br>除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库，后面讲锁的时候还会展开说。 </p>
<h3 id="事务的启动方式"><a href="#事务的启动方式" class="headerlink" title="事务的启动方式"></a>事务的启动方式</h3><p>如前面所述，长事务有这些潜在风险，我当然是建议你尽量避免。其实很多时候业务开发同学并不是有意使用长事务，通常是由于误用所致。MySQL的事务启动方式有以下几种：<br>1.显示启动事务语句，begin活start transaction。配套的提交语句是commit，回滚语句是rollback，或者断开连接。<br>有些客户端连接框架会默认连接成功后先执行一个set autocommit = 0的命令。这就导致接下来的查询都在事务中，如果是长链接，就导致了意外的长事务。<br>因此，我会建议你总是使用set autocommit = 1，通过显式语句的方式来启动事务。   </p>
<p>ps：这里解释一下set autocommit = 1  autocommit指的是事务，如果set autocommit = 0那么所有的语句一定是在一个事务里。在这种情况下，如果使用连接池，并且在查询之前没有rollback或者set autocommit = 1，那么就悲剧了，因为根据mysql的默认事务级别，可重复读，永远也取不到这个事务被开户前的数据。另外一点set autocommit = 0，会自动提交前一个事务，因此正确的做法是rollback ，set autocommit = 0，完成之后在set autocommit<br> = 1  </p>
<p>但有的开发同学会纠结“多一次交互”的问题，对于一个需要频繁使用事务的业务，第二种方式每个事务在开始时都不需要主动执行一次“begin”，减少了语句的交互次数。如果你也有这个顾虑，我建议你commit work and chain语法。<br>在autocommit为1的情况下，用beigin显示启动的事务，如果执行commit则提交事务。如果执行commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行begin语句的开销，同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。  </p>
<p>你可以在information_schema库的innodb_trx这个表中查询长事务，比如下面这个语句，用于查找持续时间超过60s的事务。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from information_schema.innodb_trx where TIME_TO_SET(timediff(now(),trx_started)) &gt; 60</span><br></pre></td></tr></table></figure>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/事务/">事务</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据库/">数据库</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="blog-日志系统：一条SQL更新语句是如何执行的？" class="article article-type-blog" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/10/20/日志系统：一条SQL更新语句是如何执行的？/"
    >日志系统：一条SQL更新语句是如何执行的？</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2019/10/20/日志系统：一条SQL更新语句是如何执行的？/" class="article-date">
  <time datetime="2019-10-20T10:55:53.000Z" itemprop="datePublished">2019-10-20</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库/">数据库</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h3 id="MySQL实战45讲-第二讲"><a href="#MySQL实战45讲-第二讲" class="headerlink" title="MySQL实战45讲-第二讲"></a>MySQL实战45讲-第二讲</h3><p>上一节讲了一条查询语句是如何执行的，这节讲述的是一条更新语句的执行过程。<br>常听DBA的同事说，MySQL可以恢复到半个月内任意一秒的状态，那么是如何做到的呢？<br>还是以一条SQL语句开始<br><code>create table user(ID int primary key,c int)</code><br>如果要将ID = 2这一行的值加1，SQL语句会这么写：<br><code>update user set c = c + 1 where ID = 2</code><br>之前说的查询的链路，在执行更新语句的时候也会走一遍，因为对某张表的更新，需要先找到这张表。<br>与查询流程不一样的是，更新流程还涉及两个重要的日志模块redolog(重做日志)和binlog(归档日志)。接下来详细讨论下。 </p>
<h3 id="重要的日志模块：redo-log"><a href="#重要的日志模块：redo-log" class="headerlink" title="重要的日志模块：redo log"></a>重要的日志模块：redo log</h3><p>老师举了一个例子，是拿《孔乙己》里酒店掌柜有一个粉板，专门用来记录客人的赊帐记录。如果赊帐的人不多，那么他可以先讲顾客和账单记录在粉板上；但如果赊帐的人多了，就一定有一个专门记录赊帐的账本。<br>如果有人要赊帐或者还帐的话，掌柜有两种做法：<br>1⃣️：先讲顾客和账单记录在粉板上，等不忙的时候在去账本上更新一下。<br>2⃣️：有人来就拿出账本去找到顾客的记录来更新。<br>当店里生意红火的时候很明显的看出来是第一种方式更加的高效。<br>同样的MySQL里更新数据库的时候也会有同样的问题，如果每次更新操作都写入磁盘里，然后磁盘也要找到对应的那条记录，然后在更细，整个过程的IO成本，查询成本都很高，为了解决这个问题，MySQL的设计者，就用了类似酒店掌柜的粉板思路来提升更新效率。<br>而粉板和账本配合的过程中，就是MySQL说的WAL技术，WAL的全称是Write-Ahead Logging,简单解释就是先写日志，在写磁盘，也就是先写粉板，等不忙的时候在写磁盘。<br>具体来说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log(粉板)里，并更新内存，这个时候就算更新完成了，同时InnoDB引擎会在适当时候，讲这个操作更新到磁盘里，而这个更新往往是在系统比较空闲的时候做。<br>但如果某一天赊帐的人突然很多，粉板记录不下怎么办？这个时候掌柜只好停下手中的活儿，把粉板中的一部分赊帐记录更新到账本中，然后将这些记录从粉板上擦掉，为新账腾出空间。<br>与此类似，InnoDB的redo log大小是固定的，比如可以配置一组4个文件，每个文件的大小是1GB，所以这块粉板就可以存储4GB的操作，从头开始写，写到末尾就又从头开始写，如下面这个图一样  </p>
<p><img src="../image/redolog.png" alt="redolog.png" title="redolog">  </p>
<p>write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。checkpoint是当前要擦出的位置，也是往后推移并且循环的，擦出记录前要把记录更新到数据文件，<br>write pos和checkpoint之间的“粉板”上还空着的部分，可以用来记录新的操作，如果write pos追上checkpoint，表示“粉板”满了，这时候不能在执行新的更新，得停下来先擦掉一些记录，把checkpoint推进一下。<br>有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe。 </p>
<h3 id="什么是crash-safe？"><a href="#什么是crash-safe？" class="headerlink" title="什么是crash-safe？"></a>什么是crash-safe？</h3><p>crash-safe是MySQL5.6版本的新特性，要理解crash-safe这个概念，可以想想我们前面赊帐记录的例子。只要赊帐记录记在了粉板或者写在了账本上，之后即便掌柜忘记了，比如突然停业几天，恢复生意后依然可以通过账本和粉板上的数据明确赊帐账目。  </p>
<h3 id="crash-unsafe"><a href="#crash-unsafe" class="headerlink" title="crash-unsafe?"></a>crash-unsafe?</h3><p>在了解crash-safe前，先分析一下在MySQL5.6版本之前出现slave(从) crash-unsafe的原因。我们知道在一套主从结构体系中，slave包含两个线程：即IO thread和SQL thread。两个线程的执行进度（偏移量）都保存在文件中。<br><code>IO thread负责从master拉取binlog文件（下面会讲到）并保存到本地的relay-log文件中</code><br><code>SQL thread负责执行重复sql，执行relay-log记录的日志</code><br>IO thread的执行状态信息保存在master.info文件，SQL thread的执行状态信息保存在relay-log.info文件。salve运行正常的情况下，记录位点没有问题，但是每当系统发生crash，存储的偏移量可能是不准确的（需要注意的是这些文件被修改后不是同步写入磁盘的）。因为应用binlog和更新位点信息到文件不是原子操作，而是两个独立的步骤。比如SQL thread已经应用relay-log.01的4个事务<br><code>trx1(pos:10)</code><br><code>trx2(pos:20)</code><br><code>trx3(pos:30)</code><br><code>trx4(pos:40)</code><br>但是SQL thread更新位点（relay-log.01,30）到relay-log.info文件中，slave实例重启的时候sql thread会重复执行trx4。<br>看到这里我们大概了解了，发生crash-unsafe的主要原因是应用binlog和更新位点不是原子操作，所以MySQL的解决办法是将两个操作融合成一个事务，这样就保证了原子性。  </p>
<h3 id="重要的日志模块：binlog"><a href="#重要的日志模块：binlog" class="headerlink" title="重要的日志模块：binlog"></a>重要的日志模块：binlog</h3><p>前面说过，MySQL整体来看，其实就有两大部分，一部分是server层，它主要做的是MySQL功能层面的事情，还有一块是引擎层，负责存储相关的具体事宜，上面我们聊到的粉板redo log是InnoDB引擎层特有日志，而Server层也有自己的日志，称为binlog（归档日志).<br>为什么会有两份日志呢？<br>因为最开始MySQL中并没有InnoDB引擎，MySQL自带的是MyISAM，但是MyISAM没有crash-safe的能力，binlog日志只能用于归档，而InnoDB是另一个公司以插件形式引入MySQL中的，既然只靠binlog是没有crash-safe能力的，所以InnoDB使用另外一套日志系统-也就是redo log来实现crash-safe能力。<br>这两种日志有以下三点不同。<br>1.redo log是InnoDB引擎特有的，binlog是MySQL的Server层实现的，所有引擎层都可以使用。<br>2.redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如”给ID = 2这一行的c字段加1“<br>3.redo log是循环写的，空间固定会用完；binlog是可以追加写入的。”追加写“是指binlog文件写到一定大小后会切换到下一个，并不户覆盖以前的日志。<br>有了对这两个日志的概念性的理解，我们再来看执行器InnoDB引擎在执行这个简单的update语句时的内部流程。<br>(1).执行器先找引擎取ID = 2这一行，ID是主键，引擎直接用树搜索找到这一行，如果ID = 2这一行所在的数据页本来就在内存中，就直接返回给执行器，否则，需要先从磁盘读入内存，然后在返回。<br>(2).执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，在调用引擎接口写入这行新数据。<br>(3).引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里，此时redo log处于prepare状态，然后告知执行器执行完成了，随时可以提交事务。<br>(4).执行器生成这个操作的binlog，并把binlog写入磁盘。<br>(5).执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。<br>下面给出的是课程中给出的流程图，浅色框表示实在InnoDB内部执行的，深色框表示是在执行器中执行的。   </p>
<p><img src="../image/update%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="update执行流程.png" title="update执行流程">  </p>
<p>后面三步为什么把redo log拆成两个步骤：prepare和commit，这就是“两阶段提交“  </p>
<h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p>还记不记得开头的那个问题：怎样让数据库恢复到半个月内任意一秒的状态？<br>前面我们说过，binlog会记录所有的逻辑操作，并且是采用“追加写”的形式。如果你的DBA承诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月内的所有binlog，同时系统会定期做整库备份。这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备。<br>当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做：<br>首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库；<br>然后，从备份的时间点开始，将备份的binlog依次取出来，重放到中午误删表之前的那个时刻。<br>这样你的临时库就喝误删之前的线上库一样了，然后你可以把表数据从临时库取出来，按需恢复到线上库去。说完了这个问题，再回过头来说为什么一定要有”两阶段提交“ ，为什么必须有”两阶段提交“呢？这是为了让两份日志之间的逻辑一致，如果不用两阶段提交看看会发生什么？<br>不使用两阶段提交无非两种情况：<br>1.先写redo log后写binlog。假设在redo写完，binlog还没有写完的时候，MySQL进程异常重启，由于前面说过，redo log写完之后，系统及时崩溃，仍然能够把数据恢复回来，所以恢复这一行c的值是1。<br>但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句，因此，之后备份日志的时候，存起来的binlog里面就没有这条语句。然后你会发现，如果需要用这个binlog来恢复临时库的话，由于语句的binlog丢失，这个临时库就会少了一次更新，恢复出来的这一行c的值就是0，与原库的值不同。<br>2.先写binlog后写redo log。如果在binlog写完之后异常重启，由于redo log还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0，但是binlog里面记录了“把c从0改成1”这个日志，所以，在之后用binlog恢复临时库的时候就多了一个事务出来，恢复出来的这一行c的值就是1，与原库的值不同。<br>可以看到如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库状态不一致。<br>可能会有疑问，这个概率是不是很低，平时也没有什么动不动就需要恢复临时库的场景呀？<br>其实不是，不只是误操作后需要用这个过程来恢复数据，当你需要扩容的时候，也就是需要再多搭建一些备库来增加系统的读能力的时候，现在常见的做法也是用全量备份加上应用binlog来实现的，这个“不一致”就会导致你的线上出现主从数据库不一致的情况。<br>简单说，redo log和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。  </p>
<p>其实redo log记录的就是数据，而binlog有两种模式，statement格式的话是记sql语句，row格式会记录行的内容，记两条，更新前和更新后都有。  </p>
<h3 id="课后问题"><a href="#课后问题" class="headerlink" title="课后问题"></a>课后问题</h3><p>一天一备和一周一备的对比？<br>好处是“最长恢复时间”更短。<br>在一天一备的模式里，最坏情况下需要应用一天的binlog，比如，每天0点做一次全量备份，而要恢复出一个到昨天晚上23点的备份。<br>一周一备的最坏情况就要应用一周的binlog了。系统对应指标就是RTO了。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/bin-log/">bin log</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redo-log/">redo log</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据库/">数据库</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="blog-mysql一条sql查询语句是如何执行的" class="article article-type-blog" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/10/20/mysql一条sql查询语句是如何执行的/"
    >MySQL一条sql查询语句是如何执行的?</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2019/10/20/mysql一条sql查询语句是如何执行的/" class="article-date">
  <time datetime="2019-10-19T16:48:46.000Z" itemprop="datePublished">2019-10-20</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据库/">数据库</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>[2019-10-13，2019-10-20]周计划：</p>
<p>1⃣️三道leetcode中等难度算法题<br>2⃣️MySQL实战45讲-基础篇1，2，3讲<br>3⃣️周六，日总结，写博客</p>
<p>本周学习了极客时间的MySQL实战45讲一课，本篇做一个总结。<br>先看一个普通的查询语句  </p>
<p><code>select * from user where id = 1</code>  </p>
<p>这条语句的执行过程是什么样的呢？废话不多说先上图：<br><img src="../image/MySQL.png" alt="MySQL.png" title="MySQL"><br>大体来说MySQL可以分为server层和引擎层两部分，server层包括连接器，查询缓存，分析器，优化器，查询器等，覆盖MySQL的绝大多数核心服务功能，包括内置函数，存储过程，触发器，视图等都是在这一层实现的。<br>而引擎层则是负责数据的存储和提取，其架构模式是插件式的，比如InnoDB，MyISAM，Memory等多个存储引擎，现在最常用的是InnoDB，在MySQL5.5.5版本成为了默认引擎。接下来具体介绍一下每一个部分的作用：  </p>
<h3 id="1⃣️连接器："><a href="#1⃣️连接器：" class="headerlink" title="1⃣️连接器："></a>1⃣️连接器：</h3><p>如果要使用MySQL首先要做的事与MySQL建立连接，输入账户密码MySQL会到连接器中对该账号进行权限的验证，以后的所有操作都基于此时的权限，及时在这段时间管理员对你的账号修改了权限也不会影响到本次连接的其他操作。同时这里涉及到了长链接与短链接，大家知道与数据库的连接是比较消耗资源的，所以要尽可能的在一次连接做尽量多的事，不让资源浪费，这就是长链接，客户端如果太长时间没有操作，连接器会自动将它断开，这是wait_timeout控制的，默认是8个小时，当然可以根据自己的业务场景进行修改，综上所述更推荐使用长链接。  </p>
<h3 id="2⃣️查询缓存："><a href="#2⃣️查询缓存：" class="headerlink" title="2⃣️查询缓存："></a>2⃣️查询缓存：</h3><p>通过了连接器就可以到下一步，也就是查询缓存了，大多数情况下并不推荐使用查询缓存，为什么呢？<br>我们先来了解下查询缓存的工作原理，其实MySQL会把执行过的查询语句以key-value的形式储存起来，key是查询语句，value是结果，如果在查询缓存中可以找到匹配的key那么直接返回value，但有人说这不是很方便吗提高了查询速度，为什么不推荐使用呢？因为不仅仅存储这些语句和结果需要占用空间，还有个最关键的原因是当有任何对某张表的更新那么基于这张表的所有查询缓存全部清空，除非你是有一张静态表，很长时间不更新那么可以使用查询缓存。<br>使用方式？只需要设置参数query_cache_type（0—&gt;关闭，1—&gt;开始，2—&gt;只有在执行查询语句时，显示指定开始如下例子）</p>
<p><code>select SQL_CACHE * form user where id = 1</code>  </p>
<h3 id="3⃣️分析器："><a href="#3⃣️分析器：" class="headerlink" title="3⃣️分析器："></a>3⃣️分析器：</h3><p>如果没有命中查询缓存就要真正开始执行语句了，首先MySQL要知道你执行的是什么操作，分析器会先做词法分析，你输入的是一串字符串，MySQL会识别出关键词比如select，那么MySQL会知道这是一条查询语句，在把user识别为表名，当然也会有写错的时候，那么语法错误就是在这一层做的。</p>
<h3 id="4⃣️优化器："><a href="#4⃣️优化器：" class="headerlink" title="4⃣️优化器："></a>4⃣️优化器：</h3><p>通过了分析器证明sql语句写的没有问题，那么MySQL会根据你写的语句在内部做一个优化，是在有多个索引的时候进行比较，提到索引，可能大家都知道最左前缀原则，比如user表有联合索引 ‘A_B’ 当查询语句为下面这样时：  </p>
<p><code>select name from user where B = 10</code>  </p>
<p>这样写的话并不会命中索引是因为没有满足最左前缀原则，但如果我把语句改成：  </p>
<p><code>select name from user where B = 10 and A = 15</code><br>如果这样写msyql会通过分析器来去寻找索引，发现你的where条件里有A = 15那么MySQL会先执行A = 15这样就会命中索引。  </p>
<h3 id="5⃣️执行器："><a href="#5⃣️执行器：" class="headerlink" title="5⃣️执行器："></a>5⃣️执行器：</h3><p>终于通过重重关卡可以真正去执行语句了，执行的时候会先判断一下是否有这张表的权限（如果命中查询索引，那么会在返回结果是做权限验证），如果有权限就打开表继续执行，拿最开始语句举个例子：<br>(1)默认引擎是InnoDB，调用InnoDB引擎接口取user表的第一行，判断id是不是等于1，如果不是则跳过，如果是则将这行存在结果集中<br>(2)调用引擎接口“下一行”,重复(1)，直到user表的最后一行。<br>(3)执行器将上述遍历过程中所有满足条件的行组成记录集作为结果集返回给客户端。  </p>
<p>至此这个语句就执行完成了。</p>
<h3 id="1⃣️课后问题："><a href="#1⃣️课后问题：" class="headerlink" title="1⃣️课后问题："></a>1⃣️课后问题：</h3><p>比如执行 <code>select * form user where t = 10</code> 如果不存在t这一列，那么一定会报错，这个报错是在哪个阶段报出的？</p>
<p>答：在分析器，MySQL其实很大程度上受了oracle的影响。</p>
<h3 id="2⃣️看课后有同学问了一个问题：为什么对权限的检查不在优化器之前做呢？"><a href="#2⃣️看课后有同学问了一个问题：为什么对权限的检查不在优化器之前做呢？" class="headerlink" title="2⃣️看课后有同学问了一个问题：为什么对权限的检查不在优化器之前做呢？"></a>2⃣️看课后有同学问了一个问题：为什么对权限的检查不在优化器之前做呢？</h3><p>答：有些时候，SQL要操作的表不仅仅是字面上那些，比如有个触发器，得在执行器阶段(过程中)才能确定，优化器前是无能为力的。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql查询语句执行/">mysql查询语句执行</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据库/">数据库</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="blog-Java基础部分之String" class="article article-type-blog" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/09/27/Java基础部分之String/"
    >Java基础部分之String</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2019/09/27/Java基础部分之String/" class="article-date">
  <time datetime="2019-09-27T10:01:53.000Z" itemprop="datePublished">2019-09-27</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java基础/">Java基础</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>String被声明为final，因此它不可被继承。</p>
<p>在Java8中，String内部使用char数组存储数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final class String</span><br><span class="line">	implements java.io.serializable,Comparable,CharSequence &#123;</span><br><span class="line">	/** The value is used for character storage. */</span><br><span class="line">	private final char value[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Java9之后，String类的实现改用byte数组存储字符串，同时使用coder来标识使用了哪种编码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final class String</span><br><span class="line">	implements java.io.serializable,Comparable,CharSequence &#123;</span><br><span class="line">	/** The value is used for character storage. */</span><br><span class="line">	private final byte[] value;</span><br><span class="line">	</span><br><span class="line">	/** The identifier of the encoding used to encode the bytes in &#123;@code value&#125;. */</span><br><span class="line">	private final byte coder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>value数组被声明为final，这意味着value数组初始化之后就不能再引用其他数组，并且String内部没有改变value数组的方法，因此可以保证String不可变。</p>
<h3 id="不可变的好处"><a href="#不可变的好处" class="headerlink" title="不可变的好处"></a>不可变的好处</h3><h4 id="1-可以缓存hash值"><a href="#1-可以缓存hash值" class="headerlink" title="1.可以缓存hash值"></a>1.可以缓存hash值</h4><p>因为String的hash值经常被使用，例如String用做HashMap的key，不可变的特性可以使得hash值也不可变，因此只需要进行一次计算。</p>
<h4 id="2-String-Pool的需要"><a href="#2-String-Pool的需要" class="headerlink" title="2.String Pool的需要"></a>2.String Pool的需要</h4><p>如果一个String对象已经被创建过了，那么就会从String Pool中取得引用，只有String是不可变的，才可能使用Spring Pool</p>
<h4 id="3-安全性"><a href="#3-安全性" class="headerlink" title="3.安全性"></a>3.安全性</h4><p>String经常作为参数，String不可变性可以保证参数不可变，例如在作为网络连接参数的情况下如果String是可变的，那么在网络连接过程中，String被改变，改变String对象的那一方以为现在连接的是其他主机，而实际情况却不一定是。</p>
<h4 id="4-线程安全"><a href="#4-线程安全" class="headerlink" title="4.线程安全"></a>4.线程安全</h4><p>String不可变性天生具备线程安全，可以在多个线程中安全的使用。</p>
<h3 id="String，StringBuffer-and-StringBuilder"><a href="#String，StringBuffer-and-StringBuilder" class="headerlink" title="String，StringBuffer and StringBuilder"></a>String，StringBuffer and StringBuilder</h3><h4 id="1-可变性"><a href="#1-可变性" class="headerlink" title="1.可变性"></a>1.可变性</h4><p>String不可变<br>StringBuffer和StringBuilder可变</p>
<h4 id="2-线程安全"><a href="#2-线程安全" class="headerlink" title="2.线程安全"></a>2.线程安全</h4><p>String不可变，因此线程是安全的<br>StringBuilder不是线程安全的<br>StringBuffer是线程安全的，内部使用synchronized进行同步</p>
<h3 id="String-Pool"><a href="#String-Pool" class="headerlink" title="String Pool"></a>String Pool</h3><p>字符串常量池(String Pool)保存着所有字符串字面量，这些字面量在编译时期就确定。不仅如此，还可以使用String的intern()方法在运行过程中将字符串添加到String Pool中。</p>
<p>当一个字符串调用intern()方法时如果String Pool中已经存在一个字符串和改字符串值相等(使用equals()方法进行确定)，那么就会返回String Pool中字符串的引用，否则，就会在String Pool中添加一个新的字符串，并返回这个新字符串的引用。</p>
<p>下面示例中，s1和s2采用new String()的方式新建了两个不同字符串，而s3和s4是通过s1.intern()方法取得一个字符串的引用，intern()首先把s1引用的字符串放到String Pool中，然后返回这个字符串引用，因此s3和s4引用的是同一个字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 = new String(&quot;aaa&quot;);</span><br><span class="line">Stirng s2 = new String(&quot;aaa&quot;);</span><br><span class="line">System.out.println(s1 == s2); //false</span><br><span class="line">String s3 = s1.intern();</span><br><span class="line">Stirng s4 = s2.intern();</span><br><span class="line">System.out.println(s3 == s4); //true</span><br></pre></td></tr></table></figure>

<p>如果是采用”bbb”这种字面量的形式创建字符串，会自动地将字符串放入String Pool中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s5 = &quot;bbb&quot;;</span><br><span class="line">String s6 = &quot;bbb&quot;;</span><br><span class="line">System.out.println(s5 == s6); //true</span><br></pre></td></tr></table></figure>

<p>在Java7之前，String Pool被放在运行时常量池中，它属于永久代。而在Java7，String Pool被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致OutOfMemoryError错误。</p>
<h3 id="new-String-“abc”"><a href="#new-String-“abc”" class="headerlink" title="new String(“abc”)"></a>new String(“abc”)</h3><p>使用这种方式一共会创建两个字符串对象(前提是String Pool中还没有”abc”字符串对象)。</p>
<p>“abc”属于字符串字面量，因此编译时期会在String Pool中创建一个字符串对象，指向这个”abc”字符串字面量。</p>
<p>而使用new的方式会在堆中创建一个字符串对象。</p>
<p>创建一个测试类，其main方法中使用这种方式来创建字符串对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class NewStirngTest&#123;</span><br><span class="line">	public static void main(String[] args)&#123;</span><br><span class="line">		Stirng s = new String(&quot;abc&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是String构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完成复制value数组内容，而是都会指向同一个value数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public String(String original)&#123;</span><br><span class="line">	this.value = original.value;</span><br><span class="line">	this.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java基础/">Java基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/String/">String</a></li></ul>


    </footer>

  </div>

  

  
  
  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2015-2020
        Gavin
      </li>
      <li>
        
        Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV:<span id="busuanzi_value_page_pv"></span></i>
  <i>UV:<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="孙云龙的技术博客"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">目录</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/lazyload.min.js"></script>

<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
      startDelay: 0,
      typeSpeed: 200,
      loop: true,
      backSpeed: 100,
      showCursor: true
    });
  } catch (err) {
  }

</script>





<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>
<script src="/dist/main.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>




<script src="/js/busuanzi-2.3.pure.min.js"></script>


<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>


    
  </div>
</body>

</html>