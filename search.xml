<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BigDecimal比较大小</title>
    <url>/2019/09/16/BigDecimal%E6%AF%94%E8%BE%83%E5%A4%A7%E5%B0%8F/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBigDecimal</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BigDecimal b1 = BigDecimal.valueOf(<span class="number">0.00</span>);</span><br><span class="line">        BigDecimal b2 = <span class="keyword">new</span> BigDecimal(<span class="number">0.00</span>);</span><br><span class="line">        BigDecimal b3 = <span class="keyword">new</span> BigDecimal(<span class="string">"0.00"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(b1);</span><br><span class="line">        System.out.println(b2);</span><br><span class="line">        System.out.println(b3);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"--------------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"equals比较"</span>);</span><br><span class="line">        System.out.println(contrast1(b1,b2));</span><br><span class="line">        System.out.println(contrast1(b1,b3));</span><br><span class="line">        System.out.println(contrast1(b2,b3));</span><br><span class="line">        System.out.println(contrast1(b1,BigDecimal.ZERO));</span><br><span class="line">        System.out.println(contrast1(b2,BigDecimal.ZERO));</span><br><span class="line">        System.out.println(contrast1(b3,BigDecimal.ZERO));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"--------------"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"compareTo比较"</span>);</span><br><span class="line">        System.out.println(contrast2(b1,b2));</span><br><span class="line">        System.out.println(contrast2(b1,b3));</span><br><span class="line">        System.out.println(contrast2(b2,b3));</span><br><span class="line">        System.out.println(contrast2(b1,BigDecimal.ZERO));</span><br><span class="line">        System.out.println(contrast2(b2,BigDecimal.ZERO));</span><br><span class="line">        System.out.println(contrast2(b3,BigDecimal.ZERO));</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">contrast1</span><span class="params">(BigDecimal b1,BigDecimal b2)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> b1.equals(b2);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">contrast2</span><span class="params">(BigDecimal b1,BigDecimal b2)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> b1.compareTo(b2);</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p> 运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0.0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0.00</span></span><br><span class="line">--------------</span><br><span class="line">equals比较</span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line">--------------</span><br><span class="line">compareTo比较</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><img src="../image/equals.png" alt="equals.png" title="equals"><br>清楚的看到比较了小数位，小数位不同直接返回false<br>在看一下compareTo源码：<br><img src="../image/compareTo.png" alt="compareTo.png" title="compareTo"><br>可以看到比较逻辑是先判断小数位是否相同，相同则比较有效值，不同先比较正负，正负相同在比较数值大小<br>结论：在进行需要忽略小数位比较时需要用compareTo()，不忽略小数位比较时用equals()</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>BigDecimal</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础部分之数据类型</title>
    <url>/2019/09/23/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="一-数据类型"><a href="#一-数据类型" class="headerlink" title="一 数据类型"></a>一 数据类型</h3><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><p>byte/8</p>
<p>char/16</p>
<p>short/16</p>
<p>int/32</p>
<p>float/32</p>
<p>long/64</p>
<p>double/64</p>
<p>boolean/~</p>
<p>boolean只有两个值，ture，false可以使用1bit来存储，但是具体大小没有明确规定，JVM会在编译期将boolean类型的数据转换为int，使用1来表示true，0表示false，JVM支持boolean数组，但是是通过读写byte数组来实现的。</p>
<h4 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h4><p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer x = <span class="number">2</span>; <span class="comment">//装箱</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> y = x; <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure>

<h4 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h4><p>new Integer(123)与Integer.valueOf(123)的区别在于：</p>
<p>new Integer(123)每次都会新建一个对象</p>
<p>Integer.valueOf(123)会使用缓存池中的对象，多次调用会取得同一个对象的引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer x = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">Integer y = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">System.out.println(x == y); <span class="comment">//false</span></span><br><span class="line">Integer z = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">Integer k = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">System.out.println(z == k); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>valueOf()方法的实现比较简单，就是先判断是否在缓存池中，如果在的话就直接返回缓存池的内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i &gt;= IntegerCahe.low &amp;&amp; i &lt;= IntegerCahe.high)</span><br><span class="line">		<span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Java8中，Integer缓存池的大小默认为-128-127.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">	<span class="comment">//high value may be configured by property</span></span><br><span class="line">	<span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">	String integerCacheHighPropValue = </span><br><span class="line">		sum.misc.VM.getSaveProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">	<span class="keyword">if</span>(integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="keyword">int</span> i = parseInt(integerCacheHighPropValue)</span><br><span class="line">			i = Math.max(i,<span class="number">127</span>);</span><br><span class="line">			<span class="comment">//Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">			h = Math.min(i,Integer.MAX_VALUE - (-low) - <span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span>( NumberFormatException nfe)&#123;</span><br><span class="line">		<span class="comment">//If the property cannot be parsed into an int,ignore it.</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	high = h;</span><br><span class="line">	</span><br><span class="line">	cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> j = low;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k&lt;cache.length; k++)</span><br><span class="line">		cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line">	<span class="comment">// range [-128,127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">	<span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器会在自动装箱过程调用valueOf()方法，因此多个值相同且值在缓存池范围内的Integer实例使用自动装箱来创建，那么就会引用相同的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer m = <span class="number">123</span>;</span><br><span class="line">Integer n = <span class="number">123</span>;</span><br><span class="line">System.out.println(m == n); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>基本类型对应的缓冲池如下：</p>
<p>boolean values true and false</p>
<p>all byte values</p>
<p>short values between -128 and 127</p>
<p>int values between -128 and 127</p>
<p>char in the range \u0000 to \u007F</p>
<p>在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象。</p>
<p>在jdk1.8所有的数值类缓冲池中，Integer的缓冲池IntegerCache很特殊，这个缓冲池的下届是-128，上届默认是127，但是这个上届是可调的，在启动jvm的时候，通过-XX:AutoBoxCache=<size>来指定这个缓冲池的大小，该选项在JVM初始化的时候会设定一个名为java.lang.IntegerCache.high系统属性，然后IntegerCache初始化的时候就会读取该系统属性来决定上界。</size></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>Java基本类型</tag>
      </tags>
  </entry>
  <entry>
    <title>go big or go home</title>
    <url>/2020/03/16/go%20big%20or%20go%20home/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>单词/短语</th>
<th>中文</th>
<th>句子</th>
</tr>
</thead>
<tbody><tr>
<td>early birld</td>
<td>早起的鸟儿</td>
<td>Early birld gets the worm</td>
</tr>
<tr>
<td>happiness</td>
<td>开心幸福</td>
<td>I often share happiness and sorrows with my friends</td>
</tr>
<tr>
<td>jail</td>
<td>监狱</td>
<td>He may be jailed for killing</td>
</tr>
<tr>
<td>breaks the law</td>
<td>打破法律</td>
<td>He was jailed for breaking the law</td>
</tr>
<tr>
<td>chemical reaction</td>
<td>化学反应</td>
<td>When you smiling,you will experience a chemical reaction</td>
</tr>
<tr>
<td>produces good-feeling chemicals</td>
<td>同上</td>
<td>When you smiling,you produces good-feeling chemicals</td>
</tr>
<tr>
<td>fake simle</td>
<td>假笑</td>
<td>I may be fake simle when I together with my boss</td>
</tr>
<tr>
<td>relax</td>
<td>放松</td>
<td>I want to keep relaxing in holiday</td>
</tr>
<tr>
<td>look younger</td>
<td>看起来年轻</td>
<td>You look younger than your age</td>
</tr>
<tr>
<td>sick</td>
<td>生病</td>
<td>The little girl may be sick</td>
</tr>
<tr>
<td>pressure</td>
<td>压力</td>
<td>Post-90s pressure</td>
</tr>
<tr>
<td>mortgage</td>
<td>房贷</td>
<td>He feel pressure beacuse of the mortgage</td>
</tr>
<tr>
<td>get sick</td>
<td>生病</td>
<td>I don’t want to get sick</td>
</tr>
<tr>
<td>vocabulary</td>
<td>词汇</td>
<td>Chinese vocabulary</td>
</tr>
<tr>
<td>busy with</td>
<td>忙于工作</td>
<td>I’m too busy with my work</td>
</tr>
<tr>
<td>crying</td>
<td>哭</td>
<td>The little girl is crying</td>
</tr>
<tr>
<td>get lost</td>
<td>走丢</td>
<td>She got lost</td>
</tr>
<tr>
<td>toothache</td>
<td>牙痛</td>
<td>Doctor,I have a toothache</td>
</tr>
<tr>
<td>glass</td>
<td>杯子</td>
<td>The glass is broken</td>
</tr>
<tr>
<td>stomachache</td>
<td>胃痛</td>
<td>The boy has a stomachache</td>
</tr>
<tr>
<td>live</td>
<td>注意读音[lɪv , laɪv]</td>
<td>I live in Beijing；live Spring gala</td>
</tr>
<tr>
<td>farther</td>
<td>更远</td>
<td>The higher you climb,The farther you can see</td>
</tr>
<tr>
<td>suffer</td>
<td>伤害</td>
<td>The longer the war lasts,the more the people there will suffer</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>单词</tag>
      </tags>
  </entry>
  <entry>
    <title>一路走来，即将毕业。</title>
    <url>/2019/09/12/Sentiment/</url>
    <content><![CDATA[<p>第一次写博客是大三上学期，现在是大四下学期，虽然也就一年半的时间，从最初的懵懂无知，以一个小白的身份出去找实习，就因为厌倦了学校的生活，每每看见室友在玩儿游戏总感觉和他们格格不入，但我当时也并没有很努力的去学习，只是在迷惑自己，觉得自己学习了但其实什么都没学，当时就连ssh框架整合都搞不定，后来去找实习，有幸进入了用友金融，虽然是一家技术比较老的公司，但是对我的启蒙来说还是很好了，后来又去了京东，不得不说在京东的时间对我的技术帮助是最大的，不仅独立完成功能开发，虽然大部分也都是增删改查，只不过做了数据展示上的不同，比如导出excel，合并单元格，这些基础的东西能写好已经很不错了，而且还在部门分享自己学到的东西，这都是对我的锻炼，虽然那段日子自己一个人住在小屋子里，而且要早起赶班车，晚上还加班，不过真的很有意义，后来又很可惜没留下来，hc锁了，之后参加了饿了么校招也算半个阿里的人了，到现在一切终于尘埃落定了，就是想到什么写什么，过年在家里休息了两个月，现在重新来实习，我觉得我的技术水平确实增长了，有些问题真的能自己解决了，现在也不再是停留在只会用的层面了，也很想要知道原理，但是看源码还是有点吃力，我的学习路线呢大概是</p>
<p>java基础—-&gt;mysql—-&gt;jdbc/servlet—&gt;hibernate—&gt;spring mvc—&gt;spring—&gt;spring boot—&gt;PortgreSQL—&gt;kafka</p>
<p>这些是按时间线来说的，当然python，c，c++，js也是会一点点都是在学校学的，真的是从小小白到小白到白</p>
<p>现在马上大学生活就结束了，总结一下大学四年，有过开心，有过迷茫，有过无助，有过离别，有过失恋，有过失落，有过自信，有了成熟。</p>
<p>每一个形容词都是一个故事，这些故事组成了我的大学四年，也陪伴了我大学四年，想想一路走来，一切真的真的都是最好的安排，要每一天热爱生活，要热爱工作，要为自己的梦想打好基础，要学会处理好人际关系，我现在很幸福，家里和睦，生活愉快，我为自己自豪，唯一的遗憾就是大一大二没有把基础打好，但有些许的遗憾才是人生。</p>
<p>面对未来我一点都不迷茫，我有自己的目标，我和谁都说我要创业，未来的我还要去读MBA，要干的事还很多，我觉得我能改变世界，我相信我以后也会作出可以改变世界的产品，就算创业失败了我也去尝试了，年轻人就要去试一下，无论成功失败，不然老了会后悔的，未来的世界是我们的。</p>
<p>也许很多人说不了解社会的险恶，早晚会被磨平棱角，那只要做到心不是社会的形状就好了。</p>
<p>祝我自己前途似锦，万事胜意。</p>
<p>2019-03-27 20:44更</p>
]]></content>
      <categories>
        <category>个人经历</category>
      </categories>
      <tags>
        <tag>个人经历</tag>
        <tag>毕业感悟</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础部分之String</title>
    <url>/2019/09/27/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%E4%B9%8BString/</url>
    <content><![CDATA[<h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>String被声明为final，因此它不可被继承。</p>
<p>在Java8中，String内部使用char数组存储数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">	<span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">serializable</span>,<span class="title">Comparable</span>,<span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">	<span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Java9之后，String类的实现改用byte数组存储字符串，同时使用coder来标识使用了哪种编码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">	<span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">serializable</span>,<span class="title">Comparable</span>,<span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">	<span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/** The identifier of the encoding used to encode the bytes in &#123;<span class="doctag">@code</span> value&#125;. */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span> coder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>value数组被声明为final，这意味着value数组初始化之后就不能再引用其他数组，并且String内部没有改变value数组的方法，因此可以保证String不可变。</p>
<h3 id="不可变的好处"><a href="#不可变的好处" class="headerlink" title="不可变的好处"></a>不可变的好处</h3><h4 id="1-可以缓存hash值"><a href="#1-可以缓存hash值" class="headerlink" title="1.可以缓存hash值"></a>1.可以缓存hash值</h4><p>因为String的hash值经常被使用，例如String用做HashMap的key，不可变的特性可以使得hash值也不可变，因此只需要进行一次计算。</p>
<h4 id="2-String-Pool的需要"><a href="#2-String-Pool的需要" class="headerlink" title="2.String Pool的需要"></a>2.String Pool的需要</h4><p>如果一个String对象已经被创建过了，那么就会从String Pool中取得引用，只有String是不可变的，才可能使用Spring Pool</p>
<h4 id="3-安全性"><a href="#3-安全性" class="headerlink" title="3.安全性"></a>3.安全性</h4><p>String经常作为参数，String不可变性可以保证参数不可变，例如在作为网络连接参数的情况下如果String是可变的，那么在网络连接过程中，String被改变，改变String对象的那一方以为现在连接的是其他主机，而实际情况却不一定是。</p>
<h4 id="4-线程安全"><a href="#4-线程安全" class="headerlink" title="4.线程安全"></a>4.线程安全</h4><p>String不可变性天生具备线程安全，可以在多个线程中安全的使用。</p>
<h3 id="String，StringBuffer-and-StringBuilder"><a href="#String，StringBuffer-and-StringBuilder" class="headerlink" title="String，StringBuffer and StringBuilder"></a>String，StringBuffer and StringBuilder</h3><h4 id="1-可变性"><a href="#1-可变性" class="headerlink" title="1.可变性"></a>1.可变性</h4><p>String不可变<br>StringBuffer和StringBuilder可变</p>
<h4 id="2-线程安全"><a href="#2-线程安全" class="headerlink" title="2.线程安全"></a>2.线程安全</h4><p>String不可变，因此线程是安全的<br>StringBuilder不是线程安全的<br>StringBuffer是线程安全的，内部使用synchronized进行同步</p>
<h3 id="String-Pool"><a href="#String-Pool" class="headerlink" title="String Pool"></a>String Pool</h3><p>字符串常量池(String Pool)保存着所有字符串字面量，这些字面量在编译时期就确定。不仅如此，还可以使用String的intern()方法在运行过程中将字符串添加到String Pool中。</p>
<p>当一个字符串调用intern()方法时如果String Pool中已经存在一个字符串和改字符串值相等(使用equals()方法进行确定)，那么就会返回String Pool中字符串的引用，否则，就会在String Pool中添加一个新的字符串，并返回这个新字符串的引用。</p>
<p>下面示例中，s1和s2采用new String()的方式新建了两个不同字符串，而s3和s4是通过s1.intern()方法取得一个字符串的引用，intern()首先把s1引用的字符串放到String Pool中，然后返回这个字符串引用，因此s3和s4引用的是同一个字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">Stirng s2 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">System.out.println(s1 == s2); <span class="comment">//false</span></span><br><span class="line">String s3 = s1.intern();</span><br><span class="line">Stirng s4 = s2.intern();</span><br><span class="line">System.out.println(s3 == s4); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>如果是采用”bbb”这种字面量的形式创建字符串，会自动地将字符串放入String Pool中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s5 = <span class="string">"bbb"</span>;</span><br><span class="line">String s6 = <span class="string">"bbb"</span>;</span><br><span class="line">System.out.println(s5 == s6); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>在Java7之前，String Pool被放在运行时常量池中，它属于永久代。而在Java7，String Pool被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致OutOfMemoryError错误。</p>
<h3 id="new-String-“abc”"><a href="#new-String-“abc”" class="headerlink" title="new String(“abc”)"></a>new String(“abc”)</h3><p>使用这种方式一共会创建两个字符串对象(前提是String Pool中还没有”abc”字符串对象)。</p>
<p>“abc”属于字符串字面量，因此编译时期会在String Pool中创建一个字符串对象，指向这个”abc”字符串字面量。</p>
<p>而使用new的方式会在堆中创建一个字符串对象。</p>
<p>创建一个测试类，其main方法中使用这种方式来创建字符串对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewStirngTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Stirng s = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是String构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完成复制value数组内容，而是都会指向同一个value数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.value = original.value;</span><br><span class="line">	<span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>go big or go home-10</title>
    <url>/2020/03/25/go-big-or-go-home-10/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>单词/短语</th>
<th>中文</th>
<th>句子</th>
</tr>
</thead>
<tbody><tr>
<td>degree Celsius</td>
<td>摄氏度</td>
<td>It’s about 20 degrees Celsius</td>
</tr>
<tr>
<td>rely</td>
<td>依赖</td>
<td>Babies rely on their parents for food and care</td>
</tr>
<tr>
<td>conductor</td>
<td>指挥</td>
<td>The conductor is the leader of the band</td>
</tr>
<tr>
<td>well-known</td>
<td>有名的</td>
<td>This is a well-known painting</td>
</tr>
<tr>
<td>rescue</td>
<td>拯救</td>
<td>The firemen rescued the little boy from the fire</td>
</tr>
<tr>
<td>blank</td>
<td>空白的</td>
<td>You can write something on this blank notebook</td>
</tr>
<tr>
<td>fee</td>
<td>费用</td>
<td>He was shocked by the huge amount of hidden fees behind such a haircut</td>
</tr>
<tr>
<td>autonomous</td>
<td>自动驾驶</td>
<td>The man is relaxing-reading a book in his autonomous car</td>
</tr>
<tr>
<td>measurement</td>
<td>测量</td>
<td>the measurement in degrees of how hot or cold a thing or place is</td>
</tr>
<tr>
<td>clear my mind</td>
<td>理清我的思路</td>
<td>clear my mind</td>
</tr>
<tr>
<td>forecast</td>
<td>预告</td>
<td>a prediction of the weather for the future</td>
</tr>
<tr>
<td>weatherman</td>
<td>天气预报员</td>
<td>My sister is a weatherman</td>
</tr>
<tr>
<td>a drop of</td>
<td>一滴/一缕</td>
<td>a drop of golden sunshine</td>
</tr>
<tr>
<td>freezing</td>
<td>冰冻的</td>
<td>It is freezing here,please bring enough warm clothes when you come</td>
</tr>
<tr>
<td>Indeed,couldn’t be better</td>
<td>确实是这样，不能再好了</td>
<td>Indeed,couldn’t be better</td>
</tr>
<tr>
<td>minus</td>
<td>下降</td>
<td>Even can be minus 20 degrees Celsius</td>
</tr>
<tr>
<td>dry</td>
<td>干燥的</td>
<td>Beijing is dry and windy in winter</td>
</tr>
<tr>
<td>windy</td>
<td>多风的</td>
<td>Beijing is dry and windy in winter</td>
</tr>
<tr>
<td>heavy</td>
<td>表示程度</td>
<td>There is a heavy rain outside</td>
</tr>
<tr>
<td>storm</td>
<td>暴风雨</td>
<td>Look at the heavy cloud,I think the storm is coming</td>
</tr>
<tr>
<td>cloud</td>
<td>云</td>
<td>Look at the heavy cloud,I think the strom is coming</td>
</tr>
<tr>
<td>I’m afraid so</td>
<td>恐怕是的</td>
<td>I’m afraid so ,the weatherman said there would be a heavy rain tonight</td>
</tr>
<tr>
<td>hail</td>
<td>下冰雹</td>
<td>heavy hail</td>
</tr>
<tr>
<td>blizzard</td>
<td>暴风雪</td>
<td>blizzard</td>
</tr>
<tr>
<td>miserable</td>
<td>悲惨的</td>
<td>It’s miserable out</td>
</tr>
<tr>
<td>calling for</td>
<td>呼吁</td>
<td>They are calling for blue skies all week</td>
</tr>
<tr>
<td>smoking hot</td>
<td>火辣</td>
<td>The gril is smoking hot</td>
</tr>
<tr>
<td>frequently</td>
<td>经常，频繁</td>
<td>I go to BeiJing frequently</td>
</tr>
<tr>
<td>developed</td>
<td>发达</td>
<td>My hometown is not developed</td>
</tr>
<tr>
<td>优雅句子</td>
<td>当你独自穿过了暴风雨,你就不再是原来那个人了</td>
<td>Once you walk through the storm alone,You are no longer the same person as before</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>单词</tag>
      </tags>
  </entry>
  <entry>
    <title>go big or go home-11</title>
    <url>/2020/03/26/go-big-or-go-home-11/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>单词/短语</th>
<th>中文</th>
<th>句子</th>
</tr>
</thead>
<tbody><tr>
<td>broad</td>
<td>宽的</td>
<td>This road is broad enough for many cars to drive on</td>
</tr>
<tr>
<td>accomplish</td>
<td>完成</td>
<td>She is so happy to have accomplished her weight-loss goal</td>
</tr>
<tr>
<td>case</td>
<td>箱子</td>
<td>He carried all of his important things in a black case</td>
</tr>
<tr>
<td>normal</td>
<td>正常的</td>
<td>A normal human foot should be like the one in the middle</td>
</tr>
<tr>
<td>organ</td>
<td>器官</td>
<td>Every organ plays an important role in our body</td>
</tr>
<tr>
<td>ceremony</td>
<td>典礼</td>
<td>The student was awarded her certificate during the graduation ceremony</td>
</tr>
<tr>
<td>miserable</td>
<td>悲惨的</td>
<td>It’s miserable out</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>单词</tag>
      </tags>
  </entry>
  <entry>
    <title>go big or go home-12</title>
    <url>/2020/03/27/go-big-or-go-home-12/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>单词/短语</th>
<th>中文</th>
<th>句子</th>
</tr>
</thead>
<tbody><tr>
<td>draft</td>
<td>草稿</td>
<td>This is just the draft design of a building</td>
</tr>
<tr>
<td>side</td>
<td>边</td>
<td>There are many trees on both sides of the river</td>
</tr>
<tr>
<td>patience</td>
<td>耐心</td>
<td>Fishing demands a great deal of patience</td>
</tr>
<tr>
<td>candidate</td>
<td>候选人</td>
<td>The candidates are persenting the speeches fot the election</td>
</tr>
<tr>
<td>disturb</td>
<td>打扰</td>
<td>His snoring really disturbs me at night</td>
</tr>
<tr>
<td>handle</td>
<td>把手</td>
<td>Turn the handle to open the door</td>
</tr>
<tr>
<td>merchant</td>
<td>商人</td>
<td>The merchant checks the quality of his produce</td>
</tr>
<tr>
<td>construct</td>
<td>建造</td>
<td>The workers are constructing a tall  building</td>
</tr>
<tr>
<td>edition</td>
<td>版本</td>
<td>The dictionary is now in its third edition which was published in 2017</td>
</tr>
<tr>
<td>fax</td>
<td>传真</td>
<td>You can contact us by email or fax</td>
</tr>
<tr>
<td>maintain</td>
<td>保持</td>
<td>How do you maintain relationships with your long-distance friends?</td>
</tr>
<tr>
<td>instant message</td>
<td>即使消息</td>
<td>Also emails can realize instant messaging</td>
</tr>
<tr>
<td>pal</td>
<td>伙伴</td>
<td>Eamiling the pals is a great and helpful way to stay in touch with each other</td>
</tr>
<tr>
<td>circumstances</td>
<td>情况</td>
<td>What circumstances you would choose to send emails to keep in touch?</td>
</tr>
<tr>
<td>goes off/rings</td>
<td>响了</td>
<td>My alarm goes off at 9:30 in the morning</td>
</tr>
<tr>
<td>get out of</td>
<td>形容完全离开床了</td>
<td>Then I get out of the bed</td>
</tr>
<tr>
<td>get up</td>
<td>起床/起来</td>
<td>I’ve fallen and I can’t get up</td>
</tr>
<tr>
<td>wake up</td>
<td>醒来</td>
<td>wake up early</td>
</tr>
<tr>
<td>go downstairs</td>
<td>下楼</td>
<td>go downstairs</td>
</tr>
<tr>
<td>go upstairs</td>
<td>上楼</td>
<td>go upstairs</td>
</tr>
<tr>
<td>go to the bathroom/toilet/restroom</td>
<td>去厕所(美)/(英)</td>
<td>go to the bathroom/toilet/restroom</td>
</tr>
<tr>
<td>How would you like your egg?</td>
<td>你想要什么样的鸡蛋？</td>
<td>早餐回答</td>
</tr>
<tr>
<td>sunny side up</td>
<td>太阳蛋</td>
<td>回答上文</td>
</tr>
<tr>
<td>over easy</td>
<td>煎鸡蛋程度很轻</td>
<td>回答上文</td>
</tr>
<tr>
<td>over medium</td>
<td>一面熟</td>
<td>回答上文</td>
</tr>
<tr>
<td>over hard</td>
<td>两面熟</td>
<td>回答上文</td>
</tr>
<tr>
<td>scrambled egg</td>
<td>炒鸡蛋</td>
<td>scrambled egg</td>
</tr>
<tr>
<td>hard boiled egg</td>
<td>煮鸡蛋</td>
<td>hard boiled egg</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>单词</tag>
      </tags>
  </entry>
  <entry>
    <title>go big or go home-13</title>
    <url>/2020/03/29/go-big-or-go-home-13/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>单词/短语</th>
<th>中文</th>
<th>句子</th>
</tr>
</thead>
<tbody><tr>
<td>dismiss</td>
<td>开除</td>
<td>The boss was anrgy and dismissed the staff</td>
</tr>
<tr>
<td>protection</td>
<td>保护</td>
<td>Everyone should get involved in enviromental protection</td>
</tr>
<tr>
<td>feed</td>
<td>喂养</td>
<td>My mother would feed me when I was hungry</td>
</tr>
<tr>
<td>ought to</td>
<td>应该</td>
<td>When you study，you ought to sit up straight</td>
</tr>
<tr>
<td>rapid</td>
<td>迅速的</td>
<td>The rabbit ran at a rapid speed</td>
</tr>
<tr>
<td>cure</td>
<td>治愈</td>
<td>These pills will cure your sickness</td>
</tr>
<tr>
<td>outer</td>
<td>外面的</td>
<td>The outer part of this ball is green</td>
</tr>
<tr>
<td>dinosaur</td>
<td>恐龙</td>
<td>Two dinosaurs are fighting against each other</td>
</tr>
<tr>
<td>spicy</td>
<td>辣的</td>
<td>I like spicy hot pot</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>单词</tag>
      </tags>
  </entry>
  <entry>
    <title>go big or go home-14</title>
    <url>/2020/03/29/go-big-or-go-home-14/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>单词/短语</th>
<th>中文</th>
<th>句子</th>
</tr>
</thead>
<tbody><tr>
<td>humor</td>
<td>幽默</td>
<td>The performance that he was forced to eat corn showed his unique sense of humor</td>
</tr>
<tr>
<td>ridiculous</td>
<td>可笑的</td>
<td>She looks ridiculous wearing this dress when walking in the street</td>
</tr>
<tr>
<td>go ahead</td>
<td>继续干下去</td>
<td>The boy still went ahead with the race even after falling</td>
</tr>
<tr>
<td>rare</td>
<td>半熟的</td>
<td>He likes eating rare steak,which is bloody and red in the middle</td>
</tr>
<tr>
<td>fluency</td>
<td>流畅</td>
<td>He speaks with perfect fluency</td>
</tr>
<tr>
<td>yawn</td>
<td>打哈欠</td>
<td>The cat yawned lying on the grass.So cute</td>
</tr>
<tr>
<td>boycott</td>
<td>抵制</td>
<td>The office workers are putting up a boycott</td>
</tr>
<tr>
<td>certificate</td>
<td>证书</td>
<td>I got my graduation certificate after finishing college</td>
</tr>
<tr>
<td>hug</td>
<td>拥抱</td>
<td>The happy couple hug in front of their new home</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>单词</tag>
      </tags>
  </entry>
  <entry>
    <title>go big or go home-15</title>
    <url>/2020/03/30/go-big-or-go-home-15/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>单词/短语</th>
<th>中文</th>
<th>句子</th>
</tr>
</thead>
<tbody><tr>
<td>development</td>
<td>发展</td>
<td>This picture shows the development of phones over time</td>
</tr>
<tr>
<td>work out</td>
<td>计算出</td>
<td>He worked out the math problem on the blackboard</td>
</tr>
<tr>
<td>take the place of</td>
<td>取代</td>
<td>Gradually,robots have taken the place of manual workers</td>
</tr>
<tr>
<td>pardon</td>
<td>原谅</td>
<td>The king pardoned the prisoner</td>
</tr>
<tr>
<td>strap</td>
<td>绑住</td>
<td>The man is driving a jeep with luggage strapped to the roof</td>
</tr>
<tr>
<td>fur</td>
<td>毛皮</td>
<td>A fur coat is very warm,bur very expensive</td>
</tr>
<tr>
<td>yet</td>
<td>尚/还</td>
<td>I’m tired,but I haven’t finished studying yet</td>
</tr>
<tr>
<td>jet</td>
<td>喷气式</td>
<td>Nowadays most long-distance travel is by jet plane</td>
</tr>
<tr>
<td>bacterium</td>
<td>细菌</td>
<td>This kind of bacterium can cause a very dangerous disease</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>单词</tag>
      </tags>
  </entry>
  <entry>
    <title>go big or go home-16</title>
    <url>/2020/03/31/go-big-or-go-home-16/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>单词/短语</th>
<th>中文</th>
<th>句子</th>
</tr>
</thead>
<tbody><tr>
<td>shoulder</td>
<td>肩膀</td>
<td>The old man has pain in his shoulder</td>
</tr>
<tr>
<td>polite</td>
<td>有礼貌的</td>
<td>The student is very polite to his teacher</td>
</tr>
<tr>
<td>thin/skinny</td>
<td>瘦的</td>
<td>Five year ago,I was much thinner</td>
</tr>
<tr>
<td>back</td>
<td>背痛</td>
<td>My back hurts</td>
</tr>
<tr>
<td>religious</td>
<td>虔诚的</td>
<td>He is a religious believer,he goes to church every week</td>
</tr>
<tr>
<td>pupli</td>
<td>小学生</td>
<td>The pupils are walking to school</td>
</tr>
<tr>
<td>file</td>
<td>文件</td>
<td>She put those files on the desk</td>
</tr>
<tr>
<td>outcome</td>
<td>最终，结果</td>
<td>The final outcome of the football game is 0 : 0</td>
</tr>
<tr>
<td>beans</td>
<td>豆类</td>
<td>-</td>
</tr>
<tr>
<td>black beans</td>
<td>黑豆</td>
<td>-</td>
</tr>
<tr>
<td>soy beans</td>
<td>黄豆</td>
<td>-</td>
</tr>
<tr>
<td>soy sause</td>
<td>酱油</td>
<td>-</td>
</tr>
<tr>
<td>soy milk</td>
<td>豆奶</td>
<td>-</td>
</tr>
<tr>
<td>milkshake</td>
<td>奶昔</td>
<td>-</td>
</tr>
<tr>
<td>black tea</td>
<td>红茶</td>
<td>-</td>
</tr>
<tr>
<td>vegetarian</td>
<td>素食主义者，乳制品还是吃的</td>
<td>-</td>
</tr>
<tr>
<td>vegan</td>
<td>比较苛刻的素食主义者，只吃蔬菜</td>
<td>-</td>
</tr>
<tr>
<td>chubby</td>
<td>胖乎乎的</td>
<td>Do you think I’m too chubby</td>
</tr>
<tr>
<td>diet</td>
<td>节食</td>
<td>diet coke</td>
</tr>
<tr>
<td>grapes</td>
<td>葡萄</td>
<td>some grapes</td>
</tr>
<tr>
<td>snacks</td>
<td>零食</td>
<td>-</td>
</tr>
<tr>
<td>little treats</td>
<td>零食</td>
<td>-</td>
</tr>
<tr>
<td>coworker</td>
<td>同事</td>
<td>-</td>
</tr>
<tr>
<td>coworking place</td>
<td>共享办公室</td>
<td>-</td>
</tr>
<tr>
<td>shrimp</td>
<td>虾/虾肉</td>
<td>-</td>
</tr>
<tr>
<td>pork</td>
<td>猪肉</td>
<td>-</td>
</tr>
<tr>
<td>protein</td>
<td>蛋白质</td>
<td>-</td>
</tr>
<tr>
<td>protein powder</td>
<td>蛋白粉</td>
<td>-</td>
</tr>
<tr>
<td>steak</td>
<td>牛排</td>
<td>-</td>
</tr>
<tr>
<td>rare</td>
<td>一分熟两分熟</td>
<td>-</td>
</tr>
<tr>
<td>medium rare</td>
<td>半熟的</td>
<td>-</td>
</tr>
<tr>
<td>medium</td>
<td>四分熟</td>
<td>-</td>
</tr>
<tr>
<td>medium well</td>
<td>七分熟</td>
<td>-</td>
</tr>
<tr>
<td>well done</td>
<td>全熟</td>
<td>-</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>单词</tag>
      </tags>
  </entry>
  <entry>
    <title>go big or go home-17</title>
    <url>/2020/04/01/go-big-or-go-home-17/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>单词/短语</th>
<th>中文</th>
<th>句子</th>
</tr>
</thead>
<tbody><tr>
<td>shoulder</td>
<td>肩膀</td>
<td>The old man has pain in his shoulder</td>
</tr>
<tr>
<td>file</td>
<td>文件</td>
<td>She put those files on the desk</td>
</tr>
<tr>
<td>snacks</td>
<td>零食</td>
<td>-</td>
</tr>
<tr>
<td>unite</td>
<td>团结</td>
<td>We will unite with each other to finish the task</td>
</tr>
<tr>
<td>cleaner</td>
<td>清洁工</td>
<td>The cleaner needs different tools to do her job</td>
</tr>
<tr>
<td>seminar</td>
<td>研讨会</td>
<td>A teacher and some students are attending a math seminar</td>
</tr>
<tr>
<td>sour</td>
<td>酸的</td>
<td>The lemon has such a sour taste</td>
</tr>
<tr>
<td>branch</td>
<td>分支</td>
<td>A bird is resting on the tree branch</td>
</tr>
<tr>
<td>salute</td>
<td>敬礼</td>
<td>The policeman salutes me as I walk by</td>
</tr>
<tr>
<td>material</td>
<td>材料</td>
<td>Many different materials are needed for construction work</td>
</tr>
<tr>
<td>pine</td>
<td>松树</td>
<td>The pine tree on HuangShan is very famous</td>
</tr>
<tr>
<td>laptop</td>
<td>笔记本</td>
<td>The girl has given up doing her homework on the laptop</td>
</tr>
<tr>
<td>beach</td>
<td>海边</td>
<td>The girl took a vacation on the beach</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>单词</tag>
      </tags>
  </entry>
  <entry>
    <title>go big or go home-2</title>
    <url>/2020/03/17/go-big-or-go-home-2/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>单词/短语</th>
<th>中文</th>
<th>句子</th>
</tr>
</thead>
<tbody><tr>
<td>stadium</td>
<td>体育场</td>
<td>I often play football in the stadium</td>
</tr>
<tr>
<td>reply</td>
<td>回复</td>
<td>I’m waiting for your reply</td>
</tr>
<tr>
<td>standard</td>
<td>标准</td>
<td>Such a standard figure</td>
</tr>
<tr>
<td>honour</td>
<td>荣誉</td>
<td>It’s an honour to graduate from this school</td>
</tr>
<tr>
<td>village</td>
<td>乡村</td>
<td>I like village life</td>
</tr>
<tr>
<td>ever since</td>
<td>自从…时起</td>
<td>They lived there ever since they married</td>
</tr>
<tr>
<td>turn up</td>
<td>调高</td>
<td>Turn up the TV volume</td>
</tr>
<tr>
<td>volume</td>
<td>音量</td>
<td>Turn on the volume</td>
</tr>
<tr>
<td>get on with</td>
<td>与…相处</td>
<td>She likes get on with animals</td>
</tr>
<tr>
<td>tourism</td>
<td>旅游</td>
<td>I like tourism around the world</td>
</tr>
<tr>
<td>industry</td>
<td>行业</td>
<td>The tourism industry is getting worse</td>
</tr>
<tr>
<td>experience</td>
<td>经验</td>
<td>He has five years of programming experience</td>
</tr>
<tr>
<td>sorrows</td>
<td>悲伤</td>
<td>I often share happiness and sorrows with my friends</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>单词</tag>
      </tags>
  </entry>
  <entry>
    <title>go big or go home-18</title>
    <url>/2020/04/02/go-big-or-go-home-18/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>单词/短语</th>
<th>中文</th>
<th>句子</th>
</tr>
</thead>
<tbody><tr>
<td>noisy</td>
<td>吵闹的</td>
<td>I think they are noisy</td>
</tr>
<tr>
<td>crowd</td>
<td>人群</td>
<td>Crowds of people poured into the street</td>
</tr>
<tr>
<td>sprite</td>
<td>雪碧</td>
<td>-</td>
</tr>
<tr>
<td>soda</td>
<td>饮料(带气的饮料)</td>
<td>-</td>
</tr>
<tr>
<td>beverage</td>
<td>饮料</td>
<td>-</td>
</tr>
<tr>
<td>pepsi</td>
<td>百事可乐</td>
<td>-</td>
</tr>
<tr>
<td>coke</td>
<td>可口可乐</td>
<td>-</td>
</tr>
<tr>
<td>diet coke</td>
<td>零卡路里的饮料</td>
<td>-</td>
</tr>
<tr>
<td>hot chocolate</td>
<td>热巧克力</td>
<td>-</td>
</tr>
<tr>
<td>espresso</td>
<td>浓缩咖啡</td>
<td>-</td>
</tr>
<tr>
<td>champagne</td>
<td>香槟酒</td>
<td>-</td>
</tr>
<tr>
<td>lemonade</td>
<td>柠檬水</td>
<td>-</td>
</tr>
<tr>
<td>red wine</td>
<td>红葡萄酒</td>
<td>-</td>
</tr>
<tr>
<td>white wine</td>
<td>白葡萄酒</td>
<td>-</td>
</tr>
<tr>
<td>cocktail</td>
<td>鸡尾酒</td>
<td>-</td>
</tr>
<tr>
<td>whisky</td>
<td>威士忌</td>
<td>-</td>
</tr>
<tr>
<td>bartender</td>
<td>酒保</td>
<td>-</td>
</tr>
<tr>
<td>barmaid</td>
<td>女酒保</td>
<td>-</td>
</tr>
<tr>
<td>Bar Taps</td>
<td>啤酒牌子</td>
<td>-</td>
</tr>
<tr>
<td>strobe lights</td>
<td>舞台灯光</td>
<td>-</td>
</tr>
<tr>
<td>coat check</td>
<td>保管衣服的地方</td>
<td>-</td>
</tr>
<tr>
<td>alcohol</td>
<td>酒精</td>
<td>I can’t have alcohol today,because I need to drive later</td>
</tr>
<tr>
<td>ketch up</td>
<td>番茄酱</td>
<td>-</td>
</tr>
<tr>
<td>french fries</td>
<td>薯条</td>
<td>-</td>
</tr>
<tr>
<td>small</td>
<td>小</td>
<td>-</td>
</tr>
<tr>
<td>medium</td>
<td>中</td>
<td>-</td>
</tr>
<tr>
<td>large</td>
<td>大</td>
<td>-</td>
</tr>
<tr>
<td>extra large</td>
<td>超大</td>
<td>-</td>
</tr>
<tr>
<td>beef patties</td>
<td>牛肉肉饼</td>
<td>-</td>
</tr>
<tr>
<td>junk food</td>
<td>垃圾食品</td>
<td>-</td>
</tr>
<tr>
<td>shrimp</td>
<td>虾肉</td>
<td>-</td>
</tr>
<tr>
<td>thirsty</td>
<td>口渴的</td>
<td>-</td>
</tr>
<tr>
<td>relay</td>
<td>比赛</td>
<td>In a 400-meter relay,a runner passes the baton to the next person</td>
</tr>
<tr>
<td>bean curd</td>
<td>豆腐</td>
<td>Bean curd is healthy and tasty</td>
</tr>
<tr>
<td>editor</td>
<td>编辑</td>
<td>The video editor is using special computer software to do his work</td>
</tr>
<tr>
<td>register</td>
<td>登记</td>
<td>You should register on this page first,then you can use this APP</td>
</tr>
<tr>
<td>jam</td>
<td>果酱</td>
<td>I like eating the bread with sweet jam</td>
</tr>
<tr>
<td>greet</td>
<td>问好</td>
<td>This gentlemen takes his hat off to greet people</td>
</tr>
<tr>
<td>former</td>
<td>前任的</td>
<td>The first photograph is our former headmaster</td>
</tr>
<tr>
<td>cage</td>
<td>笼子，鸟笼</td>
<td>Get me out of this cage.Where’s the key?</td>
</tr>
<tr>
<td>garlic</td>
<td>大蒜</td>
<td>Garlic makes any meal taste better</td>
</tr>
<tr>
<td>sentence</td>
<td>句子</td>
<td>Note the importance of this sentence</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>单词</tag>
      </tags>
  </entry>
  <entry>
    <title>go big or go home-19</title>
    <url>/2020/04/03/go-big-or-go-home-19/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>单词/短语</th>
<th>中文</th>
<th>句子</th>
</tr>
</thead>
<tbody><tr>
<td>pilot</td>
<td>飞行员</td>
<td>The heroic pilot managed to land the damaged plane safely</td>
</tr>
<tr>
<td>mustard</td>
<td>芥末</td>
<td>Would you like some mustard on your sandwich?</td>
</tr>
<tr>
<td>agriculture</td>
<td>农业</td>
<td>We depend on agriculture to give us food</td>
</tr>
<tr>
<td>proposal</td>
<td>建议</td>
<td>He’s against the teacher’s proposal</td>
</tr>
<tr>
<td>mailbox</td>
<td>邮箱</td>
<td>Hey！You’ve got a leeter in your mailbox</td>
</tr>
<tr>
<td>cap</td>
<td>帽子</td>
<td>This is a blue police cap</td>
</tr>
<tr>
<td>straight</td>
<td>直的</td>
<td>How did you get your hair so straight?</td>
</tr>
<tr>
<td>restaurant</td>
<td>饭馆</td>
<td>The happy family are dining together at a restaurant</td>
</tr>
<tr>
<td>shrimp</td>
<td>虾肉</td>
<td>-</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>单词</tag>
      </tags>
  </entry>
  <entry>
    <title>go big or go home-20</title>
    <url>/2020/04/04/go-big-or-go-home-20/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>单词/短语</th>
<th>中文</th>
<th>句子</th>
</tr>
</thead>
<tbody><tr>
<td>plate</td>
<td>盘子</td>
<td>I can put much food on this big plate</td>
</tr>
<tr>
<td>so that</td>
<td>太…以至于</td>
<td>Its so hot that I’m going to melt</td>
</tr>
<tr>
<td>discovery</td>
<td>发现</td>
<td>She makes a discovery in the field of flowers</td>
</tr>
<tr>
<td>outline</td>
<td>外形</td>
<td>The girl drew an outline of the model</td>
</tr>
<tr>
<td>zip code</td>
<td>邮政编码</td>
<td>You must write a zip code on the envelope before mailing a letter</td>
</tr>
<tr>
<td>lip</td>
<td>嘴唇</td>
<td>Her lips are the most beautiful part of her face</td>
</tr>
<tr>
<td>weed</td>
<td>杂草</td>
<td>The worker is cutting the weeds</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>单词</tag>
      </tags>
  </entry>
  <entry>
    <title>go big or go home-21</title>
    <url>/2020/04/05/go-big-or-go-home-21/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>单词/短语</th>
<th>中文</th>
<th>句子</th>
</tr>
</thead>
<tbody><tr>
<td>vertical</td>
<td>垂直的</td>
<td>The boy found the only vertical tree in the woods</td>
</tr>
<tr>
<td>extraordinary</td>
<td>非同寻常的</td>
<td>The teacher said my daughter has extraordinary musical talent</td>
</tr>
<tr>
<td>object</td>
<td>物体</td>
<td>UFO is the short form of Unidentified Flying Object</td>
</tr>
<tr>
<td>ahead</td>
<td>领先</td>
<td>I am running ahead of the rest of the group</td>
</tr>
<tr>
<td>for ever</td>
<td>永远</td>
<td>Diamonds and gold last for ever, and so will our love</td>
</tr>
<tr>
<td>tip</td>
<td>小费</td>
<td>I paid $5 to the waiter for tip</td>
</tr>
<tr>
<td>barber</td>
<td>理发师</td>
<td>I asked my barber to give me a new style this time</td>
</tr>
<tr>
<td>coronavirus</td>
<td>冠状病毒</td>
<td></td>
</tr>
<tr>
<td>western restaurant</td>
<td>西餐厅</td>
<td></td>
</tr>
<tr>
<td>dining table</td>
<td>餐桌(正餐)</td>
<td></td>
</tr>
<tr>
<td>6 o’clock sharp</td>
<td>六点整</td>
<td></td>
</tr>
<tr>
<td>half past 10</td>
<td>十点半</td>
<td></td>
</tr>
<tr>
<td>a quarter past 10</td>
<td>十点十五</td>
<td></td>
</tr>
<tr>
<td>make a reservation</td>
<td>预定(还没有预订)</td>
<td></td>
</tr>
<tr>
<td>have a reservation</td>
<td>预定(已经预订了)</td>
<td></td>
</tr>
<tr>
<td>book a table</td>
<td>预定一个位置</td>
<td></td>
</tr>
<tr>
<td>breakfast</td>
<td>早餐，注意没有r</td>
<td></td>
</tr>
<tr>
<td>have…for dinner</td>
<td>晚餐吃什么</td>
<td>I have fruit for dinner</td>
</tr>
<tr>
<td>receptionist</td>
<td>前台</td>
<td></td>
</tr>
<tr>
<td>Certainly</td>
<td>当然</td>
<td></td>
</tr>
<tr>
<td>I’d like to</td>
<td>想要，不是命令</td>
<td></td>
</tr>
<tr>
<td>I want to</td>
<td>想要，带有命令</td>
<td></td>
</tr>
<tr>
<td>Ms</td>
<td>/miz/</td>
<td>you don’t know</td>
</tr>
<tr>
<td>Miss</td>
<td>/mis/</td>
<td>unmarried</td>
</tr>
<tr>
<td>Mrs</td>
<td>/misiz/</td>
<td>married</td>
</tr>
<tr>
<td>on</td>
<td>具体的一天</td>
<td>on Saturday</td>
</tr>
<tr>
<td>in</td>
<td>范围</td>
<td>in Spring</td>
</tr>
<tr>
<td>at</td>
<td>具体时刻</td>
<td>at 7o’clock</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>单词</tag>
      </tags>
  </entry>
  <entry>
    <title>go big or go home-22</title>
    <url>/2020/04/06/go-big-or-go-home-22/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>单词/短语</th>
<th>中文</th>
<th>句子</th>
</tr>
</thead>
<tbody><tr>
<td>bang</td>
<td>巨响</td>
<td>After a guest of wind,the door was suddenly shut with a bang</td>
</tr>
<tr>
<td>veal</td>
<td>小牛肉</td>
<td>My favorite meat is veal</td>
</tr>
<tr>
<td>yoghurt</td>
<td>酸奶</td>
<td>Yoghurt tastes very delicious with cookies</td>
</tr>
<tr>
<td>by and by</td>
<td>逐渐的</td>
<td>By and by,the tree will lose its leaves</td>
</tr>
<tr>
<td>wounded</td>
<td>受伤的</td>
<td>The wounded soldier goes to the doctor every day</td>
</tr>
<tr>
<td>pill</td>
<td>药丸</td>
<td>The woman took some pills when she was ill</td>
</tr>
<tr>
<td>goal</td>
<td>目标</td>
<td>The boy’s goal is to become as strong as the man in the poster</td>
</tr>
<tr>
<td>Olympic</td>
<td>奥林匹克</td>
<td>The five rings are the symbol of the Olympic games</td>
</tr>
<tr>
<td>get pay</td>
<td>得到加班费，钱</td>
<td>Do you get pay for that?</td>
</tr>
<tr>
<td>one day off</td>
<td>一天的休息</td>
<td>-</td>
</tr>
<tr>
<td>virus</td>
<td>病毒</td>
<td>-</td>
</tr>
<tr>
<td>fried rice</td>
<td>炒饭</td>
<td>-</td>
</tr>
<tr>
<td>flavor</td>
<td>口味</td>
<td>What’s your favorite flavor of the ice cream?</td>
</tr>
<tr>
<td>vanilla</td>
<td>香草</td>
<td>-</td>
</tr>
<tr>
<td>caramel</td>
<td>焦糖</td>
<td>-</td>
</tr>
<tr>
<td>avocado</td>
<td>牛油果</td>
<td>-</td>
</tr>
<tr>
<td>mix</td>
<td>搅拌</td>
<td>-</td>
</tr>
<tr>
<td>carrot</td>
<td>胡萝卜</td>
<td>-</td>
</tr>
<tr>
<td>mashed potato</td>
<td>土豆泥</td>
<td>-</td>
</tr>
<tr>
<td>dressing</td>
<td>口味，调料</td>
<td>-</td>
</tr>
<tr>
<td>ketchup</td>
<td>番茄酱</td>
<td>-</td>
</tr>
<tr>
<td>mayo</td>
<td>蛋黄酱</td>
<td>-</td>
</tr>
<tr>
<td>sesame oil</td>
<td>麻油，芝麻油</td>
<td>-</td>
</tr>
<tr>
<td>light mayo</td>
<td>淡一点的蛋黄酱</td>
<td>-</td>
</tr>
<tr>
<td>mustard</td>
<td>黄芥末酱</td>
<td>-</td>
</tr>
<tr>
<td>ranch</td>
<td>牧场/田园酱</td>
<td>-</td>
</tr>
<tr>
<td>ingredients</td>
<td>材料</td>
<td>-</td>
</tr>
<tr>
<td>cucumber</td>
<td>黄瓜</td>
<td>-</td>
</tr>
<tr>
<td>lettuce</td>
<td>生菜</td>
<td>-</td>
</tr>
<tr>
<td>olives</td>
<td>橄榄</td>
<td>-</td>
</tr>
<tr>
<td>spinach</td>
<td>菠菜</td>
<td>-</td>
</tr>
<tr>
<td>host</td>
<td>主人</td>
<td>-</td>
</tr>
<tr>
<td>host family</td>
<td>寄宿家庭</td>
<td>-</td>
</tr>
<tr>
<td>seem</td>
<td>看起来</td>
<td>It seems like he is crying</td>
</tr>
<tr>
<td>yummy</td>
<td>可口的</td>
<td>-</td>
</tr>
<tr>
<td>oatmeal</td>
<td>燕麦粥</td>
<td>-</td>
</tr>
<tr>
<td>kiwifruit</td>
<td>猕猴桃</td>
<td>-</td>
</tr>
<tr>
<td>lollipops</td>
<td>棒棒糖</td>
<td>-</td>
</tr>
<tr>
<td>cotton candy</td>
<td>棉花糖</td>
<td>-</td>
</tr>
<tr>
<td>brownies</td>
<td>布朗尼</td>
<td>-</td>
</tr>
<tr>
<td>tiramisu</td>
<td>提拉米苏</td>
<td>-</td>
</tr>
<tr>
<td>a sweet pudding</td>
<td>布丁</td>
<td>-</td>
</tr>
<tr>
<td>custard</td>
<td>蛋挞</td>
<td>-</td>
</tr>
<tr>
<td>matcha</td>
<td>抹茶</td>
<td>-</td>
</tr>
<tr>
<td>blender</td>
<td>搅拌机</td>
<td>-</td>
</tr>
<tr>
<td>chop</td>
<td>切块</td>
<td>-</td>
</tr>
<tr>
<td>mince</td>
<td>切碎</td>
<td>-</td>
</tr>
<tr>
<td>slice</td>
<td>切薄片</td>
<td>-</td>
</tr>
<tr>
<td>instant</td>
<td>即刻的</td>
<td>-</td>
</tr>
<tr>
<td>instant noodle</td>
<td>方便面</td>
<td>-</td>
</tr>
<tr>
<td>vitamins</td>
<td>维生素</td>
<td>-</td>
</tr>
<tr>
<td>nutrients</td>
<td>营养物</td>
<td>-</td>
</tr>
<tr>
<td>carbohydrates</td>
<td>碳水化合物</td>
<td>-</td>
</tr>
<tr>
<td>salmon</td>
<td>三文鱼</td>
<td>-</td>
</tr>
<tr>
<td>crab</td>
<td>螃蟹</td>
<td>-</td>
</tr>
<tr>
<td>squid</td>
<td>鱿鱼</td>
<td>-</td>
</tr>
<tr>
<td>octopus</td>
<td>章鱼</td>
<td>-</td>
</tr>
<tr>
<td>leafy greens</td>
<td>绿叶蔬菜</td>
<td>-</td>
</tr>
<tr>
<td>benefit</td>
<td>好处</td>
<td>-</td>
</tr>
<tr>
<td>spicy food</td>
<td>辣的食物</td>
<td>-</td>
</tr>
<tr>
<td>one big meal</td>
<td>整餐</td>
<td>-</td>
</tr>
<tr>
<td>several small snacks</td>
<td>小吃</td>
<td>-</td>
</tr>
<tr>
<td>gym person</td>
<td>健身的人</td>
<td>-</td>
</tr>
<tr>
<td>sugar cravings</td>
<td>对糖的渴望</td>
<td>-</td>
</tr>
<tr>
<td>gold</td>
<td>黄金</td>
<td>Diamonds and gold last for ever,and so will our love</td>
</tr>
<tr>
<td>day by day</td>
<td>每天逐渐往某个方向前进</td>
<td>He’s getting better day by day</td>
</tr>
<tr>
<td>day after day</td>
<td>重复每天不变</td>
<td>I’m sick of working day after day</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>单词</tag>
      </tags>
  </entry>
  <entry>
    <title>go big or go home-24</title>
    <url>/2020/04/08/go-big-or-go-home-24/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>单词/短语</th>
<th>中文</th>
<th>句子</th>
</tr>
</thead>
<tbody><tr>
<td>abroad</td>
<td>到国外</td>
<td>The happy couple traveled abroad and took photos together</td>
</tr>
<tr>
<td>biography</td>
<td>传记文学</td>
<td>On the shelf,you’ll find many biographies of famous people</td>
</tr>
<tr>
<td>voyage</td>
<td>航海</td>
<td>The ship is on a voyage now</td>
</tr>
<tr>
<td>as soon as</td>
<td>一…就</td>
<td>As soon as he got home,it stopped raining</td>
</tr>
<tr>
<td>besides</td>
<td>除…之外</td>
<td>As the winner,I recevied lots of money besides the cup</td>
</tr>
<tr>
<td>fiber</td>
<td>纤维</td>
<td>We can see the fibers of the rope under a magnifying glass</td>
</tr>
<tr>
<td>roller</td>
<td>滚筒</td>
<td>Use the roller to paint the walls</td>
</tr>
<tr>
<td>chew</td>
<td>咀嚼</td>
<td>The boy is chewing the rice</td>
</tr>
<tr>
<td>catch up with</td>
<td>赶上</td>
<td>I finally catch up with other people</td>
</tr>
<tr>
<td>sleep like a baby</td>
<td>像婴儿一样睡觉</td>
<td>-</td>
</tr>
<tr>
<td>guest</td>
<td>客人</td>
<td>-</td>
</tr>
<tr>
<td>professional</td>
<td>专业的</td>
<td>-</td>
</tr>
<tr>
<td>shocked</td>
<td>震惊</td>
<td>-</td>
</tr>
<tr>
<td>frightened</td>
<td>害怕的</td>
<td>-</td>
</tr>
<tr>
<td>satisfy</td>
<td>满意</td>
<td>-</td>
</tr>
<tr>
<td>quiet</td>
<td>安静的</td>
<td>-</td>
</tr>
<tr>
<td>cheer up</td>
<td>加油(宠物狗死了，可以说cheer up)</td>
<td>-</td>
</tr>
<tr>
<td>hang in there</td>
<td>坚持住</td>
<td>-</td>
</tr>
<tr>
<td>take you time</td>
<td>别着急</td>
<td>-</td>
</tr>
<tr>
<td>salary raise</td>
<td>加薪</td>
<td>-</td>
</tr>
<tr>
<td>narrow</td>
<td>狭隘的</td>
<td>-</td>
</tr>
<tr>
<td>screen candidates</td>
<td>筛选候选人</td>
<td>-</td>
</tr>
<tr>
<td>pool of applications</td>
<td>应用池</td>
<td>-</td>
</tr>
<tr>
<td>recruit</td>
<td>招聘</td>
<td>-</td>
</tr>
<tr>
<td>resume</td>
<td>简历</td>
<td>-</td>
</tr>
<tr>
<td>tips</td>
<td>提示</td>
<td>-</td>
</tr>
<tr>
<td>algorithm</td>
<td>算法</td>
<td>-</td>
</tr>
<tr>
<td>headset</td>
<td>耳机</td>
<td>-</td>
</tr>
<tr>
<td>hardworking</td>
<td>勤奋的</td>
<td>-</td>
</tr>
<tr>
<td>confirm</td>
<td>确认</td>
<td>-</td>
</tr>
<tr>
<td>details</td>
<td>详情，细节</td>
<td>-</td>
</tr>
<tr>
<td>etiquette</td>
<td>礼仪</td>
<td>-</td>
</tr>
<tr>
<td>impression</td>
<td>印象</td>
<td>-</td>
</tr>
<tr>
<td>greeting</td>
<td>招呼</td>
<td>-</td>
</tr>
<tr>
<td>job fair</td>
<td>招聘会</td>
<td>-</td>
</tr>
<tr>
<td>confident</td>
<td>信心</td>
<td>-</td>
</tr>
<tr>
<td>slouch</td>
<td>懒散的</td>
<td>-</td>
</tr>
<tr>
<td>hand shake</td>
<td>握手</td>
<td>-</td>
</tr>
<tr>
<td>make eye contact</td>
<td>眼神交流</td>
<td>-</td>
</tr>
<tr>
<td>big picture thinker</td>
<td>大局观的</td>
<td>-</td>
</tr>
<tr>
<td>liberty</td>
<td>自由</td>
<td>The bird flew from the cage and got liberty</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>单词</tag>
      </tags>
  </entry>
  <entry>
    <title>go big or go home-25</title>
    <url>/2020/04/10/go-big-or-go-home-25/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>单词/短语</th>
<th>中文</th>
<th>句子</th>
</tr>
</thead>
<tbody><tr>
<td>headmistress</td>
<td>女校长</td>
<td>Our headmistress is giving us a speech</td>
</tr>
<tr>
<td>conventional</td>
<td>依据惯例的</td>
<td>Although we can now pay online,some people still prefer the conventional method of cash</td>
</tr>
<tr>
<td>carry out</td>
<td>完成</td>
<td>After the hard work,I finally carried out my plan</td>
</tr>
<tr>
<td>behaviour</td>
<td>行为</td>
<td>I can tell he is happy from his behaviour</td>
</tr>
<tr>
<td>mirror</td>
<td>镜子</td>
<td>Look at yourselves in the mirror</td>
</tr>
<tr>
<td>vast</td>
<td>辽阔的</td>
<td>This vast desert looks impossible to pass</td>
</tr>
<tr>
<td>toast</td>
<td>烤面包</td>
<td>There are two slices of toast and some butter on the table</td>
</tr>
<tr>
<td>cyclist</td>
<td>骑自行车的人</td>
<td>The cyclist stopped to enjoy the beautiful natuial scenery</td>
</tr>
<tr>
<td>satisfy</td>
<td>满意</td>
<td>-</td>
</tr>
<tr>
<td>frightened</td>
<td>害怕的</td>
<td>-</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>单词</tag>
      </tags>
  </entry>
  <entry>
    <title>go big or go home-23</title>
    <url>/2020/04/07/go-big-or-go-home-23/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>单词/短语</th>
<th>中文</th>
<th>句子</th>
</tr>
</thead>
<tbody><tr>
<td>pure</td>
<td>纯净的</td>
<td>The water seems so pure and clean</td>
</tr>
<tr>
<td>regulation</td>
<td>法规</td>
<td>The traffic police is introducing traffic rules and regulations to us</td>
</tr>
<tr>
<td>Africa</td>
<td>非洲</td>
<td>Africa is home to some of the world’s oldest cultures</td>
</tr>
<tr>
<td>motherland</td>
<td>祖国</td>
<td>Everyone has their own motherland</td>
</tr>
<tr>
<td>liberty</td>
<td>自由</td>
<td>The bird flew from the cage and got liberty</td>
</tr>
<tr>
<td>pair</td>
<td>一对</td>
<td>Here is a pair of black shoes</td>
</tr>
<tr>
<td>irrigate</td>
<td>灌溉</td>
<td>This machine can irrigate the field</td>
</tr>
<tr>
<td>accompany</td>
<td>陪伴</td>
<td>I always accompany my children to their school</td>
</tr>
<tr>
<td>typist</td>
<td>打字员</td>
<td>The typist is finishing her documents</td>
</tr>
<tr>
<td>barrier</td>
<td>路障</td>
<td>The road was closed by a barrier</td>
</tr>
<tr>
<td>octopus</td>
<td>章鱼</td>
<td>-</td>
</tr>
<tr>
<td>slice</td>
<td>切薄片</td>
<td>-</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>单词</tag>
      </tags>
  </entry>
  <entry>
    <title>go big or go home-27</title>
    <url>/2020/04/11/go-big-or-go-home-27/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>单词/短语</th>
<th>中文</th>
<th>句子</th>
</tr>
</thead>
<tbody><tr>
<td>emergency</td>
<td>紧急情况</td>
<td>It’s an emergency.Get her to the hospital now!</td>
</tr>
<tr>
<td>do one’s best</td>
<td>尽最大的努力</td>
<td>Don’t worry so much about the exam.Just do your best</td>
</tr>
<tr>
<td>absolute</td>
<td>绝对的</td>
<td>Motion is absolute,while stillness is relative</td>
</tr>
<tr>
<td>tongue</td>
<td>舌头</td>
<td>The boy sticks out his tongue to make a face to me</td>
</tr>
<tr>
<td>instruct</td>
<td>指导</td>
<td>My mom instructs me how to play golf</td>
</tr>
<tr>
<td>nylon</td>
<td>尼龙</td>
<td>The socks,strap and cord are all made of nylon</td>
</tr>
<tr>
<td>strange</td>
<td>奇怪的</td>
<td>I met a guy wearing strange clothes on the subway</td>
</tr>
<tr>
<td>secondhand</td>
<td>二手的</td>
<td>The boy bought a secondhand book from the old man</td>
</tr>
<tr>
<td>expand</td>
<td>扩大</td>
<td>Our business is expanding across the whole country</td>
</tr>
<tr>
<td>forest</td>
<td>森林</td>
<td>The sun shines through the forest</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>单词</tag>
      </tags>
  </entry>
  <entry>
    <title>go big or go home-28</title>
    <url>/2020/04/12/go-big-or-go-home-28/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>单词/短语</th>
<th>中文</th>
<th>句子</th>
</tr>
</thead>
<tbody><tr>
<td>go by</td>
<td>流逝</td>
<td>Don’t waste your time as it goes by quickly</td>
</tr>
<tr>
<td>left-handed</td>
<td>惯用左手的</td>
<td>This left-handed girl is painting with her left hand</td>
</tr>
<tr>
<td>badminton</td>
<td>羽毛球</td>
<td>These kids are playing badminton in the park</td>
</tr>
<tr>
<td>bench</td>
<td>长凳</td>
<td>The boy is sitting on the bench with his monther</td>
</tr>
<tr>
<td>seaman</td>
<td>水手</td>
<td>He looks really happy in the seaman uniform</td>
</tr>
<tr>
<td>bookshelf</td>
<td>书架</td>
<td>Various books are placed on the bookshelves</td>
</tr>
<tr>
<td>diamond</td>
<td>钻石</td>
<td>Diamond rings are very popular among young couples</td>
</tr>
<tr>
<td>bucket</td>
<td>水桶</td>
<td>The cute cat is hiding in a bucket</td>
</tr>
<tr>
<td>Antarctic</td>
<td>南极</td>
<td>This kind of animal lives in the Antarctic</td>
</tr>
<tr>
<td>graduation</td>
<td>毕业</td>
<td>They stand in line and wait for their graduation ceremony</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>单词</tag>
      </tags>
  </entry>
  <entry>
    <title>go big or go home-26</title>
    <url>/2020/04/10/go-big-or-go-home-26/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>单词/短语</th>
<th>中文</th>
<th>句子</th>
</tr>
</thead>
<tbody><tr>
<td>give in</td>
<td>投降</td>
<td>He finally gave in to me and admintted that I’m the winner</td>
</tr>
<tr>
<td>transform</td>
<td>改变</td>
<td>You will transform into a beautiful butterfly one day</td>
</tr>
<tr>
<td>department</td>
<td>部门</td>
<td>Our company consists of financial department,sales department,and technical department</td>
</tr>
<tr>
<td>put off</td>
<td>推迟</td>
<td>The sports meeting will be put off because of the rain</td>
</tr>
<tr>
<td>mass</td>
<td>众多</td>
<td>A mass of people are waiting</td>
</tr>
<tr>
<td>allow</td>
<td>允许</td>
<td>The green light allows you to go</td>
</tr>
<tr>
<td>serious</td>
<td>认真的</td>
<td>He is always very serious while working</td>
</tr>
<tr>
<td>seem</td>
<td>看起来</td>
<td>It seems his car has a serious problem</td>
</tr>
<tr>
<td>aboard</td>
<td>在…上</td>
<td>In Thailand,fishers often cook and have meals aboard their boats</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>单词</tag>
      </tags>
  </entry>
  <entry>
    <title>go big or go home-29</title>
    <url>/2020/04/13/go-big-or-go-home-29/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>单词/短语</th>
<th>中文</th>
<th>句子</th>
</tr>
</thead>
<tbody><tr>
<td>soil</td>
<td>泥土</td>
<td>He held some soil in his hand</td>
</tr>
<tr>
<td>appropriate</td>
<td>合适的</td>
<td>A gentle handshake is appropriate when greeting someone for the first time</td>
</tr>
<tr>
<td>hook</td>
<td>钩子</td>
<td>We put a worm on the hook to catch a fish</td>
</tr>
<tr>
<td>knot</td>
<td>结</td>
<td>Chinese knots are a traditional handicraft of China</td>
</tr>
<tr>
<td>punishment</td>
<td>惩罚</td>
<td>The student was given punishment for doing something wrong</td>
</tr>
<tr>
<td>interrput</td>
<td>打扰</td>
<td>Their conversion was interrputed by a knock at the door</td>
</tr>
<tr>
<td>bread</td>
<td>面包</td>
<td>There are different kinds of bread in the picture</td>
</tr>
<tr>
<td>disgusting</td>
<td>令人厌恶的</td>
<td>He finds the smell of the sock disgusting</td>
</tr>
<tr>
<td>non-violent</td>
<td>非暴力的</td>
<td>Every conflict has a non-violent solution</td>
</tr>
<tr>
<td>Morning person</td>
<td>习惯早起的人</td>
<td>I hate waking up early for work,so I’m totally not a morning person</td>
</tr>
<tr>
<td>early bird</td>
<td>早起的鸟儿</td>
<td>Tom is an early bird.He is always the first to arrive in school</td>
</tr>
<tr>
<td>night person</td>
<td>晚睡的人</td>
<td>He is really a night person,he always stays up very late</td>
</tr>
<tr>
<td>night owl</td>
<td>夜晚的猫头鹰</td>
<td>When the important exams come,Jack becomes a night owl</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>单词</tag>
      </tags>
  </entry>
  <entry>
    <title>go big or go home-30</title>
    <url>/2020/04/14/go-big-or-go-home-30/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>单词/短语</th>
<th>中文</th>
<th>句子</th>
</tr>
</thead>
<tbody><tr>
<td>apartment</td>
<td>公寓</td>
<td>This apartment is so bright with these windows</td>
</tr>
<tr>
<td>Ms</td>
<td>/miz/</td>
<td>you don’t know</td>
</tr>
<tr>
<td>Miss</td>
<td>/mis/</td>
<td>unmarried</td>
</tr>
<tr>
<td>Mrs</td>
<td>/misiz/</td>
<td>married</td>
</tr>
<tr>
<td>catch</td>
<td>捕捉</td>
<td>The goalkeeper caught the ball.What a save!</td>
</tr>
<tr>
<td>dead</td>
<td>死的</td>
<td>The fish is dead</td>
</tr>
<tr>
<td>sparrow</td>
<td>麻雀</td>
<td>Sparrows are small brown and grey birds,and are common in many parts of the world</td>
</tr>
<tr>
<td>mud</td>
<td>泥</td>
<td>Oh no!I think our car is stuck in the mud!</td>
</tr>
<tr>
<td>stuck</td>
<td>不能动的</td>
<td>同上</td>
</tr>
<tr>
<td>shapes</td>
<td>形状</td>
<td>I like collecting glasses of all shapes and sizes</td>
</tr>
<tr>
<td>interrput</td>
<td>打扰</td>
<td>Their conversation was interrputed by a knock at the door</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>单词</tag>
      </tags>
  </entry>
  <entry>
    <title>go big or go home-31</title>
    <url>/2020/04/15/go-big-or-go-home-31/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>单词/短语</th>
<th>中文</th>
<th>句子</th>
</tr>
</thead>
<tbody><tr>
<td>colleague</td>
<td>同事</td>
<td>I really learned a lot of discussing with my colleagues</td>
</tr>
<tr>
<td>arrow</td>
<td>箭</td>
<td>Traditional hunters use arrows to catch animals</td>
</tr>
<tr>
<td>empty</td>
<td>空的</td>
<td>The man’s wallet is empty</td>
</tr>
<tr>
<td>associate</td>
<td>联想</td>
<td>I associate this picture with a star</td>
</tr>
<tr>
<td>easy-going</td>
<td>随和</td>
<td>My friend and I are easy-going</td>
</tr>
<tr>
<td>carry off</td>
<td>夺走</td>
<td>He’s gonna carry off her bag!Stop him!</td>
</tr>
<tr>
<td>lost</td>
<td>迷路的</td>
<td>The hikers are lost walking in the forest</td>
</tr>
<tr>
<td>lock</td>
<td>锁</td>
<td>The door is locked;we can’t get in</td>
</tr>
<tr>
<td>slice</td>
<td>切片</td>
<td>The man thinly slices the beef</td>
</tr>
<tr>
<td>might</td>
<td>或许</td>
<td>I think it might rain later,so I should take an umbrella</td>
</tr>
<tr>
<td>dead</td>
<td>死的</td>
<td>The fish is dead</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>单词</tag>
      </tags>
  </entry>
  <entry>
    <title>go big or go home-3</title>
    <url>/2020/03/18/go-big-or-go-home-3/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>单词/短语</th>
<th>中文</th>
<th>句子</th>
</tr>
</thead>
<tbody><tr>
<td>output</td>
<td>生产</td>
<td>You need to have the output of the code</td>
</tr>
<tr>
<td>pocket</td>
<td>口袋</td>
<td>My pocket is full of money</td>
</tr>
<tr>
<td>dioxide</td>
<td>氧化物</td>
<td>Carbon dioxide causes global warming</td>
</tr>
<tr>
<td>several</td>
<td>几个</td>
<td>I hava several apples</td>
</tr>
<tr>
<td>award</td>
<td>奖</td>
<td>He won the ACM award</td>
</tr>
<tr>
<td>physical education</td>
<td>体育课</td>
<td>I like physical education when I was a student</td>
</tr>
<tr>
<td>physics</td>
<td>物理</td>
<td>Physics is amazing</td>
</tr>
<tr>
<td>past tense</td>
<td>过去式</td>
<td>It was all in the past</td>
</tr>
<tr>
<td>primary school</td>
<td>小学</td>
<td>He’s only eight years old in primary school</td>
</tr>
<tr>
<td>junior high school/middle school</td>
<td>初中</td>
<td>He studied physics in junior high school</td>
</tr>
<tr>
<td>high school</td>
<td>高中</td>
<td>He studied biology in high school</td>
</tr>
<tr>
<td>approachable</td>
<td>亲和力的</td>
<td>My teacher is very approachable</td>
</tr>
<tr>
<td>chemistry</td>
<td>化学</td>
<td>I like chemistry</td>
</tr>
<tr>
<td>biology</td>
<td>生物</td>
<td>Biology is a very difficult subject</td>
</tr>
<tr>
<td>science classes</td>
<td>理科</td>
<td>I studied science classes in my high school</td>
</tr>
<tr>
<td>art classes</td>
<td>文科</td>
<td>I studied art classes in my high school</td>
</tr>
<tr>
<td>geography</td>
<td>地理</td>
<td>Geography was my weak subject</td>
</tr>
<tr>
<td>politics</td>
<td>政治</td>
<td>He quickly involved himself in local politics</td>
</tr>
<tr>
<td>have a test</td>
<td>测试</td>
<td>There is a test this week</td>
</tr>
<tr>
<td>have an exam</td>
<td>考试</td>
<td>There is an exam this week about biology</td>
</tr>
<tr>
<td>exercise</td>
<td>锻炼</td>
<td>I run every day to exercise my legs</td>
</tr>
<tr>
<td>spacious and bright</td>
<td>宽敞明亮</td>
<td>My house is spacious and bright</td>
</tr>
<tr>
<td>play outside–&gt;针对小孩儿</td>
<td>出去玩儿</td>
<td>In spring,we can play outside all day</td>
</tr>
<tr>
<td>do outdoor activities–&gt;对成年人</td>
<td>出去玩儿</td>
<td>Classes are over, and it’s time for students to do some outdoor activities</td>
</tr>
<tr>
<td>不能与成年人说play with要说hang out</td>
<td>与。。。玩儿</td>
<td>Children like to play with water/Let’s hang out again tomorrow</td>
</tr>
<tr>
<td>besides</td>
<td>除。。。之外</td>
<td>He gave me a book, a pen and some money besides</td>
</tr>
<tr>
<td>house意为别墅/apartment公寓/home意为家</td>
<td>家</td>
<td>All you have to do is make a home video</td>
</tr>
<tr>
<td>volume</td>
<td>声音</td>
<td>turn on the TV volume</td>
</tr>
<tr>
<td>prepare</td>
<td>准备</td>
<td>I’m preparing to tell you</td>
</tr>
<tr>
<td>How are you？</td>
<td>最近怎么样</td>
<td>Couldn’t be better</td>
</tr>
<tr>
<td>How are you doing?</td>
<td>最近怎么样</td>
<td>Keeping busy</td>
</tr>
<tr>
<td>How’s everything?</td>
<td>最近怎么样</td>
<td>Can’t complain</td>
</tr>
<tr>
<td>How’s it going?</td>
<td>最近怎么样</td>
<td>Been getting by</td>
</tr>
<tr>
<td>How’s your business?</td>
<td>最近怎么样</td>
<td>Not so good</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>单词</tag>
      </tags>
  </entry>
  <entry>
    <title>go big or go home-32</title>
    <url>/2020/04/16/go-big-or-go-home-32/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>单词/短语</th>
<th>中文</th>
<th>句子</th>
</tr>
</thead>
<tbody><tr>
<td>latter</td>
<td>后者</td>
<td>When asked what he would prefer;an apple or pizza,the boy chose the latter</td>
</tr>
<tr>
<td>kitchen</td>
<td>厨房</td>
<td>The kitchen is clean and modern</td>
</tr>
<tr>
<td>senior</td>
<td>年长的</td>
<td>The senior citizens in the community often have fun talking to each other</td>
</tr>
<tr>
<td>build</td>
<td>建造</td>
<td>They are building a block of offices</td>
</tr>
<tr>
<td>parcel</td>
<td>包裹</td>
<td>The person has a lot of parcels to send on Novermber 11th</td>
</tr>
<tr>
<td>animal</td>
<td>动物</td>
<td>There are many kinds of animals on earth</td>
</tr>
<tr>
<td>take out the rubbish</td>
<td>倒垃圾</td>
<td>Could you please take out the rubbish when you leave?</td>
</tr>
<tr>
<td>put it in the trash can</td>
<td>放进垃圾桶</td>
<td>Don’t drop the bottle there,please put it in the trash can</td>
</tr>
<tr>
<td>empty the recycle bin</td>
<td>清理垃圾桶</td>
<td>-</td>
</tr>
<tr>
<td>garbage</td>
<td>食物垃圾(美式)</td>
<td>-</td>
</tr>
<tr>
<td>trash</td>
<td>纸/塑料(美式)</td>
<td>-</td>
</tr>
<tr>
<td>rubbish</td>
<td>垃圾(英式)</td>
<td>-</td>
</tr>
<tr>
<td>dead</td>
<td>死的</td>
<td>The fish is dead</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>单词</tag>
      </tags>
  </entry>
  <entry>
    <title>go big or go home-33</title>
    <url>/2020/04/17/go-big-or-go-home-33/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>单词/短语</th>
<th>中文</th>
<th>句子</th>
</tr>
</thead>
<tbody><tr>
<td>suspect</td>
<td>嫌疑犯</td>
<td>The suspect is talking with his lawyer</td>
</tr>
<tr>
<td>hand in</td>
<td>上交</td>
<td>He’s handing in his homework to the teacher</td>
</tr>
<tr>
<td>ladder</td>
<td>梯子</td>
<td>The man is standing on a ladder</td>
</tr>
<tr>
<td>weakness</td>
<td>弱点</td>
<td>Vampires’s weakness is that they are afraid of sunshine</td>
</tr>
<tr>
<td>French</td>
<td>法国</td>
<td>The Eiffel tower is a French landmark</td>
</tr>
<tr>
<td>million</td>
<td>百万</td>
<td>-</td>
</tr>
<tr>
<td>billion</td>
<td>十亿</td>
<td>-</td>
</tr>
<tr>
<td>minibus</td>
<td>小巴士</td>
<td>Let’s take the minibus on a trip!</td>
</tr>
<tr>
<td>junior</td>
<td>三年级学生</td>
<td>The junior is preparing for her exams in the dormitory</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>单词</tag>
      </tags>
  </entry>
  <entry>
    <title>go big or go home-34</title>
    <url>/2020/04/18/go-big-or-go-home-34/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>单词/短语</th>
<th>中文</th>
<th>句子</th>
</tr>
</thead>
<tbody><tr>
<td>point</td>
<td>指向</td>
<td>They are pointing at each other</td>
</tr>
<tr>
<td>department store</td>
<td>百货商场</td>
<td>This department store sells many different kinds of goods</td>
</tr>
<tr>
<td>silver medal</td>
<td>银牌</td>
<td>The athlete who took second place got a silver medal</td>
</tr>
<tr>
<td>forgive</td>
<td>原谅</td>
<td>The girl says,”Can you forgive me,mom?”</td>
</tr>
<tr>
<td>go on doing</td>
<td>继续干某事</td>
<td>Even though he was tired,he went on working for 12 hours</td>
</tr>
<tr>
<td>alone</td>
<td>孤单</td>
<td>Seesaws are not very fun when you’re alone</td>
</tr>
<tr>
<td>brotherhood</td>
<td>手足情谊</td>
<td>The brotherhood between the boys will keep them close forever</td>
</tr>
<tr>
<td>statistics</td>
<td>统计数字</td>
<td>I use facts and statistics to prove my point</td>
</tr>
<tr>
<td>bookstore</td>
<td>书店</td>
<td>She’s buying books in the bookstore</td>
</tr>
<tr>
<td>decision</td>
<td>决定</td>
<td>I’ve made my decision to buy this beautiful skirt</td>
</tr>
<tr>
<td>suspect</td>
<td>嫌疑犯</td>
<td>The suspect is talking with his lawyer</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>单词</tag>
      </tags>
  </entry>
  <entry>
    <title>go big or go home-35</title>
    <url>/2020/04/19/go-big-or-go-home-35/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>单词/短语</th>
<th>中文</th>
<th>句子</th>
</tr>
</thead>
<tbody><tr>
<td>south</td>
<td>南方</td>
<td>A large number of birds fly south every winter</td>
</tr>
<tr>
<td>typhoon</td>
<td>台风</td>
<td>The typhoon destroyed many houses last year</td>
</tr>
<tr>
<td>rid</td>
<td>污点</td>
<td>The stain is gotten rid of easily</td>
</tr>
<tr>
<td>topic</td>
<td>话题</td>
<td>He wrote down a topic for us to discuss</td>
</tr>
<tr>
<td>get on</td>
<td>上车</td>
<td>Let’s get on the airplane</td>
</tr>
<tr>
<td>direction</td>
<td>方向</td>
<td>The man is asking a stranger for directions</td>
</tr>
<tr>
<td>survival</td>
<td>生存</td>
<td>He taught me survival skills,like how to start a fire in the forest</td>
</tr>
<tr>
<td>zebra</td>
<td>斑马</td>
<td>The zebras are running across the river</td>
</tr>
<tr>
<td>amateur</td>
<td>业余爱好者</td>
<td>The office worker is also an amateur soccer player</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>单词</tag>
      </tags>
  </entry>
  <entry>
    <title>go big or go home-36</title>
    <url>/2020/04/20/go-big-or-go-home-36/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>单词/短语</th>
<th>中文</th>
<th>句子</th>
</tr>
</thead>
<tbody><tr>
<td>marble</td>
<td>大理石</td>
<td>The floor is made of marble</td>
</tr>
<tr>
<td>tortoise</td>
<td>乌龟</td>
<td>Look,the little tortoise is eating leaves</td>
</tr>
<tr>
<td>belong</td>
<td>属于</td>
<td>This girl belongs to me!</td>
</tr>
<tr>
<td>acknowledge</td>
<td>告知收到</td>
<td>Acknowledge,We will bake the bread soon</td>
</tr>
<tr>
<td>radiation</td>
<td>辐射物</td>
<td>Don’t get closer to radiation if you are not in protective suit</td>
</tr>
<tr>
<td>anyhow</td>
<td>无论如何</td>
<td>Someone has to wash the dishes anyhow,so I’ll do them</td>
</tr>
<tr>
<td>altitude</td>
<td>海拔</td>
<td>The altitude of this mountain in 8844 meters</td>
</tr>
<tr>
<td>make a toast</td>
<td>敬酒</td>
<td>-</td>
</tr>
<tr>
<td>blush</td>
<td>脸红</td>
<td>-</td>
</tr>
<tr>
<td>tequlia</td>
<td>龙舌兰</td>
<td>-</td>
</tr>
<tr>
<td>raise</td>
<td>举</td>
<td>-</td>
</tr>
<tr>
<td>mixologist</td>
<td>调酒师</td>
<td>-</td>
</tr>
<tr>
<td>bartender</td>
<td>调酒师</td>
<td>-</td>
</tr>
<tr>
<td>alcohol</td>
<td>酒精</td>
<td>-</td>
</tr>
<tr>
<td>rum</td>
<td>朗姆酒</td>
<td>-</td>
</tr>
<tr>
<td>gorgeous</td>
<td>美丽动人的</td>
<td>-</td>
</tr>
<tr>
<td>sake</td>
<td>日本清酒</td>
<td>-</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>单词</tag>
      </tags>
  </entry>
  <entry>
    <title>go big or go home-37</title>
    <url>/2020/04/21/go-big-or-go-home-37/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>单词/短语</th>
<th>中文</th>
<th>句子</th>
</tr>
</thead>
<tbody><tr>
<td>famous</td>
<td>著名的</td>
<td>The lady is a famous actress</td>
</tr>
<tr>
<td>body building</td>
<td>健美</td>
<td>I do body building every day to make my muscles huge</td>
</tr>
<tr>
<td>constant</td>
<td>持续不断的</td>
<td>The constant noise from the construction site makes me crazy</td>
</tr>
<tr>
<td>smell</td>
<td>闻</td>
<td>The girl is smelling the pink flower with delight</td>
</tr>
<tr>
<td>a bit</td>
<td>一点点</td>
<td>There is only a bit of rice left in the pot</td>
</tr>
<tr>
<td>carpenter</td>
<td>木匠</td>
<td>The carpenter is making wooden furniture</td>
</tr>
<tr>
<td>abolish</td>
<td>废除</td>
<td>In the mid 1800s,slavery was abolished in America</td>
</tr>
<tr>
<td>church</td>
<td>教堂</td>
<td>The church is located in a beautiful suburb</td>
</tr>
<tr>
<td>glance</td>
<td>一瞥</td>
<td>She glanced at his computer screen to see what he was watching</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>单词</tag>
      </tags>
  </entry>
  <entry>
    <title>go big or go home-38</title>
    <url>/2020/04/22/go-big-or-go-home-38/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>单词/短语</th>
<th>中文</th>
<th>句子</th>
</tr>
</thead>
<tbody><tr>
<td>call on</td>
<td>拜访</td>
<td>The family called on their neighbor on Christmas Day</td>
</tr>
<tr>
<td>dawn</td>
<td>黎明</td>
<td>The rooster standing on the field crows at dawn</td>
</tr>
<tr>
<td>laughter</td>
<td>笑</td>
<td>The hall is filled with the laughter of the audience</td>
</tr>
<tr>
<td>zip</td>
<td>拉链</td>
<td>I zip up my jeans pocket to keep my money safe</td>
</tr>
<tr>
<td>comprehension</td>
<td>理解力</td>
<td>There guys must have a high level of comprehension to understand this</td>
</tr>
<tr>
<td>shape</td>
<td>形状</td>
<td>The candle on the birthday cake is in the shape of a seven</td>
</tr>
<tr>
<td>grasp</td>
<td>抓住</td>
<td>The baby grasped mother’s finger</td>
</tr>
<tr>
<td>film</td>
<td>电影</td>
<td>The film has a happy ending</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>单词</tag>
      </tags>
  </entry>
  <entry>
    <title>go big or go home-39</title>
    <url>/2020/04/23/go-big-or-go-home-39/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>单词/短语</th>
<th>中文</th>
<th>句子</th>
</tr>
</thead>
<tbody><tr>
<td>account</td>
<td>账户</td>
<td>-</td>
</tr>
<tr>
<td>feature</td>
<td>特点</td>
<td>-</td>
</tr>
<tr>
<td>transaction</td>
<td>交易</td>
<td>-</td>
</tr>
<tr>
<td>fee</td>
<td>花费</td>
<td>-</td>
</tr>
<tr>
<td>insurance</td>
<td>保险</td>
<td>-</td>
</tr>
<tr>
<td>deposit</td>
<td>存款</td>
<td>-</td>
</tr>
<tr>
<td>receipt</td>
<td>收据</td>
<td>-</td>
</tr>
<tr>
<td>cash</td>
<td>现金</td>
<td>-</td>
</tr>
<tr>
<td>try sth out</td>
<td>试验</td>
<td>I’m going to try out my new experiment on some mice</td>
</tr>
<tr>
<td>the United Nations</td>
<td>联合国(UN)</td>
<td>The United Nations play a positive role in guarding world peace</td>
</tr>
<tr>
<td>ring</td>
<td>戒指</td>
<td>The design of her rings is very interesting and unique</td>
</tr>
<tr>
<td>lovely</td>
<td>可爱的</td>
<td>The baby had lovely eyes</td>
</tr>
<tr>
<td>less</td>
<td>更少的</td>
<td>It seems that every day I have less and less money</td>
</tr>
<tr>
<td>hang up</td>
<td>挂断电话</td>
<td>Hang up to end the call</td>
</tr>
<tr>
<td>breast</td>
<td>乳房</td>
<td>She held her baby to her breast to give some milk</td>
</tr>
<tr>
<td>library</td>
<td>图书馆</td>
<td>I found three books in the library to read</td>
</tr>
<tr>
<td>unfair</td>
<td>不公平的</td>
<td>It is so unfair that his starting line is ahead of the others</td>
</tr>
<tr>
<td>paint</td>
<td>粉饰</td>
<td>The woman is painting the wall blue</td>
</tr>
<tr>
<td>northeast</td>
<td>东北的</td>
<td>These states are located in the northeast of the United States</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>单词</tag>
      </tags>
  </entry>
  <entry>
    <title>go big or go home-40</title>
    <url>/2020/04/24/go-big-or-go-home-40/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>单词/短语</th>
<th>中文</th>
<th>句子</th>
</tr>
</thead>
<tbody><tr>
<td>playroom</td>
<td>游戏室</td>
<td>A playroom is a room in a house for children to play in</td>
</tr>
<tr>
<td>refresh</td>
<td>恢复精神</td>
<td>He had a cup of coffee to refresh himself</td>
</tr>
<tr>
<td>spiritual</td>
<td>精神的</td>
<td>Living a simple life,she devoted herself to the pursuit of spiritual world</td>
</tr>
<tr>
<td>assumption</td>
<td>假设</td>
<td>Having a baby is just their assumption</td>
</tr>
<tr>
<td>strait</td>
<td>海峡</td>
<td>This important strait,which joins two seas,is called the Strait of Hormuz</td>
</tr>
<tr>
<td>situation</td>
<td>形势</td>
<td>The general is analyzing the current situation of the war</td>
</tr>
<tr>
<td>algebra</td>
<td>代数</td>
<td>Letters such as x and y are used to represent unknown quantities in algebra</td>
</tr>
<tr>
<td>In other words</td>
<td>换句话说</td>
<td>Time is money.In other words,saving time means saving money</td>
</tr>
<tr>
<td>turning</td>
<td>转弯处</td>
<td>Slow down before turnings</td>
</tr>
<tr>
<td>depend on</td>
<td>依赖</td>
<td>My grandma has to depend on a wheelchair</td>
</tr>
<tr>
<td>two-time</td>
<td>劈腿</td>
<td>-</td>
</tr>
<tr>
<td>Gossip</td>
<td>花边新闻</td>
<td>-</td>
</tr>
<tr>
<td>Third wheel</td>
<td>”电灯泡“</td>
<td>-</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>单词</tag>
      </tags>
  </entry>
  <entry>
    <title>go big or go home-4</title>
    <url>/2020/03/19/go-big-or-go-home-4/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>单词/短语</th>
<th>中文</th>
<th>句子</th>
</tr>
</thead>
<tbody><tr>
<td>desperate</td>
<td>绝望的</td>
<td>The unemployed man looks so desperate</td>
</tr>
<tr>
<td>beyond</td>
<td>更远的/超出…能力</td>
<td>The birds flew far beyond the land’s edge</td>
</tr>
<tr>
<td>in need of</td>
<td>需要</td>
<td>The dry field is in need of rain</td>
</tr>
<tr>
<td>gesture</td>
<td>手势</td>
<td>This gesture means you are very good</td>
</tr>
<tr>
<td>production</td>
<td>生产</td>
<td>Thousands of cars are under production</td>
</tr>
<tr>
<td>pregnant</td>
<td>怀孕的</td>
<td>The pregnant woman is drinking water</td>
</tr>
<tr>
<td>complain</td>
<td>抱怨</td>
<td>She complains that the homework is difficult</td>
</tr>
<tr>
<td>unemployed</td>
<td>失业</td>
<td>Have you been unemployed for over six months?</td>
</tr>
<tr>
<td>edge</td>
<td>边缘</td>
<td>He edged closer to the telephone, ready to grab it</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>单词</tag>
      </tags>
  </entry>
  <entry>
    <title>go big or go home-41</title>
    <url>/2020/04/25/go-big-or-go-home-41/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>单词/短语</th>
<th>中文</th>
<th>句子</th>
</tr>
</thead>
<tbody><tr>
<td>cow</td>
<td>奶牛</td>
<td>Cows provide us with delicious beef and milk</td>
</tr>
<tr>
<td>world-famous</td>
<td>世界著名的</td>
<td>Jack is a world-famous actress</td>
</tr>
<tr>
<td>collection</td>
<td>收藏品</td>
<td>He has a fine collection stamps</td>
</tr>
<tr>
<td>hobby</td>
<td>业务爱好</td>
<td>People have different hobbies;some like reading books and some like playing football</td>
</tr>
<tr>
<td>extremely</td>
<td>非常</td>
<td>He was extremely tired because he had worked all night</td>
</tr>
<tr>
<td>wall</td>
<td>墙</td>
<td>This wall is made up of oddly shaped bricks</td>
</tr>
<tr>
<td>set off</td>
<td>出发</td>
<td>The pirates set off from the island</td>
</tr>
<tr>
<td>break in</td>
<td>进入</td>
<td>Without keys for the door,the man is trying to break in through the window</td>
</tr>
<tr>
<td>Switzerland</td>
<td>瑞士</td>
<td>There are many snowy mountains in Switzerland.It’s so cold!</td>
</tr>
<tr>
<td>port</td>
<td>港口</td>
<td>There are hundreds of containers in the port</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>单词</tag>
      </tags>
  </entry>
  <entry>
    <title>go big or go home-5</title>
    <url>/2020/03/20/go-big-or-go-home-5/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>单词/短语</th>
<th>中文</th>
<th>句子</th>
</tr>
</thead>
<tbody><tr>
<td>foreign</td>
<td>外国的</td>
<td>Do you work in foreign company?</td>
</tr>
<tr>
<td>recite</td>
<td>背诵</td>
<td>Do you think it difficult to recite English words?</td>
</tr>
<tr>
<td>normally</td>
<td>通常情况下</td>
<td>Normally,how often do you play basketball?</td>
</tr>
<tr>
<td>basketball court</td>
<td>篮球场</td>
<td>There is a baskerball court in my neighborhood</td>
</tr>
<tr>
<td>facility</td>
<td>设施</td>
<td>There is the facility you need</td>
</tr>
<tr>
<td>football/soccer</td>
<td>在美式英语中football是橄榄球，足球用soccer</td>
<td>I play football twice a week</td>
</tr>
<tr>
<td>volleyball</td>
<td>排球</td>
<td>When I was in college,I was the caption of the volleyball team</td>
</tr>
<tr>
<td>badminton</td>
<td>羽毛球</td>
<td>LinDan played badminton very well</td>
</tr>
<tr>
<td>hockey</td>
<td>曲棍球</td>
<td>Hockey is very popular in the United States</td>
</tr>
<tr>
<td>skating</td>
<td>滑冰</td>
<td>In winter,I like playing skating and skiing</td>
</tr>
<tr>
<td>skiing</td>
<td>滑雪</td>
<td>In winter,I like playing skating and skiing</td>
</tr>
<tr>
<td>athlete</td>
<td>运动员</td>
<td>You will be a good athlete</td>
</tr>
<tr>
<td>athletic</td>
<td>爱运动的</td>
<td>You are athletic</td>
</tr>
<tr>
<td>act</td>
<td>行动</td>
<td>This is the time for acting</td>
</tr>
<tr>
<td>heat</td>
<td>高温</td>
<td>Warm the milk to blood heat</td>
</tr>
<tr>
<td>components</td>
<td>零件</td>
<td>These are the components of the car</td>
</tr>
<tr>
<td>join up</td>
<td>参军</td>
<td>I want to join the army</td>
</tr>
<tr>
<td>premanent</td>
<td>永久的</td>
<td>He hopes to find a premanent job</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>单词</tag>
      </tags>
  </entry>
  <entry>
    <title>go big or go home-6</title>
    <url>/2020/03/21/go-big-or-go-home-6/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>单词/短语</th>
<th>中文</th>
<th>句子</th>
</tr>
</thead>
<tbody><tr>
<td>altogether</td>
<td>合计</td>
<td>These gifts cost me 1000 dollars altogether</td>
</tr>
<tr>
<td>salt</td>
<td>盐</td>
<td>Adding salt gives the dish more flavor</td>
</tr>
<tr>
<td>smog</td>
<td>烟雾</td>
<td>There is too much smog in this big city</td>
</tr>
<tr>
<td>not till</td>
<td>直到…才</td>
<td>Not till eight o’clock dit I get up</td>
</tr>
<tr>
<td>stand for</td>
<td>代表</td>
<td>The sign stands for a bicycle path</td>
</tr>
<tr>
<td>zoom</td>
<td>拉近</td>
<td>The creama zoomed in on the child’s face</td>
</tr>
<tr>
<td>cordless</td>
<td>不用电线的</td>
<td>A cordless mouse is convenient for using your computer</td>
</tr>
<tr>
<td>spaceship</td>
<td>宇宙飞船</td>
<td>At last,the spaceship landed on the moon</td>
</tr>
<tr>
<td>cover</td>
<td>盖住</td>
<td>He covers his face with glasses and a face mask</td>
</tr>
<tr>
<td>umbrella</td>
<td>雨伞</td>
<td>The dog uses an umbrella to block the sun</td>
</tr>
<tr>
<td>presentation</td>
<td>科学的</td>
<td>The student is giving a presentation about how to roll the dough scientifically</td>
</tr>
<tr>
<td>backache</td>
<td>背痛</td>
<td>Since I got an office job,my backache has gotton much worse</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>单词</tag>
      </tags>
  </entry>
  <entry>
    <title>go big or go home-7</title>
    <url>/2020/03/22/go-big-or-go-home-7/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>单词/短语</th>
<th>中文</th>
<th>句子</th>
</tr>
</thead>
<tbody><tr>
<td>present</td>
<td>当下</td>
<td>Are you happy with your present job?</td>
</tr>
<tr>
<td>take out</td>
<td>取出</td>
<td>He takes out some money from his wallet</td>
</tr>
<tr>
<td>dining</td>
<td>吃饭</td>
<td>The couple enjoyed dining under candlelight</td>
</tr>
<tr>
<td>tired</td>
<td>疲劳的</td>
<td>He was extremely tired beacause he had worked all night</td>
</tr>
<tr>
<td>make a sentence</td>
<td>造句</td>
<td>Can you use these words to make sentences?</td>
</tr>
<tr>
<td>dangerous</td>
<td>危险的</td>
<td>It‘s dangerous near by him</td>
</tr>
<tr>
<td>beamed</td>
<td>喜出望外的</td>
<td>The children’s faces beamed with happy smiles</td>
</tr>
<tr>
<td>hunting</td>
<td>狩猎/寻找</td>
<td>Are you hunting for a new job?</td>
</tr>
<tr>
<td>logic</td>
<td>逻辑</td>
<td>by your own speaking logic</td>
</tr>
<tr>
<td>Nope</td>
<td>同no</td>
<td>No的洋（装）气（逼）的说法</td>
</tr>
<tr>
<td>memory</td>
<td>记忆力</td>
<td>You have a good memory</td>
</tr>
<tr>
<td>internship</td>
<td>实习</td>
<td>I had an internship when I was a junior student</td>
</tr>
<tr>
<td>finish</td>
<td>完成</td>
<td>I need to finish my studies</td>
</tr>
<tr>
<td>salary</td>
<td>薪水</td>
<td>They offer more salary</td>
</tr>
<tr>
<td>platform</td>
<td>平台</td>
<td>Bigger platform</td>
</tr>
<tr>
<td>stage</td>
<td>舞台</td>
<td>Bigger stage</td>
</tr>
<tr>
<td>opportunities</td>
<td>机会</td>
<td>more opportunities</td>
</tr>
<tr>
<td>intention</td>
<td>意图</td>
<td>I have every intention of buying a house,so I must start saving now</td>
</tr>
<tr>
<td>geometry</td>
<td>几何</td>
<td>Geometry is study dealing with different kinds of shapes</td>
</tr>
<tr>
<td>tractor</td>
<td>拖拉机</td>
<td>We use tractors to farm</td>
</tr>
<tr>
<td>adequate</td>
<td>充足的</td>
<td>I have prepared an adequate amount of food for 5 people</td>
</tr>
<tr>
<td>delicate</td>
<td>易碎的</td>
<td>The vase is delicate and should be moved with care</td>
</tr>
<tr>
<td>drop</td>
<td>下落</td>
<td>A drop of water was about to fall</td>
</tr>
<tr>
<td>beast</td>
<td>野兽</td>
<td>Lions,tigers,wolves and leopards are examples of dangerous,wild beasts</td>
</tr>
<tr>
<td>pulse</td>
<td>脉搏</td>
<td>The docter takes the patient’s pulse to determine his illness</td>
</tr>
<tr>
<td>repeat</td>
<td>重复</td>
<td>The bird is repeating what the girl says</td>
</tr>
<tr>
<td>scientifically</td>
<td>科学地</td>
<td>scientifically</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>单词</tag>
      </tags>
  </entry>
  <entry>
    <title>go big or go home-8</title>
    <url>/2020/03/23/go-big-or-go-home-8/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>单词/短语</th>
<th>中文</th>
<th>句子</th>
</tr>
</thead>
<tbody><tr>
<td>fit</td>
<td>匹配</td>
<td>They two are a perfect fit and I’m sure they are good friends</td>
</tr>
<tr>
<td>insure</td>
<td>为…投保</td>
<td>He insures the car against traffic accidents</td>
</tr>
<tr>
<td>ring sb. back</td>
<td>回电话</td>
<td>Oh,I missed a call from my mother.I’ll ring her back</td>
</tr>
<tr>
<td>try sth. out</td>
<td>试验</td>
<td>I’m going to try out my new experiment on some mice</td>
</tr>
<tr>
<td>come off</td>
<td>从…掉下</td>
<td>She looks surprised when her facial mask comes off her face</td>
</tr>
<tr>
<td>postbox</td>
<td>邮箱</td>
<td>I take letters out from the postbox everyday</td>
</tr>
<tr>
<td>over and over again</td>
<td>重复多次</td>
<td>He said no over and over again</td>
</tr>
<tr>
<td>questionnaire</td>
<td>调查问卷</td>
<td>Please complete this questionnaire</td>
</tr>
<tr>
<td>savage</td>
<td>野蛮人</td>
<td>Their wordy conversion made me feel like a total savage</td>
</tr>
<tr>
<td>wallet</td>
<td>口袋</td>
<td>He takes out some money from his wallet</td>
</tr>
<tr>
<td>platform</td>
<td>平台</td>
<td>Bigger platform</td>
</tr>
<tr>
<td>says</td>
<td>说的话</td>
<td>The bird is repeating what the girl says</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>单词</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode208</title>
    <url>/2019/10/20/leetcode208/</url>
    <content><![CDATA[<p>实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。</p>
<p>示例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Trie trie = <span class="keyword">new</span> Trie();</span><br><span class="line"></span><br><span class="line">trie.insert(<span class="string">"apple"</span>);</span><br><span class="line">trie.search(<span class="string">"apple"</span>);   <span class="comment">// 返回 true</span></span><br><span class="line">trie.search(<span class="string">"app"</span>);     <span class="comment">// 返回 false</span></span><br><span class="line">trie.startsWith(<span class="string">"app"</span>); <span class="comment">// 返回 true</span></span><br><span class="line">trie.insert(<span class="string">"app"</span>);   </span><br><span class="line">trie.search(<span class="string">"app"</span>);     <span class="comment">// 返回 true</span></span><br></pre></td></tr></table></figure>

<p>说明:你可以假设所有的输入都是由小写字母 a-z 构成的。<br>保证所有输入均为非空字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TrieNode[] children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isWord;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        TrieNode node = <span class="keyword">new</span> TrieNode();</span><br><span class="line">        node.val = c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initialize your data structure here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">        root.val = <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts a word into the trie.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode t = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (t.children[c - <span class="string">'a'</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                t.children[c - <span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode(c);</span><br><span class="line">            &#125;</span><br><span class="line">            t = t.children[c - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        t.isWord = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns if the word is in the trie.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode t = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (t.children[c - <span class="string">'a'</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            t = t.children[c - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t.isWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns if there is any word in the trie that starts with the given prefix.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode t = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;prefix.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = prefix.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (t.children[c - <span class="string">'a'</span>] == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            t = t.children[c - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Trie obj = <span class="keyword">new</span> Trie();</span><br><span class="line">        obj.insert(<span class="string">"trie"</span>);</span><br><span class="line">        <span class="keyword">boolean</span> param_2 = obj.search(<span class="string">"trie"</span>);</span><br><span class="line">        <span class="keyword">boolean</span> param_3 = obj.startsWith(<span class="string">"trie"</span>);</span><br><span class="line">        System.out.println(param_2);</span><br><span class="line">        System.out.println(param_3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Trie树</tag>
        <tag>leetcode208</tag>
      </tags>
  </entry>
  <entry>
    <title>go big or go home-9</title>
    <url>/2020/03/24/go-big-or-go-home-9/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>单词/短语</th>
<th>中文</th>
<th>句子</th>
</tr>
</thead>
<tbody><tr>
<td>actual</td>
<td>实际的</td>
<td>The actual fact is that crocodiles walk underwater instead of swimming</td>
</tr>
<tr>
<td>master</td>
<td>主人</td>
<td>The dog and its master are close to each other</td>
</tr>
<tr>
<td>fridge</td>
<td>电冰箱</td>
<td>I opened the fridge to get some food</td>
</tr>
<tr>
<td>bone</td>
<td>骨头</td>
<td>“I really want to eat some bones” the dog said</td>
</tr>
<tr>
<td>represent</td>
<td>代表</td>
<td>This hand gesture represents love</td>
</tr>
<tr>
<td>modest</td>
<td>谦虚的</td>
<td>These two businssmen may be rich,but they’re still very modest</td>
</tr>
<tr>
<td>ox</td>
<td>牛/公牛</td>
<td>The strong ox is angry now</td>
</tr>
<tr>
<td>nut</td>
<td>坚果</td>
<td>Nuts are a source of vitamin E for the body</td>
</tr>
<tr>
<td>facial</td>
<td>面部</td>
<td>She looks surprized when her facial mask comes off her face</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>单词</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode338</title>
    <url>/2019/10/20/leetcode338/</url>
    <content><![CDATA[<p>给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="number">2</span></span><br><span class="line">输出: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">输入: <span class="number">5</span></span><br><span class="line">输出: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<p>进阶:<br>给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？<br>要求算法的空间复杂度为O(n)。<br>你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount）来执行此操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[num+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">            result[i] = result[i&amp;(i-<span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ints = <span class="keyword">new</span> Solution().countBits(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : ints)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最主要的是i&amp;(i-1)是将二进制的最后的1去掉，举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">24</span>的二进制是<span class="number">11000</span></span><br><span class="line"><span class="number">24</span>-<span class="number">1</span>=<span class="number">23</span>的二进制是<span class="number">10111</span></span><br><span class="line"><span class="number">11000</span>&amp;<span class="number">10111</span> = <span class="number">10000</span></span><br><span class="line">这样就把<span class="number">24</span>的最后的<span class="number">1</span>去掉了 </span><br><span class="line">result[i] = result[i&amp;(i-<span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">首先i&amp;(i-<span class="number">1</span>)一定比i小，所以这段代码可以保证result[i&amp;(i-<span class="number">1</span>)]一定是之前计算过的，然后在后面加上<span class="number">1</span>就是一共有的<span class="number">1</span>的个数</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode338</tag>
        <tag>二进制数</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode79</title>
    <url>/2019/10/20/leetcode79/</url>
    <content><![CDATA[<p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<p>示例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">board =</span><br><span class="line">[</span><br><span class="line">  [<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'E'</span>],</span><br><span class="line">  [<span class="string">'S'</span>,<span class="string">'F'</span>,<span class="string">'C'</span>,<span class="string">'S'</span>],</span><br><span class="line">  [<span class="string">'A'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">给定 word = <span class="string">"ABCCED"</span>, 返回 <span class="keyword">true</span>.</span><br><span class="line">给定 word = <span class="string">"SEE"</span>, 返回 <span class="keyword">true</span>.</span><br><span class="line">给定 word = <span class="string">"ABCB"</span>, 返回 <span class="keyword">false</span>.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] row = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] column = &#123;<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>,rowLen = board.length;i&lt;rowLen;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>,columnLen = board[<span class="number">0</span>].length;j&lt;columnLen;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (dfs(board,word,i,j,<span class="number">0</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board,String word,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x&lt;<span class="number">0</span> || x&gt;=board.length || y&lt;<span class="number">0</span> || y&gt;=board[<span class="number">0</span>].length) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(board[x][y] != word.charAt(index)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(index == word.length() - <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        board[x][y] = <span class="string">'#'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (dfs(board,word,x+row[i],y+column[i],index+<span class="number">1</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[x][y] = word.charAt(index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[][] borad = &#123;&#123;<span class="string">'F'</span>,<span class="string">'Y'</span>,<span class="string">'C'</span>,<span class="string">'E'</span>,<span class="string">'N'</span>,<span class="string">'R'</span>,<span class="string">'D'</span>&#125;,&#123;<span class="string">'K'</span>,<span class="string">'L'</span>,<span class="string">'N'</span>,<span class="string">'F'</span>,<span class="string">'I'</span>,<span class="string">'N'</span>,<span class="string">'U'</span>&#125;,&#123;<span class="string">'A'</span>,<span class="string">'A'</span>,<span class="string">'A'</span>,<span class="string">'R'</span>,<span class="string">'A'</span>,<span class="string">'H'</span>,<span class="string">'R'</span>&#125;,&#123;<span class="string">'N'</span>,<span class="string">'D'</span>,<span class="string">'K'</span>,<span class="string">'L'</span>,<span class="string">'P'</span>,<span class="string">'N'</span>,<span class="string">'E'</span>&#125;,&#123;<span class="string">'A'</span>,<span class="string">'L'</span>,<span class="string">'A'</span>,<span class="string">'N'</span>,<span class="string">'S'</span>,<span class="string">'A'</span>,<span class="string">'P'</span>&#125;,&#123;<span class="string">'O'</span>,<span class="string">'O'</span>,<span class="string">'G'</span>,<span class="string">'O'</span>,<span class="string">'T'</span>,<span class="string">'P'</span>,<span class="string">'N'</span>&#125;,&#123;<span class="string">'H'</span>,<span class="string">'P'</span>,<span class="string">'O'</span>,<span class="string">'L'</span>,<span class="string">'A'</span>,<span class="string">'N'</span>,<span class="string">'O'</span>&#125;&#125;;</span><br><span class="line">        String word= <span class="string">"poland"</span>;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().exist(borad,word));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要说明一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">board[x][y] = <span class="string">'#'</span>;</span><br></pre></td></tr></table></figure>

<p>是将已经查找过的做一个标记，以及</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] row = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] column = &#123;<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>这段代码是指向四周遍历的坐标点。深度遍历的时候会经常用到，本道题用到了深度优先遍历和回溯。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>二维网格</tag>
        <tag>leetcode79</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL一条sql查询语句是如何执行的?</title>
    <url>/2019/10/20/mysql%E4%B8%80%E6%9D%A1sql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/</url>
    <content><![CDATA[<p>[2019-10-13，2019-10-20]周计划：</p>
<p>1⃣️三道leetcode中等难度算法题<br>2⃣️MySQL实战45讲-基础篇1，2，3讲<br>3⃣️周六，日总结，写博客</p>
<p>本周学习了极客时间的MySQL实战45讲一课，本篇做一个总结。<br>先看一个普通的查询语句  </p>
<p><code>select * from user where id = 1</code>  </p>
<p>这条语句的执行过程是什么样的呢？废话不多说先上图：<br><img src="../image/MySQL.png" alt="MySQL.png" title="MySQL"><br>大体来说MySQL可以分为server层和引擎层两部分，server层包括连接器，查询缓存，分析器，优化器，查询器等，覆盖MySQL的绝大多数核心服务功能，包括内置函数，存储过程，触发器，视图等都是在这一层实现的。<br>而引擎层则是负责数据的存储和提取，其架构模式是插件式的，比如InnoDB，MyISAM，Memory等多个存储引擎，现在最常用的是InnoDB，在MySQL5.5.5版本成为了默认引擎。接下来具体介绍一下每一个部分的作用：  </p>
<h3 id="1⃣️连接器："><a href="#1⃣️连接器：" class="headerlink" title="1⃣️连接器："></a>1⃣️连接器：</h3><p>如果要使用MySQL首先要做的事与MySQL建立连接，输入账户密码MySQL会到连接器中对该账号进行权限的验证，以后的所有操作都基于此时的权限，及时在这段时间管理员对你的账号修改了权限也不会影响到本次连接的其他操作。同时这里涉及到了长链接与短链接，大家知道与数据库的连接是比较消耗资源的，所以要尽可能的在一次连接做尽量多的事，不让资源浪费，这就是长链接，客户端如果太长时间没有操作，连接器会自动将它断开，这是wait_timeout控制的，默认是8个小时，当然可以根据自己的业务场景进行修改，综上所述更推荐使用长链接。  </p>
<h3 id="2⃣️查询缓存："><a href="#2⃣️查询缓存：" class="headerlink" title="2⃣️查询缓存："></a>2⃣️查询缓存：</h3><p>通过了连接器就可以到下一步，也就是查询缓存了，大多数情况下并不推荐使用查询缓存，为什么呢？<br>我们先来了解下查询缓存的工作原理，其实MySQL会把执行过的查询语句以key-value的形式储存起来，key是查询语句，value是结果，如果在查询缓存中可以找到匹配的key那么直接返回value，但有人说这不是很方便吗提高了查询速度，为什么不推荐使用呢？因为不仅仅存储这些语句和结果需要占用空间，还有个最关键的原因是当有任何对某张表的更新那么基于这张表的所有查询缓存全部清空，除非你是有一张静态表，很长时间不更新那么可以使用查询缓存。<br>使用方式？只需要设置参数query_cache_type（0—&gt;关闭，1—&gt;开始，2—&gt;只有在执行查询语句时，显示指定开始如下例子）</p>
<p><code>select SQL_CACHE * form user where id = 1</code>  </p>
<h3 id="3⃣️分析器："><a href="#3⃣️分析器：" class="headerlink" title="3⃣️分析器："></a>3⃣️分析器：</h3><p>如果没有命中查询缓存就要真正开始执行语句了，首先MySQL要知道你执行的是什么操作，分析器会先做词法分析，你输入的是一串字符串，MySQL会识别出关键词比如select，那么MySQL会知道这是一条查询语句，在把user识别为表名，当然也会有写错的时候，那么语法错误就是在这一层做的。</p>
<h3 id="4⃣️优化器："><a href="#4⃣️优化器：" class="headerlink" title="4⃣️优化器："></a>4⃣️优化器：</h3><p>通过了分析器证明sql语句写的没有问题，那么MySQL会根据你写的语句在内部做一个优化，是在有多个索引的时候进行比较，提到索引，可能大家都知道最左前缀原则，比如user表有联合索引 ‘A_B’ 当查询语句为下面这样时：  </p>
<p><code>select name from user where B = 10</code>  </p>
<p>这样写的话并不会命中索引是因为没有满足最左前缀原则，但如果我把语句改成：  </p>
<p><code>select name from user where B = 10 and A = 15</code><br>如果这样写msyql会通过分析器来去寻找索引，发现你的where条件里有A = 15那么MySQL会先执行A = 15这样就会命中索引。  </p>
<h3 id="5⃣️执行器："><a href="#5⃣️执行器：" class="headerlink" title="5⃣️执行器："></a>5⃣️执行器：</h3><p>终于通过重重关卡可以真正去执行语句了，执行的时候会先判断一下是否有这张表的权限（如果命中查询索引，那么会在返回结果是做权限验证），如果有权限就打开表继续执行，拿最开始语句举个例子：<br>(1)默认引擎是InnoDB，调用InnoDB引擎接口取user表的第一行，判断id是不是等于1，如果不是则跳过，如果是则将这行存在结果集中<br>(2)调用引擎接口“下一行”,重复(1)，直到user表的最后一行。<br>(3)执行器将上述遍历过程中所有满足条件的行组成记录集作为结果集返回给客户端。  </p>
<p>至此这个语句就执行完成了。</p>
<h3 id="1⃣️课后问题："><a href="#1⃣️课后问题：" class="headerlink" title="1⃣️课后问题："></a>1⃣️课后问题：</h3><p>比如执行 <code>select * form user where t = 10</code> 如果不存在t这一列，那么一定会报错，这个报错是在哪个阶段报出的？</p>
<p>答：在分析器，MySQL其实很大程度上受了oracle的影响。</p>
<h3 id="2⃣️看课后有同学问了一个问题：为什么对权限的检查不在优化器之前做呢？"><a href="#2⃣️看课后有同学问了一个问题：为什么对权限的检查不在优化器之前做呢？" class="headerlink" title="2⃣️看课后有同学问了一个问题：为什么对权限的检查不在优化器之前做呢？"></a>2⃣️看课后有同学问了一个问题：为什么对权限的检查不在优化器之前做呢？</h3><p>答：有些时候，SQL要操作的表不仅仅是字面上那些，比如有个触发器，得在执行器阶段(过程中)才能确定，优化器前是无能为力的。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql查询语句执行</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>redis系列-Redisson分布式锁验证+踩坑</title>
    <url>/2020/04/05/redis%E7%B3%BB%E5%88%97-Redission%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E9%AA%8C%E8%AF%81-%E8%B8%A9%E5%9D%91/</url>
    <content><![CDATA[<h3 id="本篇来验证一下Redisson框架，分布式锁，底层其实就是Lua脚本，setnx-expire封装原子性操作，上代码"><a href="#本篇来验证一下Redisson框架，分布式锁，底层其实就是Lua脚本，setnx-expire封装原子性操作，上代码" class="headerlink" title="本篇来验证一下Redisson框架，分布式锁，底层其实就是Lua脚本，setnx+expire封装原子性操作，上代码"></a>本篇来验证一下Redisson框架，分布式锁，底层其实就是Lua脚本，setnx+expire封装原子性操作，上代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.redisson&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;redisson&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.11.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>: 秒杀商品接口, 这里为了测试就手动创建三个线程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> JsonObject</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@exception</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> mazhq</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2018/11/18 13:46</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">kill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> time = System.currentTimeMillis() + TIMEOUT;</span><br><span class="line">        RLock lock=</span><br><span class="line">                redissonClient.getLock(KEY);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread a = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    Thread.currentThread().setName(<span class="string">"线程1"</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">boolean</span> isSuccess=lock.tryLock(<span class="number">0</span>,<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">                        <span class="keyword">if</span> (isSuccess)&#123;</span><br><span class="line">                            log.info(Thread.currentThread().getName()+<span class="string">"获得锁，开始秒杀"</span>);</span><br><span class="line">                            redisUtil.sub(KEY_NUM);</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            log.info(Thread.currentThread().getName()+<span class="string">"强锁失败"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        log.info(Thread.currentThread().getName()+<span class="string">"强锁异常"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            Thread b = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    Thread.currentThread().setName(<span class="string">"线程2"</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">boolean</span> isSuccess=lock.tryLock(<span class="number">0</span>,<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">                        <span class="keyword">if</span> (isSuccess)&#123;</span><br><span class="line">                            log.info(Thread.currentThread().getName()+<span class="string">"获得锁，开始秒杀"</span>);</span><br><span class="line">                            redisUtil.sub(KEY_NUM);</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            log.info(Thread.currentThread().getName()+<span class="string">"强锁失败"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        log.info(Thread.currentThread().getName()+<span class="string">"强锁异常"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            Thread c = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    Thread.currentThread().setName(<span class="string">"线程3"</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">boolean</span> isSuccess=lock.tryLock(<span class="number">0</span>,<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">                        <span class="keyword">if</span> (isSuccess)&#123;</span><br><span class="line">                            log.info(Thread.currentThread().getName()+<span class="string">"获得锁，开始秒杀"</span>);</span><br><span class="line">                            redisUtil.sub(KEY_NUM);</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            log.info(Thread.currentThread().getName()+<span class="string">"强锁失败"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        log.info(Thread.currentThread().getName()+<span class="string">"强锁异常"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            a.start();</span><br><span class="line">            b.start();</span><br><span class="line">            c.start();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            log.info(<span class="string">"--------"</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"111"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String key,String num)</span></span>&#123;</span><br><span class="line">        ValueOperations&lt;String, String&gt; opsForValue</span><br><span class="line">                =stringRedisTemplate.opsForValue();</span><br><span class="line">        opsForValue.set(key,num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 库存减1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sub</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().increment(key, -<span class="number">1</span>);</span><br><span class="line">        log.info(<span class="string">"当前剩余库存"</span>+stringRedisTemplate.opsForValue().get(key));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="重点是RedissonClinet如何注入，如果不手动配置的话会出现注入Bean失败-这篇博客写的很详细，可以看一下"><a href="#重点是RedissonClinet如何注入，如果不手动配置的话会出现注入Bean失败-这篇博客写的很详细，可以看一下" class="headerlink" title="重点是RedissonClinet如何注入，如果不手动配置的话会出现注入Bean失败,这篇博客写的很详细，可以看一下"></a>重点是RedissonClinet如何注入，如果不手动配置的话会出现注入Bean失败,这篇博客写的很详细，可以看一下</h3><p><a href="https://blog.csdn.net/zilong_zilong/article/details/78252037" target="_blank" rel="noopener">https://blog.csdn.net/zilong_zilong/article/details/78252037</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里使用了单节点，还有集群模式，哨兵模式，种类很多config.useSingleServer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedissonClinetConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedissonClient <span class="title">redissonClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Config config=<span class="keyword">new</span> Config();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">"redis://127.0.0.1:6379"</span>)</span><br><span class="line">                .setConnectionPoolSize(<span class="number">500</span>)</span><br><span class="line">                .setIdleConnectionTimeout(<span class="number">10000</span>)</span><br><span class="line">                .setConnectTimeout(<span class="number">30000</span>)</span><br><span class="line">                .setTimeout(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">        RedissonClient redisson=Redisson.create(config);</span><br><span class="line">        <span class="keyword">return</span> redisson;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="先将key-num-设置为10000，然后在postman上调用请求，这里设置为20次，间隔1s，正好与锁的过期时间一致，保证三个线程里每次都有秒杀成功"><a href="#先将key-num-设置为10000，然后在postman上调用请求，这里设置为20次，间隔1s，正好与锁的过期时间一致，保证三个线程里每次都有秒杀成功" class="headerlink" title="先将key-num 设置为10000，然后在postman上调用请求，这里设置为20次，间隔1s，正好与锁的过期时间一致，保证三个线程里每次都有秒杀成功"></a>先将key-num 设置为10000，然后在postman上调用请求，这里设置为20次，间隔1s，正好与锁的过期时间一致，保证三个线程里每次都有秒杀成功</h3><p><img src="../image/kill.png" alt="kill.png" title="kill"></p>
<p><img src="../image/begin.png" alt="begin.png" title="begin"></p>
<p><img src="../image/end.png" alt="end.png" title="end"></p>
<h3 id="我们来验证下"><a href="#我们来验证下" class="headerlink" title="我们来验证下"></a>我们来验证下</h3><p><img src="../image/check.png" alt="check.png" title="check"></p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis分布式锁</tag>
        <tag>Redisson框架</tag>
      </tags>
  </entry>
  <entry>
    <title>redis系列-实现一个延时消费队列</title>
    <url>/2020/04/05/redis%E7%B3%BB%E5%88%97-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BB%B6%E6%97%B6%E6%B6%88%E8%B4%B9%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h3 id="用Zset和Hash实现一个延时队列，话不多说，附上代码"><a href="#用Zset和Hash实现一个延时队列，话不多说，附上代码" class="headerlink" title="用Zset和Hash实现一个延时队列，话不多说，附上代码"></a>用Zset和Hash实现一个延时队列，话不多说，附上代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertToRank</span><span class="params">(String id, String msg, String isNow)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> score=<span class="keyword">this</span>.getScore(isNow);</span><br><span class="line">        String uuid=UUID.randomUUID().toString().replaceAll(<span class="string">"-"</span>, <span class="string">""</span>);</span><br><span class="line">        HashOperations&lt;String, Object, Object&gt; opsForHash=</span><br><span class="line">                stringRedisTemplate.opsForHash();</span><br><span class="line">        Map&lt;String, String&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"id"</span>, id);</span><br><span class="line">        map.put(<span class="string">"msg"</span>, msg);</span><br><span class="line">        opsForHash.putAll(Constant.KEY_HASH + uuid, map);</span><br><span class="line">        <span class="keyword">this</span>.insertZset(uuid, score);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入zset，按照score排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> score</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertZset</span><span class="params">(String key, <span class="keyword">double</span> score)</span> </span>&#123;</span><br><span class="line">        ZSetOperations&lt;String, String&gt; opsForZSet=</span><br><span class="line">                stringRedisTemplate.opsForZSet();</span><br><span class="line">        opsForZSet.add(Constant.KEY_ZSET, key, score);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isNow is时表示实时消息，放入zset前面</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">getScore</span><span class="params">(String isNow)</span> </span>&#123;</span><br><span class="line">        Date nowTime=<span class="keyword">new</span> Date(System.currentTimeMillis());</span><br><span class="line">        SimpleDateFormat simpleDateFormat=<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMddHHmmss"</span>);</span><br><span class="line">        String now=simpleDateFormat.format(nowTime);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"is"</span>.equals(isNow)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Double.parseDouble(now.substring(<span class="number">0</span>, <span class="number">12</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Double.parseDouble(now);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抢锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeOut</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(String key, String value, <span class="keyword">long</span> timeOut)</span> </span>&#123;</span><br><span class="line">        Boolean isSuccess=stringRedisTemplate.opsForValue().setIfAbsent(key, value);</span><br><span class="line">        <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">            stringRedisTemplate.expire(key, timeOut, TimeUnit.MINUTES);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSuccess;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delLock</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        stringRedisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取zset第一条数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirstData</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        ZSetOperations&lt;String, String&gt; opsForZSet=stringRedisTemplate.opsForZSet();</span><br><span class="line">        Set&lt;String&gt; range=opsForZSet.range(key, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty(range)) &#123;</span><br><span class="line">            String uuid = range.iterator().next();</span><br><span class="line">            opsForZSet.remove(key,uuid);</span><br><span class="line">            <span class="keyword">return</span> uuid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询当前Zset多少个数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getZsetSize</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stringRedisTemplate.opsForZSet().zCard(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取hash数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title">getHashData</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        HashOperations&lt;String, Object, Object&gt; opsForHash=stringRedisTemplate.opsForHash();</span><br><span class="line">        Object id=opsForHash.get(key, <span class="string">"id"</span>);</span><br><span class="line">        Object msg=opsForHash.get(key, <span class="string">"msg"</span>);</span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"id"</span>,id);</span><br><span class="line">        map.put(<span class="string">"msg"</span>,msg);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(CountDownLatch countDownLatch,String uuid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Map&lt;String, Object&gt; hashData=<span class="keyword">this</span>.getHashData(Constant.KEY_HASH + uuid);</span><br><span class="line">            log.info(<span class="string">"开始发送"</span>+hashData.get(<span class="string">"id"</span>)+<span class="string">"消息: "</span>+hashData.get(<span class="string">"msg"</span>));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            log.info(<span class="string">"e:&#123;&#125;"</span>,e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String key,String num)</span></span>&#123;</span><br><span class="line">        ValueOperations&lt;String, String&gt; opsForValue</span><br><span class="line">                =stringRedisTemplate.opsForValue();</span><br><span class="line">        opsForValue.set(key,num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sub</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().increment(key, -<span class="number">1</span>);</span><br><span class="line">        log.info(<span class="string">"当前剩余库存"</span>+stringRedisTemplate.opsForValue().get(key));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用定时任务去消费，这里有一个问题，对定时任务使用分布式锁是为了避免定时任务如果部署在两台机器上重复执行，保证每次只有一台机器执行，但有个问题，如果是Redis-Cluster模式是没有问题，但如果是哨兵模式或者一主二从模式，slave是不允许写入的，因为我们涉及到了将zset中的数据删除，所以会报错，但如果你的定时任务只是读，那么就没有问题，但如果涉及写-注意删除也是写的一种-，那么就要注意是不是cluster模式。"><a href="#用定时任务去消费，这里有一个问题，对定时任务使用分布式锁是为了避免定时任务如果部署在两台机器上重复执行，保证每次只有一台机器执行，但有个问题，如果是Redis-Cluster模式是没有问题，但如果是哨兵模式或者一主二从模式，slave是不允许写入的，因为我们涉及到了将zset中的数据删除，所以会报错，但如果你的定时任务只是读，那么就没有问题，但如果涉及写-注意删除也是写的一种-，那么就要注意是不是cluster模式。" class="headerlink" title="用定时任务去消费，这里有一个问题，对定时任务使用分布式锁是为了避免定时任务如果部署在两台机器上重复执行，保证每次只有一台机器执行，但有个问题，如果是Redis Cluster模式是没有问题，但如果是哨兵模式或者一主二从模式，slave是不允许写入的，因为我们涉及到了将zset中的数据删除，所以会报错，但如果你的定时任务只是读，那么就没有问题，但如果涉及写(注意删除也是写的一种)，那么就要注意是不是cluster模式。"></a>用定时任务去消费，这里有一个问题，对定时任务使用分布式锁是为了避免定时任务如果部署在两台机器上重复执行，保证每次只有一台机器执行，但有个问题，如果是Redis Cluster模式是没有问题，但如果是哨兵模式或者一主二从模式，slave是不允许写入的，因为我们涉及到了将zset中的数据删除，所以会报错，但如果你的定时任务只是读，那么就没有问题，但如果涉及写(注意删除也是写的一种)，那么就要注意是不是cluster模式。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskRedis</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisUtil redisUtil;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled</span>(cron=<span class="string">"0 */1 * * * ?"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> b=redisUtil.tryLock(Constant.KEY_LOCK, <span class="string">"1"</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="keyword">if</span> (!b) &#123;</span><br><span class="line">            log.info(<span class="string">"抢锁失败"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Long zsetSize=redisUtil.getZsetSize(Constant.KEY_ZSET);</span><br><span class="line">            <span class="keyword">if</span> (zsetSize == <span class="number">0L</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            CountDownLatch countDownLatch=<span class="keyword">new</span> CountDownLatch(<span class="number">500</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; zsetSize; i++) &#123;</span><br><span class="line">                String uuid=redisUtil.getFirstData(Constant.KEY_ZSET);</span><br><span class="line">                redisUtil.sendMsg(countDownLatch, uuid);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                countDownLatch.await(<span class="number">50L</span>, TimeUnit.SECONDS);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                log.info(<span class="string">"e:&#123;&#125;"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.info(<span class="string">"e:&#123;&#125;"</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            redisUtil.delLock(Constant.KEY_LOCK);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="这是Controller"><a href="#这是Controller" class="headerlink" title="这是Controller"></a>这是Controller</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/redis"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisMsgService redisMsgService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/sendMsg"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sendMsg</span><span class="params">(String id,String msg,String isNow)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisMsgService.sendMsg(id,msg,isNow);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/insert"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">insert</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisMsgService.insert();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/kill"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">kill</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisMsgService.kill();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通过postman调用测试"><a href="#通过postman调用测试" class="headerlink" title="通过postman调用测试"></a>通过postman调用测试</h3><p><img src="../image/postman.png" alt="postman.png" title="postman"></p>
<h3 id="控制台打印"><a href="#控制台打印" class="headerlink" title="控制台打印"></a>控制台打印</h3><p><img src="../image/sys.png" alt="sys.png" title="sys"></p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>延时队列</tag>
      </tags>
  </entry>
  <entry>
    <title>《深入理解Java虚拟机》第一章 走进Java</title>
    <url>/2020/04/19/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    <content><![CDATA[<h3 id="结束了Redis系列问题，现在开始JVM虚拟机的篇章，第一讲，此系列不定时更新，因为想把这本书看透是需要时间的，所以我打算把JVM当作调味品，最近打算学习一下大数据知识，所以JVM当作放松的“课外书籍”来看。"><a href="#结束了Redis系列问题，现在开始JVM虚拟机的篇章，第一讲，此系列不定时更新，因为想把这本书看透是需要时间的，所以我打算把JVM当作调味品，最近打算学习一下大数据知识，所以JVM当作放松的“课外书籍”来看。" class="headerlink" title="结束了Redis系列问题，现在开始JVM虚拟机的篇章，第一讲，此系列不定时更新，因为想把这本书看透是需要时间的，所以我打算把JVM当作调味品，最近打算学习一下大数据知识，所以JVM当作放松的“课外书籍”来看。"></a>结束了Redis系列问题，现在开始JVM虚拟机的篇章，第一讲，此系列不定时更新，因为想把这本书看透是需要时间的，所以我打算把JVM当作调味品，最近打算学习一下大数据知识，所以JVM当作放松的“课外书籍”来看。</h3><h3 id="第一章书上只是说了一些Java的发展史，我只想总结下JDK，JVM，JRE的关系"><a href="#第一章书上只是说了一些Java的发展史，我只想总结下JDK，JVM，JRE的关系" class="headerlink" title="第一章书上只是说了一些Java的发展史，我只想总结下JDK，JVM，JRE的关系"></a>第一章书上只是说了一些Java的发展史，我只想总结下JDK，JVM，JRE的关系</h3><p><img src="../image/JDK.png" alt="JDK.png" title="JDK"></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>走进Java</tag>
        <tag>深入理解Java虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>不得不说的Java‘锁’事</title>
    <url>/2020/03/09/%E4%B8%8D%E5%BE%97%E4%B8%8D%E8%AF%B4%E7%9A%84Java%E2%80%98%E9%94%81%E2%80%99%E4%BA%8B/</url>
    <content><![CDATA[<p>水文一篇<br>转载<br><a href="https://tech.meituan.com/2018/11/15/java-lock.html" target="_blank" rel="noopener">https://tech.meituan.com/2018/11/15/java-lock.html</a></p>
]]></content>
      <categories>
        <category>高并发系列</category>
      </categories>
      <tags>
        <tag>锁</tag>
        <tag>高并发</tag>
      </tags>
  </entry>
  <entry>
    <title>《深入理解Java虚拟机》第二章 Java内存区域与内存溢出异常</title>
    <url>/2020/04/19/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h3 id="此篇为第二章-Java内存区域与内存溢出异常，主要从两部分介绍"><a href="#此篇为第二章-Java内存区域与内存溢出异常，主要从两部分介绍" class="headerlink" title="此篇为第二章 Java内存区域与内存溢出异常，主要从两部分介绍"></a>此篇为第二章 Java内存区域与内存溢出异常，主要从两部分介绍</h3><h3 id="1-内存区域"><a href="#1-内存区域" class="headerlink" title="1.内存区域"></a>1.内存区域</h3><h3 id="话不多说，先上图"><a href="#话不多说，先上图" class="headerlink" title="话不多说，先上图"></a>话不多说，先上图</h3><p><img src="../image/%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.png" alt="内存区域.png" title="内存区域"></p>
<h4 id="1-1方法区"><a href="#1-1方法区" class="headerlink" title="1.1方法区"></a>1.1方法区</h4><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据，它有一个名字叫Non-heap非堆，目的是为了与Java堆区分开来，也有人叫它永久代，是因为它可以选择不实现垃圾收集，但并不是绝对的，只是说发生垃圾回收的概率比较低。</p>
<p>另：当方法区无法满足内存分配需求时，会抛出OutOfMemoryError异常。</p>
<p><strong>JDK1.7之后版本的JVM将运行时常量池从方法区移了出来，在Java堆中开辟了一块区域存放运行时常量池，在JDK1.8开始，取消了方法区，取而代之的是位于直接内存的元空间</strong></p>
<p><strong>使方法区内存溢出，可以死循环调用String.intern()方法，向常量池里无限添加常量，就会导致内存溢出</strong></p>
<h4 id="1-2虚拟机栈"><a href="#1-2虚拟机栈" class="headerlink" title="1.2虚拟机栈"></a>1.2虚拟机栈</h4><p>线程私有的，它的生命周期和线程相同，虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个<strong>栈帧</strong>用于存储局部变量表，操作数栈，动态链接，方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。局部变量表存放了编译期可知的各种基本类型,对象引用。</p>
<p>另：一：虚拟机栈可能会抛出两种异常，如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；二：无法满足内存需求时，会抛出OutOfMemoryError异常。</p>
<p><strong>栈溢出可以通过无线递归方式</strong></p>
<h4 id="1-3本地方法栈"><a href="#1-3本地方法栈" class="headerlink" title="1.3本地方法栈"></a>1.3本地方法栈</h4><p>本地方法栈与虚拟机栈发挥的作用是非常相似的，他们之间的区别不过是虚拟机栈是为虚拟机执行Java服务的，而本地方法栈是为虚拟机使用到的native方法服务的。同样也会有两种异常。</p>
<h4 id="1-4Java堆"><a href="#1-4Java堆" class="headerlink" title="1.4Java堆"></a>1.4Java堆</h4><p>对大多数应用来说，堆是内存最大的一块，是被所有线程共享的一块内存区域，所有new出来的对象都存放在这里，也是主要的垃圾回收场所。当然也会发生内存溢出</p>
<p><strong>堆内存溢出只需要死循环创建对象即可</strong></p>
<h4 id="1-5程序计数器"><a href="#1-5程序计数器" class="headerlink" title="1.5程序计数器"></a>1.5程序计数器</h4><p>可以看作是当前线程所执行的字节码的行号指示器，每条线程都有一个独立的程序计数器。如果线程执行的Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器为空（Undefined）。</p>
<p><strong>此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域</strong></p>
<h4 id="1-6运行时常量池"><a href="#1-6运行时常量池" class="headerlink" title="1.6运行时常量池"></a>1.6运行时常量池</h4><p>运行时常量池在1.7之前都是存放在方法区中，之后就改为存放在堆中，这也导致intern()方法在判断时有些不同，这里可以自己尝试。</p>
<p>常量池分为两种，运行时常量池和Class文件常量池，Class文件常量池主要存放一些类和接口的权限定名，字段名称和描述符，方法名称和描述符，但运行时常量池相对于Class文件常量池的另外一个重要特性就是具备动态性，比如：基本类型包装类（包装类不管理浮点型，整形只会管理-128到127）和String（也可以通过String.intern()方法可以强制将String放入常量池）</p>
<h4 id="1-7直接内存"><a href="#1-7直接内存" class="headerlink" title="1.7直接内存"></a>1.7直接内存</h4><p>这部分虽然不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存被频繁的使用也会导致OutMemoryError异常的出现。</p>
<h3 id="2-Java对象头"><a href="#2-Java对象头" class="headerlink" title="2.Java对象头"></a>2.Java对象头</h3><p>以Hotspot虚拟机为例，Hotspot的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。</p>
<p>Mark Word：默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。</p>
<p>Klass Point：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>
<p><img src="../image/MarkWord.png" alt="MarkWord.png" title="MarkWord"></p>
<h3 id="3-Monitor"><a href="#3-Monitor" class="headerlink" title="3.Monitor"></a>3.Monitor</h3><p>Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。</p>
<p>Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>深入理解Java虚拟机</tag>
        <tag>Java内存区域与内存溢出异常</tag>
      </tags>
  </entry>
  <entry>
    <title>博客模版</title>
    <url>/2020/04/25/%E5%8D%9A%E5%AE%A2%E6%A8%A1%E7%89%88/</url>
    <content><![CDATA[<p><font face="黑体">我是黑体字</font><br><font face="宋体">我是宋体字</font><br><font face="微软雅黑">我是微软雅黑字</font><br><font face="fantasy">我是fantasy字</font><br><font face="Helvetica">我是Helvetica字</font></p>
<p><font face="微软雅黑"><h1 style="background:#50A2B8
"><font color="#FFFFFF">1级标题</font><h1></h1></h1></font></p>
]]></content>
      <categories>
        <category>模版</category>
      </categories>
      <tags>
        <tag>博客模版</tag>
      </tags>
  </entry>
  <entry>
    <title>你看着是一坨，它也经历了很多</title>
    <url>/2020/04/15/%E4%BD%A0%E7%9C%8B%E7%9D%80%E6%98%AF%E4%B8%80%E5%9D%A8%EF%BC%8C%E5%AE%83%E4%B9%9F%E7%BB%8F%E5%8E%86%E4%BA%86%E5%BE%88%E5%A4%9A/</url>
    <content><![CDATA[<p>你看着它是一坨，它也经历了很多。</p>
<p>今天发生了一个bug，钉钉推送数据时出现错误，目标用户收到的数据发生错乱，推送了目标用户的数据子集</p>
<p>起因：我们的数据权限依赖于商分的一张手工维护的底表，这张底表可以理解为hr在录入员工信息的一张表。只不过这里维护的不是员工信息，是数据权限，既然是手工维护，难免会出现差错。一起背锅。</p>
<p>以上是背景，加上原来的产品离职，换了新的产品，可能在设计上两位观念不符，以这个为起因，这位新的产品一直在diss我们的系统，这里是bug，那里是bug，只要不按照她的思维方式，那就被认为是bug。</p>
<p>这款产品我从实习的时候就在做，已经马上一年了，认真迭代，提出自己的想法，从重复代码如何自动化，减少工作量，为这款产品做了各种辅助的工具，各种脚本，各种统计的信息，最近才加上了PVUV的统计(因为觉得公司统计的数据不准确，所以从后端接口的角度去进行了统计)，到现在产品已经趋于稳定，虽然承认这个系统技术含量不高，但确实解决了一些人的问题，还是有他的价值的，今天听到这么diss这款产品，这么diss我们的小伙伴，心里真不是滋味，凭什么我们迭代了这么久的东西，她在不看之前prd的前提下可以这样说，今天是我在这里工作之后第一次感觉到不快乐，你看着是一坨的东西，也经历了很多人的心血。</p>
<p>同时大公司内部才会出现的一个问题是，可能会出现多种产品满足了同样的业务需求，如果说是内部竞争，像腾讯一样，谁做成了是谁的，这是良心的竞争，而我要说的是，在已经有了满足业务需求的产品的时候，还要从头在做一款几乎是一样的产品，为什么耗费这样的人力财力？不仅我们部门，其他部门也存在，不为了公司，真正的去考虑，而是为了那所谓的绩效，当然为了钱无可厚非，但如果这样做就能打高绩效的公司真的不知道待下去的意义，我觉得如果我离职这个应该算一点原因。</p>
]]></content>
      <categories>
        <category>个人经历</category>
      </categories>
      <tags>
        <tag>个人经历</tag>
        <tag>转正述职</tag>
      </tags>
  </entry>
  <entry>
    <title>方向转变</title>
    <url>/2020/05/10/%E6%96%B9%E5%90%91%E8%BD%AC%E5%8F%98/</url>
    <content><![CDATA[<p>经历了五一假期，浮躁的心慢慢静了下来，有些东西只懂表面皮毛是万万不可的，要沉淀，以后要转变一下方向，打牢地基之后，万丈高楼平地起。</p>
]]></content>
      <categories>
        <category>个人经历</category>
      </categories>
      <tags>
        <tag>方向转变</tag>
      </tags>
  </entry>
  <entry>
    <title>转正述职</title>
    <url>/2019/09/25/%E8%BD%AC%E6%AD%A3%E8%BF%B0%E8%81%8C/</url>
    <content><![CDATA[<p>&emsp;&emsp;&emsp;今天是我的转正述职，讲讲述职完后的感受。有的人觉得面试难，有的人觉得述职难，我就是后者，述职作为正式进入公司的终面来说是尤为重要的，可能每个公司考察的方向不同，但大体上都差不多。</p>
<p>首先讲一下个人不足的地方 </p>
<p>1.PPT做的太水，给HR的感觉是不太重视这次述职</p>
<p>2.PPT做的太水导致没有办法体现出你的工作到底做的怎么样，没有办法给人直观的展示</p>
<p>3.层次要清晰，建议分为四个部分，个人简介—工作内容—工作总结—未来规划</p>
<p>&emsp;&emsp;&emsp;这四个部分工作内容和未来规划是最最重要的，是HR主要考察的点，我就是在这两个地方踩了坑，首先工作内容没有明确清晰的给出，具体做了哪些工作，没有量化，最大的坑是在未来规划上，HR会通过你的未来规划来看你是否能够满足公司的发展，以及岗位能力的匹配，应该要表达出学习能力，自主学习的能力。未来规划不要讲一些虚无缥缈的东西，要实打实的列出你的规划，一年的目标？怎么去做 二到三年的目标怎么去完成？五年计划？如何实现</p>
<p>&emsp;&emsp;&emsp;虽然在两位评委的帮助下还是成功了，但在个人这里是一次非常失败的述职，之前还有同事告诉我不用太重视，承认受到了一些影响，但这不是借口，失败了就是失败了，好好复盘，以后晋升争取要做的完美，这次也吸取了教训，以后的工作唯有更加努力，夯实基础，深层次的理解业务，才能对得起自己。</p>
]]></content>
      <categories>
        <category>个人经历</category>
      </categories>
      <tags>
        <tag>个人经历</tag>
        <tag>转正述职</tag>
      </tags>
  </entry>
  <entry>
    <title>Session Token Cookie</title>
    <url>/2019/12/13/Session-Token-Cookie/</url>
    <content><![CDATA[<h4 id="本文记录一下Session-Token-Cookie到底是什么，以及有什么区别。按顺序来看保证登陆状态的演进的几种方式"><a href="#本文记录一下Session-Token-Cookie到底是什么，以及有什么区别。按顺序来看保证登陆状态的演进的几种方式" class="headerlink" title="本文记录一下Session Token Cookie到底是什么，以及有什么区别。按顺序来看保证登陆状态的演进的几种方式"></a>本文记录一下Session Token Cookie到底是什么，以及有什么区别。按顺序来看保证登陆状态的演进的几种方式</h4><h4 id="1-最开始互联网并没有那么大的体量，每个网站也没有那么多的用户，所以访问网站时，只需要做最简单的用户名密码进行校验就可以，但慢慢的随着用户量增加，体量增大，就面临一个问题，那就是要管理会话，必须记住哪些人登陆系统，也就是说必须要把每个人区分开，这就是一个不小的挑战，因为HTTP请求是无状态的，当时想出的办法是给大家发一个会话标识-session-id-，其实就是一个随机的字符串，每个人的都不一样，作为唯一区分。"><a href="#1-最开始互联网并没有那么大的体量，每个网站也没有那么多的用户，所以访问网站时，只需要做最简单的用户名密码进行校验就可以，但慢慢的随着用户量增加，体量增大，就面临一个问题，那就是要管理会话，必须记住哪些人登陆系统，也就是说必须要把每个人区分开，这就是一个不小的挑战，因为HTTP请求是无状态的，当时想出的办法是给大家发一个会话标识-session-id-，其实就是一个随机的字符串，每个人的都不一样，作为唯一区分。" class="headerlink" title="1.最开始互联网并没有那么大的体量，每个网站也没有那么多的用户，所以访问网站时，只需要做最简单的用户名密码进行校验就可以，但慢慢的随着用户量增加，体量增大，就面临一个问题，那就是要管理会话，必须记住哪些人登陆系统，也就是说必须要把每个人区分开，这就是一个不小的挑战，因为HTTP请求是无状态的，当时想出的办法是给大家发一个会话标识(session_id)，其实就是一个随机的字符串，每个人的都不一样，作为唯一区分。"></a>1.最开始互联网并没有那么大的体量，每个网站也没有那么多的用户，所以访问网站时，只需要做最简单的用户名密码进行校验就可以，但慢慢的随着用户量增加，体量增大，就面临一个问题，那就是要管理会话，必须记住哪些人登陆系统，也就是说必须要把每个人区分开，这就是一个不小的挑战，因为HTTP请求是无状态的，当时想出的办法是给大家发一个会话标识(session_id)，其实就是一个随机的字符串，每个人的都不一样，作为唯一区分。</h4><h4 id="2-这样大家很开心，但是服务器就不开心了，每个人只需要保存自己的session-id，但服务器需要保存所有人的session-id，如果访问服务器多了，就得由成千上万，甚至几十万个，这对服务器是一个巨大的开销，严重限制了服务器扩展的能力，比如说我用两个机器组成了一个集群，小F通过机器A登陆了系统，那session-id会保存在机器A上，假设小F的下一次请求被转发到机器B怎么办？机器B可没有小F的session-id"><a href="#2-这样大家很开心，但是服务器就不开心了，每个人只需要保存自己的session-id，但服务器需要保存所有人的session-id，如果访问服务器多了，就得由成千上万，甚至几十万个，这对服务器是一个巨大的开销，严重限制了服务器扩展的能力，比如说我用两个机器组成了一个集群，小F通过机器A登陆了系统，那session-id会保存在机器A上，假设小F的下一次请求被转发到机器B怎么办？机器B可没有小F的session-id" class="headerlink" title="2.这样大家很开心，但是服务器就不开心了，每个人只需要保存自己的session_id，但服务器需要保存所有人的session_id，如果访问服务器多了，就得由成千上万，甚至几十万个，这对服务器是一个巨大的开销，严重限制了服务器扩展的能力，比如说我用两个机器组成了一个集群，小F通过机器A登陆了系统，那session_id会保存在机器A上，假设小F的下一次请求被转发到机器B怎么办？机器B可没有小F的session_id"></a>2.这样大家很开心，但是服务器就不开心了，每个人只需要保存自己的session_id，但服务器需要保存所有人的session_id，如果访问服务器多了，就得由成千上万，甚至几十万个，这对服务器是一个巨大的开销，严重限制了服务器扩展的能力，比如说我用两个机器组成了一个集群，小F通过机器A登陆了系统，那session_id会保存在机器A上，假设小F的下一次请求被转发到机器B怎么办？机器B可没有小F的session_id</h4><h4 id="3-有时候会采用一点小伎俩，session-sticky，就是让小F的请求一直粘连在机器A上，但是这也不管用，要是机器A挂掉了，还得转到机器B去。"><a href="#3-有时候会采用一点小伎俩，session-sticky，就是让小F的请求一直粘连在机器A上，但是这也不管用，要是机器A挂掉了，还得转到机器B去。" class="headerlink" title="3.有时候会采用一点小伎俩，session sticky，就是让小F的请求一直粘连在机器A上，但是这也不管用，要是机器A挂掉了，还得转到机器B去。"></a>3.有时候会采用一点小伎俩，session sticky，就是让小F的请求一直粘连在机器A上，但是这也不管用，要是机器A挂掉了，还得转到机器B去。</h4><h4 id="4-那就只好做session-id的复制了，把session-id在两个机器之间搬来搬去，快累死了。"><a href="#4-那就只好做session-id的复制了，把session-id在两个机器之间搬来搬去，快累死了。" class="headerlink" title="4.那就只好做session_id的复制了，把session_id在两个机器之间搬来搬去，快累死了。"></a>4.那就只好做session_id的复制了，把session_id在两个机器之间搬来搬去，快累死了。</h4><h4 id="5-后来有个叫Memcached的支了招，把session-id集中存储到一个地方，所有的机器都来访问这个地方的数据，这样一来，就不用复制了，但是增加了单点失败的可能性，要是那个负责session的机器挂了，所有人就需要重新登陆一边，后来也尝试把这个单点的机器也搞出集群，增加可靠性，但不管如何，这小小的session对我来说是一个沉重的负担。"><a href="#5-后来有个叫Memcached的支了招，把session-id集中存储到一个地方，所有的机器都来访问这个地方的数据，这样一来，就不用复制了，但是增加了单点失败的可能性，要是那个负责session的机器挂了，所有人就需要重新登陆一边，后来也尝试把这个单点的机器也搞出集群，增加可靠性，但不管如何，这小小的session对我来说是一个沉重的负担。" class="headerlink" title="5.后来有个叫Memcached的支了招，把session_id集中存储到一个地方，所有的机器都来访问这个地方的数据，这样一来，就不用复制了，但是增加了单点失败的可能性，要是那个负责session的机器挂了，所有人就需要重新登陆一边，后来也尝试把这个单点的机器也搞出集群，增加可靠性，但不管如何，这小小的session对我来说是一个沉重的负担。"></a>5.后来有个叫Memcached的支了招，把session_id集中存储到一个地方，所有的机器都来访问这个地方的数据，这样一来，就不用复制了，但是增加了单点失败的可能性，要是那个负责session的机器挂了，所有人就需要重新登陆一边，后来也尝试把这个单点的机器也搞出集群，增加可靠性，但不管如何，这小小的session对我来说是一个沉重的负担。</h4><h4 id="6-于是有人就一直思考，我为什么要保存这可恶的session-id呢，只让每个客户端去保存该多好，可是如果不保存这些session-id，怎么验证客户端发给我的session-id的确是我生成的呢？如果不去验证，我们都不知道他们是不是合法的登陆用户，那些不怀好意的家伙就可以伪造session-id-为所欲为了。关键就是验证，这个时候token应运而生，用户登陆系统，最简单的token组成-uid-用户唯一的身份标识-、time-当前时间的时间戳-、sign-签名，由token的前几位-盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器-。"><a href="#6-于是有人就一直思考，我为什么要保存这可恶的session-id呢，只让每个客户端去保存该多好，可是如果不保存这些session-id，怎么验证客户端发给我的session-id的确是我生成的呢？如果不去验证，我们都不知道他们是不是合法的登陆用户，那些不怀好意的家伙就可以伪造session-id-为所欲为了。关键就是验证，这个时候token应运而生，用户登陆系统，最简单的token组成-uid-用户唯一的身份标识-、time-当前时间的时间戳-、sign-签名，由token的前几位-盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器-。" class="headerlink" title="6.于是有人就一直思考，我为什么要保存这可恶的session_id呢，只让每个客户端去保存该多好，可是如果不保存这些session_id，怎么验证客户端发给我的session_id的确是我生成的呢？如果不去验证，我们都不知道他们是不是合法的登陆用户，那些不怀好意的家伙就可以伪造session_id,为所欲为了。关键就是验证，这个时候token应运而生，用户登陆系统，最简单的token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器)。"></a>6.于是有人就一直思考，我为什么要保存这可恶的session_id呢，只让每个客户端去保存该多好，可是如果不保存这些session_id，怎么验证客户端发给我的session_id的确是我生成的呢？如果不去验证，我们都不知道他们是不是合法的登陆用户，那些不怀好意的家伙就可以伪造session_id,为所欲为了。关键就是验证，这个时候token应运而生，用户登陆系统，最简单的token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器)。</h4><h4 id="7-至此基本的登陆过程就讲完了，但是现在也出现了更加安全的便捷的方式，token更多用于单点登录，拿着token去sso验证，验证通过可以重定向到之前访问的网站。"><a href="#7-至此基本的登陆过程就讲完了，但是现在也出现了更加安全的便捷的方式，token更多用于单点登录，拿着token去sso验证，验证通过可以重定向到之前访问的网站。" class="headerlink" title="7.至此基本的登陆过程就讲完了，但是现在也出现了更加安全的便捷的方式，token更多用于单点登录，拿着token去sso验证，验证通过可以重定向到之前访问的网站。"></a>7.至此基本的登陆过程就讲完了，但是现在也出现了更加安全的便捷的方式，token更多用于单点登录，拿着token去sso验证，验证通过可以重定向到之前访问的网站。</h4><h4 id="8-总结一下cookie，session，token"><a href="#8-总结一下cookie，session，token" class="headerlink" title="8.总结一下cookie，session，token"></a>8.总结一下cookie，session，token</h4><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><h4 id="cookie存储在客户端，HTTP是无状态的，HTTP每次发出的时候会附上改域名下的cookie，从而可以给HTTP附上状态，最常见的就是登陆态。"><a href="#cookie存储在客户端，HTTP是无状态的，HTTP每次发出的时候会附上改域名下的cookie，从而可以给HTTP附上状态，最常见的就是登陆态。" class="headerlink" title="cookie存储在客户端，HTTP是无状态的，HTTP每次发出的时候会附上改域名下的cookie，从而可以给HTTP附上状态，最常见的就是登陆态。"></a>cookie存储在客户端，HTTP是无状态的，HTTP每次发出的时候会附上改域名下的cookie，从而可以给HTTP附上状态，最常见的就是登陆态。</h4><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><h4 id="1-客户端向服务器请求，发送用户名和密码"><a href="#1-客户端向服务器请求，发送用户名和密码" class="headerlink" title="1.客户端向服务器请求，发送用户名和密码"></a>1.客户端向服务器请求，发送用户名和密码</h4><h4 id="2-服务器生成session-id，绑定用户数据存储在数据库"><a href="#2-服务器生成session-id，绑定用户数据存储在数据库" class="headerlink" title="2.服务器生成session_id，绑定用户数据存储在数据库"></a>2.服务器生成session_id，绑定用户数据存储在数据库</h4><h4 id="3-服务器返回session-id给客户端"><a href="#3-服务器返回session-id给客户端" class="headerlink" title="3.服务器返回session_id给客户端"></a>3.服务器返回session_id给客户端</h4><h4 id="4-客户端用cookie存储session-id，以后请求都带上这个session-id"><a href="#4-客户端用cookie存储session-id，以后请求都带上这个session-id" class="headerlink" title="4.客户端用cookie存储session_id，以后请求都带上这个session_id"></a>4.客户端用cookie存储session_id，以后请求都带上这个session_id</h4><h4 id="5-服务器如果收到这个session-id，那么就去数据库查找用户数据，如果找到了说明验证通过"><a href="#5-服务器如果收到这个session-id，那么就去数据库查找用户数据，如果找到了说明验证通过" class="headerlink" title="5.服务器如果收到这个session_id，那么就去数据库查找用户数据，如果找到了说明验证通过"></a>5.服务器如果收到这个session_id，那么就去数据库查找用户数据，如果找到了说明验证通过</h4><h4 id="6-服务器把验证结果返回客户端"><a href="#6-服务器把验证结果返回客户端" class="headerlink" title="6.服务器把验证结果返回客户端"></a>6.服务器把验证结果返回客户端</h4><h3 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h3><h4 id="1-客户端向服务器请求，发送用户名和密码-1"><a href="#1-客户端向服务器请求，发送用户名和密码-1" class="headerlink" title="1.客户端向服务器请求，发送用户名和密码"></a>1.客户端向服务器请求，发送用户名和密码</h4><h4 id="2-服务器根据用户信息通过加密生成token，用户信息包括账号，token过期时间等，具体由服务器自定义"><a href="#2-服务器根据用户信息通过加密生成token，用户信息包括账号，token过期时间等，具体由服务器自定义" class="headerlink" title="2.服务器根据用户信息通过加密生成token，用户信息包括账号，token过期时间等，具体由服务器自定义"></a>2.服务器根据用户信息通过加密生成token，用户信息包括账号，token过期时间等，具体由服务器自定义</h4><h4 id="3-服务器返回token给客户端"><a href="#3-服务器返回token给客户端" class="headerlink" title="3.服务器返回token给客户端"></a>3.服务器返回token给客户端</h4><h4 id="4-客户端用cookie存储token，以后的请求都带上这个token"><a href="#4-客户端用cookie存储token，以后的请求都带上这个token" class="headerlink" title="4.客户端用cookie存储token，以后的请求都带上这个token"></a>4.客户端用cookie存储token，以后的请求都带上这个token</h4><h4 id="5-服务器拿到token，把token解密，确认用户信息是否正确"><a href="#5-服务器拿到token，把token解密，确认用户信息是否正确" class="headerlink" title="5.服务器拿到token，把token解密，确认用户信息是否正确"></a>5.服务器拿到token，把token解密，确认用户信息是否正确</h4><h4 id="6-服务器把验证结果返回给客户端"><a href="#6-服务器把验证结果返回给客户端" class="headerlink" title="6.服务器把验证结果返回给客户端"></a>6.服务器把验证结果返回给客户端</h4><h3 id="Session，token优劣"><a href="#Session，token优劣" class="headerlink" title="Session，token优劣"></a>Session，token优劣</h3><h4 id="session"><a href="#session" class="headerlink" title="session"></a>session</h4><h5 id="由于session-id和用户信息相互绑定的数据库存在服务器，所以服务器可以随时让发送出去的一个session-id失效，这是保障安全的一种重要手段"><a href="#由于session-id和用户信息相互绑定的数据库存在服务器，所以服务器可以随时让发送出去的一个session-id失效，这是保障安全的一种重要手段" class="headerlink" title="由于session_id和用户信息相互绑定的数据库存在服务器，所以服务器可以随时让发送出去的一个session_id失效，这是保障安全的一种重要手段"></a>由于session_id和用户信息相互绑定的数据库存在服务器，所以服务器可以随时让发送出去的一个session_id失效，这是保障安全的一种重要手段</h5><h4 id="token"><a href="#token" class="headerlink" title="token"></a>token</h4><h5 id="token的好处是比session更省空间和时间，服务器不需要去管理session-id和用户信息的数据库，服务器收到token直接解密就可以验证，不需要去数据库查找验证，但是token发出去之后，就只能等待它过期之后才会失效，后台服务器无法对其进行控制"><a href="#token的好处是比session更省空间和时间，服务器不需要去管理session-id和用户信息的数据库，服务器收到token直接解密就可以验证，不需要去数据库查找验证，但是token发出去之后，就只能等待它过期之后才会失效，后台服务器无法对其进行控制" class="headerlink" title="token的好处是比session更省空间和时间，服务器不需要去管理session_id和用户信息的数据库，服务器收到token直接解密就可以验证，不需要去数据库查找验证，但是token发出去之后，就只能等待它过期之后才会失效，后台服务器无法对其进行控制"></a>token的好处是比session更省空间和时间，服务器不需要去管理session_id和用户信息的数据库，服务器收到token直接解密就可以验证，不需要去数据库查找验证，但是token发出去之后，就只能等待它过期之后才会失效，后台服务器无法对其进行控制</h5><h4 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">加入jwt依赖</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.auth0&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;java-jwt&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">声明<span class="number">2</span>个变量过期时间和token秘钥(UUID可能会更好，我是自己随便输的)，token秘钥用于后面解密</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置30分钟过期</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> EXPIRE_DATE=<span class="number">30</span>*<span class="number">60</span>*<span class="number">1000</span>;</span><br><span class="line">    <span class="comment">//token秘钥</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TOKEN_SECRET = <span class="string">"EQIUBFKSJBFJH2367816BQWE"</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">加密</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">tokenTest</span> <span class="params">(String username,String password)</span></span>&#123;        </span><br><span class="line"> </span><br><span class="line">        String token = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//过期时间</span></span><br><span class="line">            Date date = <span class="keyword">new</span> Date(System.currentTimeMillis()+EXPIRE_DATE);</span><br><span class="line">            <span class="comment">//秘钥及加密算法</span></span><br><span class="line">            Algorithm algorithm = Algorithm.HMAC256(TOKEN_SECRET);</span><br><span class="line">            <span class="comment">//设置头部信息</span></span><br><span class="line">            Map&lt;String,Object&gt; header = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            header.put(<span class="string">"typ"</span>,<span class="string">"JWT"</span>);</span><br><span class="line">            header.put(<span class="string">"alg"</span>,<span class="string">"HS256"</span>);</span><br><span class="line">            <span class="comment">//携带username，password信息，生成签名</span></span><br><span class="line">            token = JWT.create()</span><br><span class="line">                    .withHeader(header)</span><br><span class="line">                    .withClaim(<span class="string">"username"</span>,username)</span><br><span class="line">                    .withClaim(<span class="string">"password"</span>,password).withExpiresAt(date)</span><br><span class="line">                    .sign(algorithm);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span>  <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">解密。该方法的参数token是加密方法的返回值</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(String token)</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@desc</span>   验证token，通过返回true</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@create</span> 2019/1/18/018 9:39</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@params</span> [token]需要校验的串</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Algorithm algorithm = Algorithm.HMAC256(TOKEN_SECRET);</span><br><span class="line">            JWTVerifier verifier = JWT.require(algorithm).build();</span><br><span class="line">            DecodedJWT jwt = verifier.verify(token);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span>  <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">登陆接口</span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/logon"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonRESTResult <span class="title">getUserInfo</span><span class="params">(HttpSession session ,String userName, String password)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@author</span> Syl</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@create</span> 2019/12/13 9:55</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@params</span> [session, userName, password]</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        JsonRESTResult jsonRESTResult = <span class="keyword">new</span> JsonRESTResult();        </span><br><span class="line">        <span class="comment">//使用token工具类生成token串</span></span><br><span class="line">        String token  = TokenUtil.tokenTest(userName,password);</span><br><span class="line">        <span class="comment">//根据用户名密码查找用户</span></span><br><span class="line">        User user = loginService.findUser(userName,password);</span><br><span class="line">        <span class="keyword">if</span> (user !=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//将用户对象放到session中</span></span><br><span class="line">            session.setAttribute(<span class="string">"USER_INFO"</span>,user);</span><br><span class="line">            <span class="comment">//用户无操作30分钟需重新登录</span></span><br><span class="line">            session.setMaxInactiveInterval(<span class="number">60</span>*<span class="number">30</span>);</span><br><span class="line">            Map map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            map.put(<span class="string">"USERINFO"</span>,user);</span><br><span class="line">            map.put(<span class="string">"SESSIONID"</span>,session.getId());</span><br><span class="line">            map.put(<span class="string">"token"</span>,token);</span><br><span class="line">            jsonRESTResult.setCode(JsonRESTResultMsg.CODE_800.getCode());</span><br><span class="line">            jsonRESTResult.setMsg(<span class="string">"登录成功"</span>);</span><br><span class="line">            jsonRESTResult.setData(map);</span><br><span class="line">            <span class="keyword">return</span> jsonRESTResult;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            jsonRESTResult.setCode(JsonRESTResultMsg.CODE_500.getCode());</span><br><span class="line">            jsonRESTResult.setMsg(<span class="string">"登录失败,用户名密码错误"</span>);</span><br><span class="line">            jsonRESTResult.setData(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> jsonRESTResult;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">验证用户是否登陆接口</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/judgeLogin"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonRESTResult <span class="title">judgeLogin</span><span class="params">(String token,HttpSession session)</span></span>&#123;</span><br><span class="line">        JsonRESTResult jsonRESTResult = <span class="keyword">new</span> JsonRESTResult();</span><br><span class="line">        <span class="keyword">if</span> (TokenUtil.verify(token))&#123;</span><br><span class="line">            User user = (User)session.getAttribute(<span class="string">"USER_INFO"</span>);</span><br><span class="line">            jsonRESTResult.setCode(JsonRESTResultMsg.CODE_800.getCode());</span><br><span class="line">            jsonRESTResult.setData(user);</span><br><span class="line">            jsonRESTResult.setMsg(<span class="string">"用户登录成功"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            jsonRESTResult.setCode(JsonRESTResultMsg.CODE_500.getCode());</span><br><span class="line">            jsonRESTResult.setMsg(<span class="string">"未登录或已过期"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jsonRESTResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Session Token Cookie</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>volatile关键字</title>
    <url>/2020/03/11/volatile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h3 id="本文还是以面试提问的方式来说一下volatile"><a href="#本文还是以面试提问的方式来说一下volatile" class="headerlink" title="本文还是以面试提问的方式来说一下volatile"></a>本文还是以面试提问的方式来说一下volatile</h3><h4 id="1-Java并发这块了解的怎么样？说说对volatile的理解？"><a href="#1-Java并发这块了解的怎么样？说说对volatile的理解？" class="headerlink" title="1.Java并发这块了解的怎么样？说说对volatile的理解？"></a>1.Java并发这块了解的怎么样？说说对volatile的理解？</h4><ol>
<li>保证了不同线程对该变量操作的内存可见性</li>
<li>禁止指令重排</li>
</ol>
<h4 id="2-能不能详细说说什么是内存可见性，什么又是重排序呢？"><a href="#2-能不能详细说说什么是内存可见性，什么又是重排序呢？" class="headerlink" title="2.能不能详细说说什么是内存可见性，什么又是重排序呢？"></a>2.能不能详细说说什么是内存可见性，什么又是重排序呢？</h4><p>  这里先从Java内存模型说起。<br>  Java虚拟机规范一种Java内存模型(JMM) 用来屏蔽各种硬件和操作系统的内存访问差异，让Java程序在各种平台上都能达到一致的内存访问效果。<br>  JMM规定所有变量都是存在主存中的，每个线程又包含自己的工作内存，方便理解就可以看成CPU上的寄存器或者高速缓存，所以线程的操作都是以工作内存为主，它们只能访问自己的工作内存，且前后都要把值同步回主内存。<br>  在线程执行时，首先会从主存中读变量值，在下载到工作内存的副本中，然后在传给处理器执行，执行完毕后再给工作内存中的副本赋值，随后工作内存再把值传回给主存，主存中的值才更新。<br>  这就引出了一个问题，比如执行 i = i + 1或i++<br>  假设初始i值为0，当只有一个线程执行它时，结果肯定得到1，当两个线程执行时，会得到结果2吗？可能会出现这种情况：</p>
<p>线程1： load i from 主存    // i = 0<br>        i + 1  // i = 1<br>线程2： load i from主存  // 因为线程1还没将i的值写回主存，所以i还是0<br>        i +  1 //i = 1<br>线程1:  save i to 主存<br>线程2： save i to 主存<br>  如果两个线程按照上面的执行流程，那么最后i的值会是1，如果最后的写回生效的慢，在读取i的值，都有可能是0，这就是缓存不一致问题。<br>分析<br>结合内存屏障这个概念对volatile的读写操作深入理解的话：</p>
<p>第一步：读<br>在第一步操作的指令后，会增加两个内存屏障：</p>
<p>在Volatile读操作后插入LoadLoad屏障，防止前面的Volatile读与后面的普通读重排序<br>在Volatile读操作后插入LoadStore屏障，防止前面的Volatile读与后面的普通写重排序<br>因此第一个指令和它后续的普通读写操作会被保证没有重排序来捣乱。通常是去内存中去读。</p>
<p>那么问题又来了，为什么通常去内存中读？</p>
<p>其实这个问题要说细的话可以很细，大概就两个关键点吧：</p>
<p>volatile的写操作的缓存失效机制<br>最后一个对volatile变量执行写操作的CPU，由于在它对应的缓存中保有最新的值，因此可以不用再去主存里面获取<br>具体看下面第三步的分析。</p>
<p>第二步：自增<br>这个步骤没什么特别的，就是在CPU自身的高速缓存(寄存器，L1-L3 Cache)中完成。不涉及到缓存和内存的交互。</p>
<p>第三步：写<br>volatile写算是一个重点。</p>
<p>根据JMM对于volatile变量类型的语义规范：volatile在编译之后，会在变量写操作时添加LOCK前缀指令。这个LOCK前缀指令在多核处理器的环境中，有这样的作用：</p>
<p>通知CPU将当前处理器缓存行的数据写回到系统主存中<br>该写回操作将使其他CPU缓存了该内存地址的数据无效<br>另外，内存屏障在volatile的写操作中起到了很大的作用，来保证上面两点能够实现：</p>
<p>在Volatile写操作前插入StoreStore屏障，防止前面其他写与本次Volatile写重排序<br>在Volatile写操作后插入StoreLoad屏障，防止本次的Volatile写与后面的读操作重排序</p>
<p>JMM主要就是围绕着如何在并发过程中如何处理原子性，可见性和有序性这三个特征来建立的，通过解决着三个问题，可以接触缓存不一致的问题，而volatile跟可见性和有序性都有关。</p>
<h4 id="3-那你具体说说这三个特性呢？"><a href="#3-那你具体说说这三个特性呢？" class="headerlink" title="3.那你具体说说这三个特性呢？"></a>3.那你具体说说这三个特性呢？</h4><p>  (1).原子性：Java中，对基本数据类型的读取和赋值操作是原子性操作，也就是这些操作是不可中断的，要做一定做完。JMM只实现了基本的原子性，像上面i++那样的操作，必须借助synchronized和Lock来保证整块代码的原子性了，线程在锁释放之前，必然会把i的值刷回到主存的。<br>  (2).可见性：可见性Java就是利用volatile来提供可见性的，当一个变量被volatile修饰时，那么对它的修改会立刻刷新到主存，当其他线程需要读取该变量时，会去内存中读取新值。而普通变量则不能保证这一点。<br>  其实通过synchronized和Lock也能够保证可见性，线程在释放锁之前，会把共享变量值都刷回主存，但是synchronized和Lock的开销都更大。<br>  (3).有序性：JMM是允许编译器和处理器对指令重排序的，但是规定了as-if-serial语义，即不管怎么重排序，程序的执行结果不能改变。比如下面的程序段：<br>double pi = 3.14;    //A<br>double r = 1;        //B<br>double s= pi * r * r;//C<br>上面的语句，可以按照A-&gt;B-&gt;C执行，结果为3.14,但是也可以按照B-&gt;A-&gt;C的顺序执行，因为A、B是两句独立的语句，而C则依赖于A、B，所以A、B可以重排序，但是C却不能排到A、B的前面。JMM保证了重排序不会影响到单线程的执行，但是在多线程中却容易出问题。<br>比如这样的代码:<br>int a = 0;<br>bool flag = false;</p>
<p>public void write() {<br>    a = 2;              //1<br>    flag = true;        //2<br>}</p>
<p>public void multiply() {<br>    if (flag) {         //3<br>        int ret = a * a;//4<br>    }</p>
<p>}</p>
<p>write方法里的1和2做了重排序，线程1先对flag赋值为true，随后执行到线程2，ret直接计算出结果，再到线程1，这时候a才赋值为2,很明显迟了一步。<br>这时候可以为flag加上volatile关键字，禁止重排序，可以确保程序的“有序性”，也可以上重量级的synchronized和Lock来保证有序性,它们能保证那一块区域里的代码都是一次性执行完毕的。<br>ps：这里提一句：volatile的禁止指令重排是在jdk1.6之后才做了修复，这也是jdk1.6之前用双重锁校验的synchronized单例模式会有线程不安全的问题原因。<br>另外，JMM具备一些先天的有序性,即不需要通过任何手段就可以保证的有序性，通常称为happens-before原则。具体如下：<br>1.程序顺序规则： 一个线程中的每个操作，happens-before于该线程中的任意后续操作<br>2.监视器锁规则：对一个线程的解锁，happens-before于随后对这个线程的加锁<br>3.volatile变量规则： 对一个volatile域的写，happens-before于后续对这个volatile域的读<br>4.传递性：如果A happens-before B ,且 B happens-before C, 那么 A happens-before C<br>5.start()规则： 如果线程A执行操作ThreadB_start()(启动线程B) ,  那么A线程的ThreadB_start()happens-before 于B中的任意操作<br>6.join()原则： 如果A执行ThreadB.join()并且成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。<br>7.interrupt()原则： 对线程interrupt()方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测是否有中断发生<br>8.finalize()原则：一个对象的初始化完成先行发生于它的finalize()方法的开始</p>
<h4 id="4-volatile关键字如何满足并发编程的三大特性的？"><a href="#4-volatile关键字如何满足并发编程的三大特性的？" class="headerlink" title="4.volatile关键字如何满足并发编程的三大特性的？"></a>4.volatile关键字如何满足并发编程的三大特性的？</h4><p>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存<br>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主存中读取共享变量。</p>
<h4 id="5-volatile可以保证可见性和有序性，但是能保证原子性吗？"><a href="#5-volatile可以保证可见性和有序性，但是能保证原子性吗？" class="headerlink" title="5.volatile可以保证可见性和有序性，但是能保证原子性吗？"></a>5.volatile可以保证可见性和有序性，但是能保证原子性吗？</h4><p>  首先我回答是不能保证原子性，要是说能保证，也只是对单个volatile变量的读/写具有原子性，但是对于类似volatile++这样的复合操作就无能为力了，比如下面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> inc=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test=<span class="keyword">new</span> Test();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j &lt; <span class="number">1000</span>; j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按道理来说结果是10000，但是运行下很可能是个小于10000的值。有人可能会说volatile不是保证了可见性啊，一个线程对inc的修改，另外一个线程应该立刻看到啊！可是这里的操作inc++是个复合操作啊，包括读取inc的值，对其自增，然后再写回主存。<br>假设线程A，读取了inc的值为10，这时候被阻塞了，因为没有对变量进行修改，触发不了volatile规则。<br>线程B此时也读读inc的值，主存里inc的值依旧为10，做自增，然后立刻就被写回主存了，为11。<br>此时又轮到线程A执行，由于工作内存里保存的是10，所以继续做自增，再写回主存，11又被写了一遍。所以虽然两个线程执行了两次increase()，结果却只加了一次。<br>有人说，volatile不是会使缓存行无效的吗？但是这里线程A读取到线程B也进行操作之前，并没有修改inc值，所以线程B读取的时候，还是读的10。<br>又有人说，线程B将11写回主存，不会把线程A的缓存行设为无效吗？但是线程A的读取操作已经做过了啊，只有在做读取操作时，发现自己缓存行无效，才会去读主存的值，所以这里线程A只能继续做自增了。<br>综上所述，在这种复合操作的情景下，原子性的功能是维持不了了。但是volatile在上面那种设置flag值的例子里，由于对flag的读/写操作都是单步的，所以还是能保证原子性的。<br>要想保证原子性，只能借助于synchronized,Lock以及并发包下的atomic的原子操作类了，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。</p>
<h4 id="6-那你知道volatile的底层实现机制吗？"><a href="#6-那你知道volatile的底层实现机制吗？" class="headerlink" title="6.那你知道volatile的底层实现机制吗？"></a>6.那你知道volatile的底层实现机制吗？</h4><p>如果把加入volatile关键字的代码和未加入volatile关键字的代码都生成汇编代码，会发现加入volatile关键字的代码会多出一个lock前缀指令。<br>lock前缀指令实际相当于一个内存屏障，内存屏障提供了以下功能：</p>
<ol>
<li>重排序时不能把后面的指令重排序到内存屏障之前的位置</li>
<li>使得本CPU的Cache写入内存</li>
<li>写入动作也会引起别的CPU或者别的内核无效化其Cache，相当于让新写入的值对别的线程可见。</li>
</ol>
<h4 id="7-你在哪里会使用到volatile，举几个例子？"><a href="#7-你在哪里会使用到volatile，举几个例子？" class="headerlink" title="7.你在哪里会使用到volatile，举几个例子？"></a>7.你在哪里会使用到volatile，举几个例子？</h4><ol>
<li>状态量标记，true/false</li>
<li>单例模式双重检查锁</li>
</ol>
]]></content>
      <categories>
        <category>高并发系列</category>
      </categories>
      <tags>
        <tag>高并发</tag>
        <tag>volatile</tag>
      </tags>
  </entry>
  <entry>
    <title>《深入理解Java虚拟机》第三章垃圾收集器与内存分配策略</title>
    <url>/2020/04/22/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h2 id="第一部分-对象已死吗？"><a href="#第一部分-对象已死吗？" class="headerlink" title="第一部分:对象已死吗？"></a>第一部分:对象已死吗？</h2><h3 id="1-1-引用计数算法"><a href="#1-1-引用计数算法" class="headerlink" title="1.1 引用计数算法"></a>1.1 引用计数算法</h3><h4 id="引用计数算法：指的是给对象添加一个引用计数器，每当有一个地方引用它的时候，计数器就-1，当引用失效时，计数器就-1，这样就会出现一个问题，无法判断互相引用的对象已死。"><a href="#引用计数算法：指的是给对象添加一个引用计数器，每当有一个地方引用它的时候，计数器就-1，当引用失效时，计数器就-1，这样就会出现一个问题，无法判断互相引用的对象已死。" class="headerlink" title="引用计数算法：指的是给对象添加一个引用计数器，每当有一个地方引用它的时候，计数器就+1，当引用失效时，计数器就-1，这样就会出现一个问题，无法判断互相引用的对象已死。"></a>引用计数算法：指的是给对象添加一个引用计数器，每当有一个地方引用它的时候，计数器就+1，当引用失效时，计数器就-1，这样就会出现一个问题，无法判断互相引用的对象已死。</h4><p><img src="../image/%E4%BA%92%E7%9B%B8%E5%BC%95%E7%94%A8.png" alt="互相引用.png" title="互相引用"></p>
<h3 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2 可达性分析算法"></a>1.2 可达性分析算法</h3><h4 id="可达性分析算法：引入了GC-Roots对象，从GC-Roots到这个对象不可达时，则证明这个对象是不可用的，如图object5，object6-objecct7来说，虽然互相有关联，但是它们到GC-Roots是不可达的，所以他们会被判断为是可回收的对象。"><a href="#可达性分析算法：引入了GC-Roots对象，从GC-Roots到这个对象不可达时，则证明这个对象是不可用的，如图object5，object6-objecct7来说，虽然互相有关联，但是它们到GC-Roots是不可达的，所以他们会被判断为是可回收的对象。" class="headerlink" title="可达性分析算法：引入了GC Roots对象，从GC Roots到这个对象不可达时，则证明这个对象是不可用的，如图object5，object6,objecct7来说，虽然互相有关联，但是它们到GC Roots是不可达的，所以他们会被判断为是可回收的对象。"></a>可达性分析算法：引入了GC Roots对象，从GC Roots到这个对象不可达时，则证明这个对象是不可用的，如图object5，object6,objecct7来说，虽然互相有关联，但是它们到GC Roots是不可达的，所以他们会被判断为是可回收的对象。</h4><h4 id="1-2-1-那么什么样的对象可以作为GC-Roots对象呢？"><a href="#1-2-1-那么什么样的对象可以作为GC-Roots对象呢？" class="headerlink" title="1.2.1 那么什么样的对象可以作为GC Roots对象呢？"></a>1.2.1 那么什么样的对象可以作为GC Roots对象呢？</h4><p>《深入理解Java虚拟机》书中给出的定义是：</p>
<ol>
<li>虚拟机栈中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中引用的对象</li>
</ol>
<h3 id="1-3-在谈引用"><a href="#1-3-在谈引用" class="headerlink" title="1.3 在谈引用"></a>1.3 在谈引用</h3><ol>
<li>强引用：在代码中普遍存在的，类似“Object obj = new Object()”,这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉这类对象</li>
<li>软引用：总结起来就是当内存不够发生GC时才会回收的对象。JDK1.2之后，提供了SoftReference类来实现软引用。</li>
<li>弱引用：被弱引用关联的对象，只能存活到下一次发生垃圾回收之前，当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</li>
<li>虚引用：是一种最弱的引用关系，存在的意义只是在这个对象被收集器回收时收到一个系统通知。</li>
</ol>
<h3 id="1-4死之前的“HP药水”"><a href="#1-4死之前的“HP药水”" class="headerlink" title="1.4死之前的“HP药水”"></a>1.4死之前的“HP药水”</h3><h4 id="1-4-1-即使在可达性分析算法中不可达的对象，也并不是“非死不可”，这时候处于濒危状态，但他们还有一瓶HP药水，那就是finalize-方法，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC-Roots相连接的引用链，那它将会第一次标记并且进行一次筛选，筛选的条件时此对象是否有必要执行finalize-方法。当对象没有覆盖finalize-方法，或者finalize-方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。"><a href="#1-4-1-即使在可达性分析算法中不可达的对象，也并不是“非死不可”，这时候处于濒危状态，但他们还有一瓶HP药水，那就是finalize-方法，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC-Roots相连接的引用链，那它将会第一次标记并且进行一次筛选，筛选的条件时此对象是否有必要执行finalize-方法。当对象没有覆盖finalize-方法，或者finalize-方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。" class="headerlink" title="1.4.1 即使在可达性分析算法中不可达的对象，也并不是“非死不可”，这时候处于濒危状态，但他们还有一瓶HP药水，那就是finalize()方法，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会第一次标记并且进行一次筛选，筛选的条件时此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。"></a>1.4.1 即使在可达性分析算法中不可达的对象，也并不是“非死不可”，这时候处于濒危状态，但他们还有一瓶HP药水，那就是finalize()方法，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会第一次标记并且进行一次筛选，筛选的条件时此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</h4><h4 id="1-4-2-如果这个对象被判定为有必要执行finalize-方法，那么这个对象将会被放置在一个叫做F-Queue的队列之中，并在稍后由一个虚拟机自动建立的，低优先级的Finalizer线程去执行它。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是，如果在finalize-方法中执行缓慢，或者发生了死循环，将很可能会导致F-Queue队列中其他的对象永久处于等待。"><a href="#1-4-2-如果这个对象被判定为有必要执行finalize-方法，那么这个对象将会被放置在一个叫做F-Queue的队列之中，并在稍后由一个虚拟机自动建立的，低优先级的Finalizer线程去执行它。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是，如果在finalize-方法中执行缓慢，或者发生了死循环，将很可能会导致F-Queue队列中其他的对象永久处于等待。" class="headerlink" title="1.4.2 如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会被放置在一个叫做F-Queue的队列之中，并在稍后由一个虚拟机自动建立的，低优先级的Finalizer线程去执行它。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是，如果在finalize()方法中执行缓慢，或者发生了死循环，将很可能会导致F-Queue队列中其他的对象永久处于等待。"></a>1.4.2 如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会被放置在一个叫做F-Queue的队列之中，并在稍后由一个虚拟机自动建立的，低优先级的Finalizer线程去执行它。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是，如果在finalize()方法中执行缓慢，或者发生了死循环，将很可能会导致F-Queue队列中其他的对象永久处于等待。</h4><h4 id="1-4-3-如果对象要在finalize-中拯救自己-只需要重新与引用连上的任何一个对象建立关联即可。"><a href="#1-4-3-如果对象要在finalize-中拯救自己-只需要重新与引用连上的任何一个对象建立关联即可。" class="headerlink" title="1.4.3 如果对象要在finalize()中拯救自己-只需要重新与引用连上的任何一个对象建立关联即可。"></a>1.4.3 如果对象要在finalize()中拯救自己-只需要重新与引用连上的任何一个对象建立关联即可。</h4><h2 id="第二部分-GC场所"><a href="#第二部分-GC场所" class="headerlink" title="第二部分:GC场所"></a>第二部分:GC场所</h2><h3 id="1-堆作为垃圾回收的主要场所，所有新建的对象都存储在堆上，但栈并不会发生垃圾回收，因为栈中存储的是线程私有的，随着线程关闭就自动释放。将堆中的内存分为新生代和老年代，这里在后面谈到垃圾回收算法时会详细说。"><a href="#1-堆作为垃圾回收的主要场所，所有新建的对象都存储在堆上，但栈并不会发生垃圾回收，因为栈中存储的是线程私有的，随着线程关闭就自动释放。将堆中的内存分为新生代和老年代，这里在后面谈到垃圾回收算法时会详细说。" class="headerlink" title="1.堆作为垃圾回收的主要场所，所有新建的对象都存储在堆上，但栈并不会发生垃圾回收，因为栈中存储的是线程私有的，随着线程关闭就自动释放。将堆中的内存分为新生代和老年代，这里在后面谈到垃圾回收算法时会详细说。"></a>1.堆作为垃圾回收的主要场所，所有新建的对象都存储在堆上，但栈并不会发生垃圾回收，因为栈中存储的是线程私有的，随着线程关闭就自动释放。将堆中的内存分为新生代和老年代，这里在后面谈到垃圾回收算法时会详细说。</h3><h3 id="2-方法区-也叫永久代，针对HotSpot虚拟机来说-，很多人都认为方法区中时没有垃圾回收的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾回收，主要是垃圾收集的“性价比”比较低"><a href="#2-方法区-也叫永久代，针对HotSpot虚拟机来说-，很多人都认为方法区中时没有垃圾回收的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾回收，主要是垃圾收集的“性价比”比较低" class="headerlink" title="2.方法区(也叫永久代，针对HotSpot虚拟机来说)，很多人都认为方法区中时没有垃圾回收的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾回收，主要是垃圾收集的“性价比”比较低"></a>2.方法区(也叫永久代，针对HotSpot虚拟机来说)，很多人都认为方法区中时没有垃圾回收的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾回收，主要是垃圾收集的“性价比”比较低</h3><h3 id="方法区的垃圾回收主要回收两部分内容：废弃常量和无用的类。那么如何判断废弃常量和无用的类？"><a href="#方法区的垃圾回收主要回收两部分内容：废弃常量和无用的类。那么如何判断废弃常量和无用的类？" class="headerlink" title="方法区的垃圾回收主要回收两部分内容：废弃常量和无用的类。那么如何判断废弃常量和无用的类？"></a>方法区的垃圾回收主要回收两部分内容：废弃常量和无用的类。那么如何判断废弃常量和无用的类？</h3><h4 id="2-1-废弃常量：假如一个字符串“abc”-放入了常量池，只要当前系统中没有有任何一个String对象引用常量池中的“abc”常量，如果这个时候发生了内存回收，而且必要的话，那么这个“abc”常量就会被系统清理出常量池。"><a href="#2-1-废弃常量：假如一个字符串“abc”-放入了常量池，只要当前系统中没有有任何一个String对象引用常量池中的“abc”常量，如果这个时候发生了内存回收，而且必要的话，那么这个“abc”常量就会被系统清理出常量池。" class="headerlink" title="2.1 废弃常量：假如一个字符串“abc”,放入了常量池，只要当前系统中没有有任何一个String对象引用常量池中的“abc”常量，如果这个时候发生了内存回收，而且必要的话，那么这个“abc”常量就会被系统清理出常量池。"></a>2.1 废弃常量：假如一个字符串“abc”,放入了常量池，只要当前系统中没有有任何一个String对象引用常量池中的“abc”常量，如果这个时候发生了内存回收，而且必要的话，那么这个“abc”常量就会被系统清理出常量池。</h4><h4 id="2-2-无用的类："><a href="#2-2-无用的类：" class="headerlink" title="2.2 无用的类："></a>2.2 无用的类：</h4><ol>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。</li>
<li>加载该类的ClassLoader已经被回收。</li>
<li>该类对象的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ol>
<h2 id="第三部分-垃圾回收算法"><a href="#第三部分-垃圾回收算法" class="headerlink" title="第三部分:垃圾回收算法"></a>第三部分:垃圾回收算法</h2><h3 id="3-1-标记清除算法"><a href="#3-1-标记清除算法" class="headerlink" title="3.1 标记清除算法"></a>3.1 标记清除算法</h3><p>缺点有内存碎片产生，缺点比较明显。</p>
<p><img src="../image/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4.png" alt="标记清除.png" title="标记清除"></p>
<h3 id="3-2-复制算法-新生代"><a href="#3-2-复制算法-新生代" class="headerlink" title="3.2 复制算法(新生代)"></a>3.2 复制算法(新生代)</h3><p>思想是将内存一分为二，每次值用一半的内存，发生GC的时候将存活的对象放入另一半内存，以此往复。</p>
<p>新生代的对象IBM研究98%都是朝生夕死的，所以没必要按照1:1的比例分配，经过研究8：1:1是最优的，为什么有两个Survivor区下文有解释。</p>
<p>对象优先存入Eden区和一个Survivor区中，将发生Minor GC，之后将存活的对象放入另一个Survivor区，然后下一次存入对象，与Eden区一起的是有存活对象的Sruvivor区</p>
<p><img src="../image/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt="复制算法.png" title="复制算法"></p>
<h3 id="3-3-标记-整理算法-老年代"><a href="#3-3-标记-整理算法-老年代" class="headerlink" title="3.3 标记-整理算法(老年代)"></a>3.3 标记-整理算法(老年代)</h3><p>大体上与标记清除算法一致，将存活的对象集中放到一起，避免了内存分片，因为老年代上存活的对象大部分都是大对象。</p>
<p><img src="../image/%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86.png" alt="标记整理.png" title="标记整理"></p>
<h3 id="3-4-分代收集算法"><a href="#3-4-分代收集算法" class="headerlink" title="3.4 分代收集算法"></a>3.4 分代收集算法</h3><p>判断新生代就用复制算法，判断老年代就用标记-整理算法，那么如何判断新生代，老年代？接着看</p>
<h2 id="第四部分-内存分配"><a href="#第四部分-内存分配" class="headerlink" title="第四部分:内存分配"></a>第四部分:内存分配</h2><h3 id="4-1-新生代，老年代"><a href="#4-1-新生代，老年代" class="headerlink" title="4.1 新生代，老年代"></a>4.1 新生代，老年代</h3><p><img src="../image/%E6%96%B0%E7%94%9F%E4%BB%A3.png" alt="新生代.png" title="新生代"></p>
<p><img src="../image/%E8%80%81%E5%B9%B4%E4%BB%A3.png" alt="老年代.png" title="老年代"></p>
<h3 id="4-2-Minor-GC和Full-GC-Major-GC"><a href="#4-2-Minor-GC和Full-GC-Major-GC" class="headerlink" title="4.2 Minor GC和Full GC(Major GC)"></a>4.2 Minor GC和Full GC(Major GC)</h3><h4 id="4-2-1-Minor-GC是发生在新生代的GC-因为新生代都是朝生夕死的对象，所以发生非常频繁，速度也较快。"><a href="#4-2-1-Minor-GC是发生在新生代的GC-因为新生代都是朝生夕死的对象，所以发生非常频繁，速度也较快。" class="headerlink" title="4.2.1 Minor GC是发生在新生代的GC,因为新生代都是朝生夕死的对象，所以发生非常频繁，速度也较快。"></a>4.2.1 Minor GC是发生在新生代的GC,因为新生代都是朝生夕死的对象，所以发生非常频繁，速度也较快。</h4><h4 id="4-2-2-Full-GC也叫Major-GC是发生在老年代的GC，出现了Full-GC一般情况下同时也会伴随着Major-GC，当然这不绝对，通常情况下Full-GC的速度会比Minor-GC速度慢10倍以上。"><a href="#4-2-2-Full-GC也叫Major-GC是发生在老年代的GC，出现了Full-GC一般情况下同时也会伴随着Major-GC，当然这不绝对，通常情况下Full-GC的速度会比Minor-GC速度慢10倍以上。" class="headerlink" title="4.2.2 Full GC也叫Major GC是发生在老年代的GC，出现了Full GC一般情况下同时也会伴随着Major GC，当然这不绝对，通常情况下Full GC的速度会比Minor GC速度慢10倍以上。"></a>4.2.2 Full GC也叫Major GC是发生在老年代的GC，出现了Full GC一般情况下同时也会伴随着Major GC，当然这不绝对，通常情况下Full GC的速度会比Minor GC速度慢10倍以上。</h4><h3 id="4-3-为什么新生代中有两个Survivor？"><a href="#4-3-为什么新生代中有两个Survivor？" class="headerlink" title="4.3 为什么新生代中有两个Survivor？"></a>4.3 为什么新生代中有两个Survivor？</h3><p>4.3.1 这里就提到了为什么新生代中要有两个Survivor区？</p>
<p>提前说下结论：防止内存碎片的发生。</p>
<p>在此之前先来讨论下为什么要分新生代和老年代？</p>
<p>如果不分新生代和老年代的话那么每发生一次GC，就会对堆中的所有对象遍历，想象是不是都痛苦？</p>
<p>那么继续讨论为什么会有Survivor区？</p>
<p>如果没有Survivor区的话，那么发生一次Minor GC就会将存活的对象放入老年代，导致老年代被很快打满，发生Full GC，发生Full GC消耗的时间和资源是非常大的。这是不是也很坑？</p>
<p>那么为什么要有两个Survivor区？</p>
<p>之前讨论了为什么要有Survivor区，现在假设只有一个Survivor区，第一次发生Minor GC,Eden区中存活的对象放入Survivor区中，在下一次Minor GC发生的时候，Eden区中存活的对象在此放入Survivor区中,要知道此时Survivor中是存在对象的，可想而知这两次放入的对象是不连续的，会发生内存碎片。这样就顺理成章的要有两个Survivor区。</p>
<p>这时有一个问题，如果Eden + Survior区中存活的对象大于Survivor的大小，就会需要老年代进行担保，那么每次发生minor GC的时候，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果这个条件成立，那么Minor GC可以确保安全的执行，如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败，如果允许那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC,尽管这次Minor GC是有风险的；如果小于或者HandlePromotionFailure设置为不允许冒险，那这时也要改为一个Full GC。</p>
<h3 id="附上一些垃圾收集器的参数"><a href="#附上一些垃圾收集器的参数" class="headerlink" title="附上一些垃圾收集器的参数"></a>附上一些垃圾收集器的参数</h3><p><img src="../image/1.png" alt="1.png" title="1"><br><img src="../image/2.png" alt="2.png" title="2"></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>深入理解Java虚拟机</tag>
        <tag>Java内存区域与内存溢出异常</tag>
      </tags>
  </entry>
  <entry>
    <title>事务隔离：为什么你改了我看不见？</title>
    <url>/2019/10/20/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E6%94%B9%E4%BA%86%E6%88%91%E7%9C%8B%E4%B8%8D%E8%A7%81%EF%BC%9F/</url>
    <content><![CDATA[<p>这篇讲的是事务隔离，个人了解的还不够多，所以就把最基础的写上，后面的等搞懂了再重新更新下。<br>提到事务，你肯定不陌生，和数据库打交道的时候，我们总是会用到事务。最经典的例子就是转账，你要给朋友小王转 100 块钱，而此时你的银行卡只有 100 块钱。<br>转账过程具体到程序里会有一系列的操作，比如查询余额、做加减法、更新余额等，这些操作必须保证是一体的，不然等程序查完之后，还没做减法之前，你这 100 块钱，完全可以借着这个时间差再查一次，然后再给另外一个朋友转账，如果银行这么整，不就乱了么？这时就要用到“事务”这个概念了。<br>简单来说，事务就是要保证一组数据库操作，要么全部成功，要么全部失败。在 MySQL 中，事务支持是在引擎层实现的。你现在知道，MySQL 是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如 MySQL 原生的 MyISAM 引擎就不支持事务，这也是 MyISAM 被 InnoDB 取代的重要原因之一。  </p>
<h3 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="headerlink" title="隔离性与隔离级别"></a>隔离性与隔离级别</h3><p>提到事务肯定会想到ACID（原子性，一致性，隔离性，持久性），这节主要讲的是隔离性。<br>当数据库有多个事务同时执行的时候，就可能会出现脏读，不可重复读，幻读的问题，为了解决这些问题，就有了“隔离级别”的概念。<br>在谈隔离级别之前，要了解的是隔离的越严实，效率就会越低，因此很多时候都要在二者之间寻找一个平衡点，SQL标准的隔离级别包括：读未提交，读已提交，可重复读，串行化。<br>读未提交是指，一个事务还没提交时，就能被其他的事务看见。<br>读已提交是指，一个事务提交后才能被其他的事务看见。<br>可重复读是指一个事务在执行过程中看到的数据总是和事务执行时看到的数据保持一致。<br>串行化，顾名思义对于同一行记录，“写”会加“写锁”，“读”会加“读锁”，当出现读写锁冲突的时候，后访问的事务必须等到前一个事务执行完成，才能继续执行。<br>下面举个例子来更好理解：  </p>
<p><img src="../image/%E4%BA%8B%E5%8A%A1.png" alt="事务.png" title="事务">  </p>
<p>来看一下，在不同隔离级别下，事务A会有哪些不同的返回结果，V1，V2，V3的返回值分别是什么。</p>
<p>若隔离级别是“读未提交”：V1就是2，事务B还没有提交就被A看到了，同样V2，V3也是2  </p>
<p>若隔离级别是“读已提交”：V1是1，V2，V3是2，事务B提交后A才能看见改变。  </p>
<p>若隔离级别是“可重复读”：V1，V2是1，V3是2，同一个事务才执行中和执行开始的值应该是一样的，V3在事务A提交后可以看到事务B的改变。  </p>
<p>若隔离级别是“串行化”：V1，V2是1，V3是2，当事务B执行“将1改为2的时候”会被锁住，直到事务A提交后才能改变。  </p>
<p>在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图实在事务启动时创建的，整个事务存在期间都用这个视图。在“读已提交”隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图的概念，而“串行化”隔离级别下直接用加锁的方式来避免并行访问。<br>我们可以看到在不同的隔离级别下，数据库行为是有所不同的。Oracle数据库的默认隔离级别其实就是“读提交”，因此对于一些从Oracle迁移到MySQL的应用，为保证数据库隔离级别的一致，你一定要记得将MySQL的隔离级别设置为“读提交”。  </p>
<p>配置的方式是，将启动参数transaction的值设置成READ-COMMITTED。你可以用show variables来查看当前的值。<br>总结来说，存在即合理，哪个隔离级别都有它自己的使用场景，你要根据自己的业务情况来定。那么什么时候需要“可重复读”的场景呢？我们来看一个校对逻辑的案例。<br>假设你在管理一个个人银行账户表。一个表存了每个月月底的余额，一个表存了账单明细。这时候你要做数据校对，也就是判断上个月的余额和当月余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。  </p>
<h3 id="事务隔离的实现"><a href="#事务隔离的实现" class="headerlink" title="事务隔离的实现"></a>事务隔离的实现</h3><p>理解了事务的隔离级别，我们再来看看事务隔离具体是怎么实现的。这里我们展开说明“可重复读”。  </p>
<p>在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。<br>假设一个值从1被按顺序改成了2，3，4，在回滚日志里面就会有类似下面的记录。  </p>
<p><img src="../image/%E5%9B%9E%E6%BB%9A%E6%AE%B5.png" alt="回滚段.png" title="回滚段">    </p>
<p>当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不用的read-view。如图中看到的，在视图A，B，C里面，这一个记录的值分别是1，2，4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）对于read-view，要得到1，就必须将当前值依次执行图中所有的回滚操作得到。<br>同时你会发现，即使现在有另外一个事务正在将4改成5，这个事务跟read-viewA，B，C对应的事务是不会冲突的。<br>你一定会问，回滚日志总不能一直保留吧，什么时候删除呢？答案是，在不需要的时候才删除，也就是说，系统会判断，当没有事务在需要用到这些回滚日志时，回滚日志会被删除。  </p>
<p>什么时候才不需要了呢？<br>就时当系统里没有比这个回滚日志更早的read-view的时候。<br>基于上面的说明，我们来讨论一下为什么建议你尽量不要使用长事务。<br>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。<br>在MySQL5.5及以前的版本，回滚日志时跟数据字典一起放在ibdata文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。我见过数只有20GB，而非回滚段有200GB的库，最终只好为了清理回滚段，重建整个库。<br>除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库，后面讲锁的时候还会展开说。 </p>
<h3 id="事务的启动方式"><a href="#事务的启动方式" class="headerlink" title="事务的启动方式"></a>事务的启动方式</h3><p>如前面所述，长事务有这些潜在风险，我当然是建议你尽量避免。其实很多时候业务开发同学并不是有意使用长事务，通常是由于误用所致。MySQL的事务启动方式有以下几种：<br>1.显示启动事务语句，begin活start transaction。配套的提交语句是commit，回滚语句是rollback，或者断开连接。<br>有些客户端连接框架会默认连接成功后先执行一个set autocommit = 0的命令。这就导致接下来的查询都在事务中，如果是长链接，就导致了意外的长事务。<br>因此，我会建议你总是使用set autocommit = 1，通过显式语句的方式来启动事务。   </p>
<p>ps：这里解释一下set autocommit = 1  autocommit指的是事务，如果set autocommit = 0那么所有的语句一定是在一个事务里。在这种情况下，如果使用连接池，并且在查询之前没有rollback或者set autocommit = 1，那么就悲剧了，因为根据mysql的默认事务级别，可重复读，永远也取不到这个事务被开户前的数据。另外一点set autocommit = 0，会自动提交前一个事务，因此正确的做法是rollback ，set autocommit = 0，完成之后在set autocommit<br> = 1  </p>
<p>但有的开发同学会纠结“多一次交互”的问题，对于一个需要频繁使用事务的业务，第二种方式每个事务在开始时都不需要主动执行一次“begin”，减少了语句的交互次数。如果你也有这个顾虑，我建议你commit work and chain语法。<br>在autocommit为1的情况下，用beigin显示启动的事务，如果执行commit则提交事务。如果执行commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行begin语句的开销，同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。  </p>
<p>你可以在information_schema库的innodb_trx这个表中查询长事务，比如下面这个语句，用于查找持续时间超过60s的事务。  </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.innodb_trx <span class="keyword">where</span> TIME_TO_SET(<span class="keyword">timediff</span>(<span class="keyword">now</span>(),trx_started)) &gt; <span class="number">60</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>日志系统：一条SQL更新语句是如何执行的？</title>
    <url>/2019/10/20/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%EF%BC%9A%E4%B8%80%E6%9D%A1SQL%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9F/</url>
    <content><![CDATA[<h3 id="MySQL实战45讲-第二讲"><a href="#MySQL实战45讲-第二讲" class="headerlink" title="MySQL实战45讲-第二讲"></a>MySQL实战45讲-第二讲</h3><p>上一节讲了一条查询语句是如何执行的，这节讲述的是一条更新语句的执行过程。<br>常听DBA的同事说，MySQL可以恢复到半个月内任意一秒的状态，那么是如何做到的呢？<br>还是以一条SQL语句开始<br><code>create table user(ID int primary key,c int)</code><br>如果要将ID = 2这一行的值加1，SQL语句会这么写：<br><code>update user set c = c + 1 where ID = 2</code><br>之前说的查询的链路，在执行更新语句的时候也会走一遍，因为对某张表的更新，需要先找到这张表。<br>与查询流程不一样的是，更新流程还涉及两个重要的日志模块redolog(重做日志)和binlog(归档日志)。接下来详细讨论下。 </p>
<h3 id="重要的日志模块：redo-log"><a href="#重要的日志模块：redo-log" class="headerlink" title="重要的日志模块：redo log"></a>重要的日志模块：redo log</h3><p>老师举了一个例子，是拿《孔乙己》里酒店掌柜有一个粉板，专门用来记录客人的赊帐记录。如果赊帐的人不多，那么他可以先讲顾客和账单记录在粉板上；但如果赊帐的人多了，就一定有一个专门记录赊帐的账本。<br>如果有人要赊帐或者还帐的话，掌柜有两种做法：<br>1⃣️：先讲顾客和账单记录在粉板上，等不忙的时候在去账本上更新一下。<br>2⃣️：有人来就拿出账本去找到顾客的记录来更新。<br>当店里生意红火的时候很明显的看出来是第一种方式更加的高效。<br>同样的MySQL里更新数据库的时候也会有同样的问题，如果每次更新操作都写入磁盘里，然后磁盘也要找到对应的那条记录，然后在更细，整个过程的IO成本，查询成本都很高，为了解决这个问题，MySQL的设计者，就用了类似酒店掌柜的粉板思路来提升更新效率。<br>而粉板和账本配合的过程中，就是MySQL说的WAL技术，WAL的全称是Write-Ahead Logging,简单解释就是先写日志，在写磁盘，也就是先写粉板，等不忙的时候在写磁盘。<br>具体来说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log(粉板)里，并更新内存，这个时候就算更新完成了，同时InnoDB引擎会在适当时候，讲这个操作更新到磁盘里，而这个更新往往是在系统比较空闲的时候做。<br>但如果某一天赊帐的人突然很多，粉板记录不下怎么办？这个时候掌柜只好停下手中的活儿，把粉板中的一部分赊帐记录更新到账本中，然后将这些记录从粉板上擦掉，为新账腾出空间。<br>与此类似，InnoDB的redo log大小是固定的，比如可以配置一组4个文件，每个文件的大小是1GB，所以这块粉板就可以存储4GB的操作，从头开始写，写到末尾就又从头开始写，如下面这个图一样  </p>
<p><img src="../image/redolog.png" alt="redolog.png" title="redolog">  </p>
<p>write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。checkpoint是当前要擦出的位置，也是往后推移并且循环的，擦出记录前要把记录更新到数据文件，<br>write pos和checkpoint之间的“粉板”上还空着的部分，可以用来记录新的操作，如果write pos追上checkpoint，表示“粉板”满了，这时候不能在执行新的更新，得停下来先擦掉一些记录，把checkpoint推进一下。<br>有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe。 </p>
<h3 id="什么是crash-safe？"><a href="#什么是crash-safe？" class="headerlink" title="什么是crash-safe？"></a>什么是crash-safe？</h3><p>crash-safe是MySQL5.6版本的新特性，要理解crash-safe这个概念，可以想想我们前面赊帐记录的例子。只要赊帐记录记在了粉板或者写在了账本上，之后即便掌柜忘记了，比如突然停业几天，恢复生意后依然可以通过账本和粉板上的数据明确赊帐账目。  </p>
<h3 id="crash-unsafe"><a href="#crash-unsafe" class="headerlink" title="crash-unsafe?"></a>crash-unsafe?</h3><p>在了解crash-safe前，先分析一下在MySQL5.6版本之前出现slave(从) crash-unsafe的原因。我们知道在一套主从结构体系中，slave包含两个线程：即IO thread和SQL thread。两个线程的执行进度（偏移量）都保存在文件中。<br><code>IO thread负责从master拉取binlog文件（下面会讲到）并保存到本地的relay-log文件中</code><br><code>SQL thread负责执行重复sql，执行relay-log记录的日志</code><br>IO thread的执行状态信息保存在master.info文件，SQL thread的执行状态信息保存在relay-log.info文件。salve运行正常的情况下，记录位点没有问题，但是每当系统发生crash，存储的偏移量可能是不准确的（需要注意的是这些文件被修改后不是同步写入磁盘的）。因为应用binlog和更新位点信息到文件不是原子操作，而是两个独立的步骤。比如SQL thread已经应用relay-log.01的4个事务<br><code>trx1(pos:10)</code><br><code>trx2(pos:20)</code><br><code>trx3(pos:30)</code><br><code>trx4(pos:40)</code><br>但是SQL thread更新位点（relay-log.01,30）到relay-log.info文件中，slave实例重启的时候sql thread会重复执行trx4。<br>看到这里我们大概了解了，发生crash-unsafe的主要原因是应用binlog和更新位点不是原子操作，所以MySQL的解决办法是将两个操作融合成一个事务，这样就保证了原子性。  </p>
<h3 id="重要的日志模块：binlog"><a href="#重要的日志模块：binlog" class="headerlink" title="重要的日志模块：binlog"></a>重要的日志模块：binlog</h3><p>前面说过，MySQL整体来看，其实就有两大部分，一部分是server层，它主要做的是MySQL功能层面的事情，还有一块是引擎层，负责存储相关的具体事宜，上面我们聊到的粉板redo log是InnoDB引擎层特有日志，而Server层也有自己的日志，称为binlog（归档日志).<br>为什么会有两份日志呢？<br>因为最开始MySQL中并没有InnoDB引擎，MySQL自带的是MyISAM，但是MyISAM没有crash-safe的能力，binlog日志只能用于归档，而InnoDB是另一个公司以插件形式引入MySQL中的，既然只靠binlog是没有crash-safe能力的，所以InnoDB使用另外一套日志系统-也就是redo log来实现crash-safe能力。<br>这两种日志有以下三点不同。<br>1.redo log是InnoDB引擎特有的，binlog是MySQL的Server层实现的，所有引擎层都可以使用。<br>2.redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如”给ID = 2这一行的c字段加1“<br>3.redo log是循环写的，空间固定会用完；binlog是可以追加写入的。”追加写“是指binlog文件写到一定大小后会切换到下一个，并不户覆盖以前的日志。<br>有了对这两个日志的概念性的理解，我们再来看执行器InnoDB引擎在执行这个简单的update语句时的内部流程。<br>(1).执行器先找引擎取ID = 2这一行，ID是主键，引擎直接用树搜索找到这一行，如果ID = 2这一行所在的数据页本来就在内存中，就直接返回给执行器，否则，需要先从磁盘读入内存，然后在返回。<br>(2).执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，在调用引擎接口写入这行新数据。<br>(3).引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里，此时redo log处于prepare状态，然后告知执行器执行完成了，随时可以提交事务。<br>(4).执行器生成这个操作的binlog，并把binlog写入磁盘。<br>(5).执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。<br>下面给出的是课程中给出的流程图，浅色框表示实在InnoDB内部执行的，深色框表示是在执行器中执行的。   </p>
<p><img src="../image/update%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="update执行流程.png" title="update执行流程">  </p>
<p>后面三步为什么把redo log拆成两个步骤：prepare和commit，这就是“两阶段提交“  </p>
<h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><p>还记不记得开头的那个问题：怎样让数据库恢复到半个月内任意一秒的状态？<br>前面我们说过，binlog会记录所有的逻辑操作，并且是采用“追加写”的形式。如果你的DBA承诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月内的所有binlog，同时系统会定期做整库备份。这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备。<br>当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做：<br>首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库；<br>然后，从备份的时间点开始，将备份的binlog依次取出来，重放到中午误删表之前的那个时刻。<br>这样你的临时库就喝误删之前的线上库一样了，然后你可以把表数据从临时库取出来，按需恢复到线上库去。说完了这个问题，再回过头来说为什么一定要有”两阶段提交“ ，为什么必须有”两阶段提交“呢？这是为了让两份日志之间的逻辑一致，如果不用两阶段提交看看会发生什么？<br>不使用两阶段提交无非两种情况：<br>1.先写redo log后写binlog。假设在redo写完，binlog还没有写完的时候，MySQL进程异常重启，由于前面说过，redo log写完之后，系统及时崩溃，仍然能够把数据恢复回来，所以恢复这一行c的值是1。<br>但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句，因此，之后备份日志的时候，存起来的binlog里面就没有这条语句。然后你会发现，如果需要用这个binlog来恢复临时库的话，由于语句的binlog丢失，这个临时库就会少了一次更新，恢复出来的这一行c的值就是0，与原库的值不同。<br>2.先写binlog后写redo log。如果在binlog写完之后异常重启，由于redo log还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0，但是binlog里面记录了“把c从0改成1”这个日志，所以，在之后用binlog恢复临时库的时候就多了一个事务出来，恢复出来的这一行c的值就是1，与原库的值不同。<br>可以看到如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库状态不一致。<br>可能会有疑问，这个概率是不是很低，平时也没有什么动不动就需要恢复临时库的场景呀？<br>其实不是，不只是误操作后需要用这个过程来恢复数据，当你需要扩容的时候，也就是需要再多搭建一些备库来增加系统的读能力的时候，现在常见的做法也是用全量备份加上应用binlog来实现的，这个“不一致”就会导致你的线上出现主从数据库不一致的情况。<br>简单说，redo log和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。  </p>
<p>其实redo log记录的就是数据，而binlog有两种模式，statement格式的话是记sql语句，row格式会记录行的内容，记两条，更新前和更新后都有。  </p>
<h3 id="课后问题"><a href="#课后问题" class="headerlink" title="课后问题"></a>课后问题</h3><p>一天一备和一周一备的对比？<br>好处是“最长恢复时间”更短。<br>在一天一备的模式里，最坏情况下需要应用一天的binlog，比如，每天0点做一次全量备份，而要恢复出一个到昨天晚上23点的备份。<br>一周一备的最坏情况就要应用一周的binlog了。系统对应指标就是RTO了。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>bin log</tag>
        <tag>redo log</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出索引</title>
    <url>/2019/10/26/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>这节讲的是索引的相关知识，提到索引相信大家都不会陌生，在工作中或多或少都会接触过，建立索引主要是用来提升SQL查询速度的一种解决方案。<br>那么索引是什么？<br>一句话简单来说，索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。  </p>
<h3 id="索引的常见模型"><a href="#索引的常见模型" class="headerlink" title="索引的常见模型"></a>索引的常见模型</h3><p>这里引入三种模型，哈希表有序数组和搜索树  </p>
<p>哈希表是一种以建-值（key-value）存储的数据结构，我们只要输入待查找的key，就能找到value。哈希的思路很简单，把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置。<br>不可避免的，多个key经过哈希函数的换算会出现同一个值的情况，处理这种情况的方式是，拉出一个链表。<br>假设，你现在维护着一个身份证信息和姓名的表，需要根据身份证号查找对应的名字。这时对应的哈希索引的示意图如下所示。  </p>
<p><img src="../image/%E5%93%88%E5%B8%8C%E8%A1%A8.png" alt="哈希表.png" title="哈希表">  </p>
<p>需要注意的是，图中四个ID_card_n的值并不是递增的，这样做的好处是增加新的User时速度会很快，只需要往后追加。但缺点是，因为不是有序的，所以哈希索引做区间查询速度是很慢的。  </p>
<p>所以，哈希表这种结构适用于只有等值查询的场景，比如 Memcached 及其他一些 NoSQL 引擎。  </p>
<p>而有序数组在等值查询和范围查询场景的性能就都非常优秀。还是根据上面这个例子，如果用有序数组来实现的话，示意图如下所示：  </p>
<p><img src="../image/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84.png" alt="有序数组.png" title="有序数组">  </p>
<p>这里假设身份证号没有重复，这个数组就是按照身份证号递增的顺序保存的，这个时候如果你要查ID_card_n2对应的名字，用二分法就可以快速得到，这个时间复杂度是O(log(N)).<br>同时很显然，这个索引结构支持范围查询。你要查身份证号在[ID_card_X,ID_card_Y]区间的User，可以先用二分法找到ID_card_X(如果不存在ID_card_X，就找到大于ID_card_X的第一个User)，然后向右遍历，直到查到第一个大于ID_card_Y的身份证号，推出循环。<br>如果仅仅看查询效率，有序数组就是最好的数据结构了，但是在更新数据的时候，如果有新增的数据，就需要挪动后续所有的记录，成本太高。<br>所以，有序数组只适用于静态存储引擎，比如你要保存的是2019年某个城市所有人口的信息，这类不会再修改的数据。<br>二叉搜索树是经典的数据结构了，还是根据上面的例子，如果我们用二叉搜索树来实现的话，示意图如下所示，</p>
<p><img src="../image/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.png" alt="二叉搜索树.png" title="二叉搜索树">  </p>
<p>二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子，这样如果你要查ID_card_2的话按照图中的顺序就是按照UserA -&gt; UserC -&gt; UserF -&gt; User2这个路径得到。这个时间复杂度是O(log(N))。<br>当然为了维持O(log(N))的查询复杂度，你就需要保持这颗树是平衡二叉树，为了做这个保证，更新的时间复杂度也是O(log(N))。<br>树可以有二叉，也可以有多叉，多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右递增。二叉搜索树的效率是最高的，但是实际上大多数数据库存储却并不适用二叉树。其原因是，索引不止存在于内存中，还要写到磁盘上。<br>你可以想象一下一棵100万节点的平衡二叉树，树高20，一次查询可能需要访问20个数据块，在机械硬盘时代，从磁盘随机读取一个数据块需要10ms的寻址时间，也就是说，对于一个100万行的表，如果使用二叉树来存储，单独访问一个行可能需要20个10ms的时间，这个查询可真够慢的，为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N 叉”树。这里，“N 叉”树中的“N”取决于数据块的大小。以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。考虑到树根的数据块总是在内存中的，一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。</p>
<p>N 叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。  </p>
<h3 id="InnoDB的索引模型"><a href="#InnoDB的索引模型" class="headerlink" title="InnoDB的索引模型"></a>InnoDB的索引模型</h3><p>大家都知道InnoDB的索引模型是B+树，假设我们有一个主键列为ID的表，表中有字段K，并且在K上有索引，如下图所示：  </p>
<p><img src="../image/InnoDB%E7%B4%A2%E5%BC%95.png" alt="InnoDB索引.png" title="InnoDB索引">  </p>
<p>从图中不难看出，根据叶子节点的内容，索引类型分为主键索引和非主键索引。</p>
<p>主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。  </p>
<p>非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。</p>
<p>根据上面的索引结构说明，我们来讨论一个问题：基于主键索引和普通索引的查询有什么区别？</p>
<p>如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；<br>如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为_回表_。<br>也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。   </p>
<p>除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。</p>
<p>当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。</p>
<p>基于上面的索引维护过程说明，我们来讨论一个案例：</p>
<p>你可能在一些建表规范里面见到过类似的描述，要求建表语句里一定要有自增主键。当然事无绝对，我们来分析一下哪些场景下应该使用自增主键，而哪些场景下不应该。</p>
<p>自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。</p>
<p>插入新记录的时候可以不指定 ID 的值，系统会获取当前 ID 最大值加 1 作为下一条记录的 ID 值。</p>
<p>也就是说，自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。</p>
<p>而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。</p>
<p>除了考虑性能外，我们还可以从存储空间的角度来看。假设你的表中确实有一个唯一字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？</p>
<p>由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约 20 个字节，而如果用整型做主键，则只要 4 个字节，如果是长整型（bigint）则是 8 个字节。</p>
<p>显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</p>
<p>所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。</p>
<p>有没有什么场景适合用业务字段直接做主键的呢？还是有的。比如，有些业务的场景需求是这样的：</p>
<p>只有一个索引；</p>
<p>该索引必须是唯一索引。</p>
<p>你一定看出来了，这就是典型的 KV 场景。</p>
<p>由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。</p>
<p>这时候我们就要优先考虑上一段提到的“尽量使用主键查询”原则，直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。 </p>
<p>对于一张表可以这么理解：<br>每一张表其实就是好几个B+树，树结点的key值就是某一行的主键，value是该行的其他数据。新建索引就是新增一个B+树，查询不走索引就是遍历主B+树。</p>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>如果执行的语句是 select ID from T where k between 3 and 5，这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引 k 已经“覆盖了”我们的查询需求，我们称为覆盖索引。</p>
<p>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</p>
<p>需要注意的是，在引擎内部使用覆盖索引在索引 k 上其实读了三个记录，R3~R5（对应的索引 k 上的记录项），但是对于 MySQL 的 Server 层来说，它就是找引擎拿到了两条记录，因此 MySQL 认为扫描行数是 2。  </p>
<p>基于上面覆盖索引的说明，我们来讨论一个问题：在一个市民信息表上，是否有必要将身份证号和名字建立联合索引？  </p>
<p>我们知道，身份证号是市民的唯一标识。也就是说，如果有根据身份证号查询市民信息的需求，我们只要在身份证号字段上建立索引就够了。而再建立一个（身份证号、姓名）的联合索引，是不是浪费空间？</p>
<p>如果现在有一个高频请求，要根据市民的身份证号查询他的姓名，这个联合索引就有意义了。它可以在这个高频请求上用到覆盖索引，不再需要回表查整行记录，减少语句的执行时间。</p>
<p>当然，索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这正是业务 DBA，或者称为业务数据架构师的工作。  </p>
<h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>对于最左前缀原则大家都应该轻车熟路了，就不过多介绍，有些重点内容可以考虑一下：<br>基于上面对最左前缀索引的说明，我们来讨论一个问题：在建立联合索引的时候，如何安排索引内的字段顺序。</p>
<p>这里我们的评估标准是，索引的复用能力。因为可以支持最左前缀，所以当已经有了 (a,b) 这个联合索引后，一般就不需要单独在 a 上建立索引了。因此，第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。  </p>
<p>所以现在你知道了，这段开头的问题里，我们要为高频请求创建 (身份证号，姓名）这个联合索引，并用这个索引支持“根据身份证号查询地址”的需求。</p>
<p>那么，如果既有联合查询，又有基于 a、b 各自的查询呢？查询条件里面只有 b 的语句，是无法使用 (a,b) 这个联合索引的，这时候你不得不维护另外一个索引，也就是说你需要同时维护 (a,b)、(b) 这两个索引。</p>
<p>这时候，我们要考虑的原则就是空间了。比如上面这个市民表的情况，name 字段是比 age 字段大的 ，那我就建议你创建一个（name,age) 的联合索引和一个 (age) 的单字段索引。  </p>
<h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>上一段我们说到满足最左前缀原则的时候，最左前缀可以用于在索引中定位记录。这时，你可能要问，那些不符合最左前缀的部分，会怎么样呢？</p>
<p>我们还是以市民表的联合索引（name, age）为例。如果现在有一个需求：检索出表中“名字第一个字是张，而且年龄是 10 岁的所有男孩”。那么，SQL 语句是这么写的：   </p>
<p><code>mysql&gt; select * from tuser where name like &#39;张 %&#39; and age=10 and ismale=1;</code></p>
<p>你已经知道了前缀索引规则，所以这个语句在搜索索引树的时候，只能用 “张”，找到第一个满足条件的记录 ID3。当然，这还不错，总比全表扫描要好。</p>
<p>然后呢？</p>
<p>当然是判断其他条件是否满足。</p>
<p>在 MySQL 5.6 之前，只能从 ID3 开始一个个回表。到主键索引上找出数据行，再对比字段值。</p>
<p>而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p>
<p>图 3 和图 4，是这两个过程的执行流程图。</p>
<p><img src="../image/%E5%9B%BE3.png" alt="图3.png" title="图3">  </p>
<p><img src="../image/%E5%9B%BE3.png" alt="图3.png" title="图3">  </p>
<p>在图 3 和 4 这两个图里面，每一个虚线箭头表示回表一次。</p>
<p>图 3 中，在 (name,age) 索引里面我特意去掉了 age 的值，这个过程 InnoDB 并不会去看 age 的值，只是按顺序把“name 第一个字是’张’”的记录一条条取出来回表。因此，需要回表 4 次。</p>
<p>图 4 跟图 3 的区别是，InnoDB 在 (name,age) 索引内部就判断了 age 是否等于 10，对于不等于 10 的记录，直接判断并跳过。在我们的这个例子中，只需要对 ID4、ID5 这两条记录回表取数据判断，就只需要回表 2 次。</p>
<h3 id="课后问题"><a href="#课后问题" class="headerlink" title="课后问题"></a>课后问题</h3><p>实际上主键索引也是可以使用多个字段的。DBA 小吕在入职新公司的时候，就发现自己接手维护的库里面，有这么一个表，表结构定义类似这样的：</p>
<pre><code class="sql"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`geek`</span> (
  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,
  <span class="string">`b`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,
  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,
  <span class="string">`d`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,
  PRIMARY <span class="keyword">KEY</span> (<span class="string">`a`</span>,<span class="string">`b`</span>),
  <span class="keyword">KEY</span> <span class="string">`c`</span> (<span class="string">`c`</span>),
  <span class="keyword">KEY</span> <span class="string">`ca`</span> (<span class="string">`c`</span>,<span class="string">`a`</span>),
  <span class="keyword">KEY</span> <span class="string">`cb`</span> (<span class="string">`c`</span>,<span class="string">`b`</span>)
) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</code></pre>
<p>公司的同事告诉他说，由于历史原因，这个表需要 a、b 做联合主键，这个小吕理解了。</p>
<p>但是，学过本章内容的小吕又纳闷了，既然主键包含了 a、b 这两个字段，那意味着单独在字段 c 上创建一个索引，就已经包含了三个字段了呀，为什么要创建“ca”“cb”这两个索引？</p>
<p>同事告诉他，是因为他们的业务里面有这样的两种语句：  </p>
<pre><code class="sql"><span class="keyword">select</span> * <span class="keyword">from</span> geek <span class="keyword">where</span> c=N <span class="keyword">order</span> <span class="keyword">by</span> a <span class="keyword">limit</span> <span class="number">1</span>;
<span class="keyword">select</span> * <span class="keyword">from</span> geek <span class="keyword">where</span> c=N <span class="keyword">order</span> <span class="keyword">by</span> b <span class="keyword">limit</span> <span class="number">1</span>;</code></pre>
<p>我给你的问题是，这位同事的解释对吗，为了这两个查询模式，这两个索引是否都是必须的？为什么呢？  </p>
<p>解答：  </p>
<p>表记录  </p>
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>c</th>
<th>d</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2</td>
<td>3</td>
<td>d</td>
</tr>
<tr>
<td>1</td>
<td>3</td>
<td>2</td>
<td>d</td>
</tr>
<tr>
<td>1</td>
<td>4</td>
<td>3</td>
<td>d</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>3</td>
<td>d</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>2</td>
<td>d</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>4</td>
<td>d</td>
</tr>
</tbody></table>
<p>主键 a，b 的聚簇索引组织顺序相当于 order by a,b ，也就是先按 a 排序，再按 b 排序，c 无序。</p>
<p>索引 ca 的组织是先按 c 排序，再按 a 排序，同时记录主键<br>（注意，这里不是 ab，而是只有 b）</p>
<table>
<thead>
<tr>
<th>c</th>
<th>a</th>
<th>主键部分b</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>2</td>
<td>3</td>
</tr>
</tbody></table>
<p>这个跟索引 c 的数据是一模一样的。</p>
<p>索引 cb 的组织是先按 c 排序，在按 b 排序，同时记录主键  </p>
<table>
<thead>
<tr>
<th>c</th>
<th>b</th>
<th>主键部分a</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>4</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>3</td>
<td>2</td>
</tr>
</tbody></table>
<p>所以，结论是 ca 可以去掉，cb 需要保留。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈MVCC</title>
    <url>/2020/03/23/%E6%B5%85%E8%B0%88MVCC/</url>
    <content><![CDATA[<h2 id="事前准备"><a href="#事前准备" class="headerlink" title="事前准备"></a>事前准备</h2><h3 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h3><p>对于使用InnoDB存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列（row_id并不是必要的，我们创建的表中有主键或者非NULL唯一键时都不会包含row_id列）：</p>
<ol>
<li>trx_id：每次对某条聚簇索引记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。</li>
<li>roll_pointer：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li>
</ol>
<h4 id="比方说我们的表t现在只包含一条记录："><a href="#比方说我们的表t现在只包含一条记录：" class="headerlink" title="比方说我们的表t现在只包含一条记录："></a>比方说我们的表t现在只包含一条记录：</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM t;</span><br><span class="line">+<span class="comment">----+--------+</span></span><br><span class="line">| id | c      |</span><br><span class="line">+<span class="comment">----+--------+</span></span><br><span class="line">|  1 | 刘备   |</span><br><span class="line">+<span class="comment">----+--------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<p>复制代码假设插入该记录的事务id为80，那么此刻该条记录的示意图如下所示：</p>
<p><img src="../image/MVCC1.png" alt="MVCC1.png" title="MVCC1"><br>假设之后两个id分别为100、200的事务对这条记录进行UPDATE操作，操作流程如下：</p>
<p><img src="../image/MVCC2.png" alt="MVCC2.png" title="MVCC2">  </p>
<ol>
<li>小贴士： 能不能在两个事务中交叉更新同一条记录呢？哈哈，这是不可以滴，第一个事务更新了某条记录后，就会给这条记录加锁，另一个事务再次更新时就需要等待第一个事务提交了，把锁释放之后才可以继续更新。本篇文章不是讨论锁的，有关锁的更多细节我们之后再说。</li>
</ol>
<p>每次对记录进行改动，都会记录一条undo日志，每条undo日志也都有一个roll_pointer属性（INSERT操作对应的undo日志没有该属性，因为该记录并没有更早的版本），可以将这些undo日志都连起来，串成一个链表，所以现在的情况就像下图一样：</p>
<p><img src="../image/MVCC3.png" alt="MVCC3.png" title="MVCC3">  </p>
<p>对该记录每次更新后，都会将旧值放到一条undo日志中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被roll_pointer属性连接成一个链表，我们把这个链表称之为版本链，版本链的头节点就是当前记录最新的值。另外，每个版本中还包含生成该版本时对应的事务id，这个信息很重要，我们稍后就会用到。</p>
<h3 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h3><p>对于使用READ UNCOMMITTED隔离级别的事务来说，直接读取记录的最新版本就好了，对于使用SERIALIZABLE隔离级别的事务来说，使用加锁的方式来访问记录。对于使用READ COMMITTED和REPEATABLE READ隔离级别的事务来说，就需要用到我们上边所说的版本链了，核心问题就是：需要判断一下版本链中的哪个版本是当前事务可见的。所以设计InnoDB的大叔提出了一个ReadView的概念，这个ReadView中主要包含当前系统中还有哪些活跃的读写事务，把它们的事务id放到一个列表中，我们把这个列表命名为为m_ids。这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：</p>
<ol>
<li>如果被访问版本的trx_id属性值小于m_ids列表中最小的事务id，表明生成该版本的事务在生成ReadView前已经提交，所以该版本可以被当前事务访问。</li>
<li>如果被访问版本的trx_id属性值大于m_ids列表中最大的事务id，表明生成该版本的事务在生成ReadView后才生成，所以该版本不可以被当前事务访问。</li>
<li>如果被访问版本的trx_id属性值在m_ids列表中最大的事务id和最小事务id之间，那就需要判断一下trx_id属性值是不是在m_ids列表中，如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</li>
</ol>
<p>如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本，如果最后一个版本也不可见的话，那么就意味着该条记录对该事务不可见，查询结果就不包含该记录。</p>
<p>在MySQL中，READ COMMITTED和REPEATABLE READ隔离级别的的一个非常大的区别就是它们生成ReadView的时机不同，我们来看一下。</p>
<h3 id="READ-COMMITTED-—-每次读取数据前都生成一个ReadView"><a href="#READ-COMMITTED-—-每次读取数据前都生成一个ReadView" class="headerlink" title="READ COMMITTED — 每次读取数据前都生成一个ReadView"></a>READ COMMITTED — 每次读取数据前都生成一个ReadView</h3><p>比方说现在系统里有两个id分别为100、200的事务在执行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Transaction 100</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> c = <span class="string">'关羽'</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> c = <span class="string">'张飞'</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Transaction 200</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ol>
<li>小贴士： 事务执行过程中，只有在第一次真正修改记录时（比如使用INSERT、DELETE、UPDATE语句），才会被分配一个单独的事务id，这个事务id是递增的。</li>
</ol>
<p>此刻，表t中id为1的记录得到的版本链表如下所示：</p>
<p><img src="../image/MVCC4.png" alt="MVCC4.png" title="MVCC4"></p>
<p>假设现在有一个使用READ COMMITTED隔离级别的事务开始执行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用READ COMMITTED隔离级别的事务</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># SELECT1：Transaction 100、200未提交</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>; <span class="comment"># 得到的列c的值为'刘备'</span></span><br></pre></td></tr></table></figure>

<p>这个SELECT1的执行过程如下：</p>
<p>在执行SELECT语句时会先生成一个ReadView，ReadView的m_ids列表的内容就是[100, 200]。</p>
<p>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列c的内容是’张飞’，该版本的trx_id值为100，在m_ids列表内，所以不符合可见性要求，根据roll_pointer跳到下一个版本。</p>
<p>下一个版本的列c的内容是’关羽’，该版本的trx_id值也为100，也在m_ids列表内，所以也不符合要求，继续跳到下一个版本。</p>
<p>下一个版本的列c的内容是’刘备’，该版本的trx_id值为80，小于m_ids列表中最小的事务id100，所以这个版本是符合要求的，最后返回给用户的版本就是这条列c为’刘备’的记录。</p>
<p>之后，我们把事务id为100的事务提交一下，就像这样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Transaction 100</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> c = <span class="string">'关羽'</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> c = <span class="string">'张飞'</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>然后再到事务id为200的事务中更新一下表t中id为1的记录：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Transaction 200</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新了一些别的表的记录</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> c = <span class="string">'赵云'</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> c = <span class="string">'诸葛亮'</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>此刻，表t中id为1的记录的版本链就长这样：</p>
<p><img src="../image/MVCC5.png" alt="MVCC5.png" title="MVCC5"></p>
<p>然后再到刚才使用READ COMMITTED隔离级别的事务中继续查找这个id为1的记录，如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用READ COMMITTED隔离级别的事务</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># SELECT1：Transaction 100、200均未提交</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>; <span class="comment"># 得到的列c的值为'刘备'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SELECT2：Transaction 100提交，Transaction 200未提交</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>; <span class="comment"># 得到的列c的值为'张飞'</span></span><br></pre></td></tr></table></figure>

<p>这个SELECT2的执行过程如下：</p>
<p>在执行SELECT语句时会先生成一个ReadView，ReadView的m_ids列表的内容就是[200]（事务id为100的那个事务已经提交了，所以生成快照时就没有它了）。</p>
<p>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列c的内容是’诸葛亮’，该版本的trx_id值为200，在m_ids列表内，所以不符合可见性要求，根据roll_pointer跳到下一个版本。</p>
<p>下一个版本的列c的内容是’赵云’，该版本的trx_id值为200，也在m_ids列表内，所以也不符合要求，继续跳到下一个版本。</p>
<p>下一个版本的列c的内容是’张飞’，该版本的trx_id值为100，比m_ids列表中最小的事务id200还要小，所以这个版本是符合要求的，最后返回给用户的版本就是这条列c为’张飞’的记录。</p>
<p>以此类推，如果之后事务id为200的记录也提交了，再此在使用READ COMMITTED隔离级别的事务中查询表t中id值为1的记录时，得到的结果就是’诸葛亮’了，具体流程我们就不分析了。总结一下就是：使用READ COMMITTED隔离级别的事务在每次查询开始时都会生成一个独立的ReadView。</p>
<h3 id="REPEATABLE-READ-—在第一次读取数据时生成一个ReadView"><a href="#REPEATABLE-READ-—在第一次读取数据时生成一个ReadView" class="headerlink" title="REPEATABLE READ —在第一次读取数据时生成一个ReadView"></a>REPEATABLE READ —在第一次读取数据时生成一个ReadView</h3><p>对于使用REPEATABLE READ隔离级别的事务来说，只会在第一次执行查询语句时生成一个ReadView，之后的查询就不会重复生成了。我们还是用例子看一下是什么效果。</p>
<p>比方说现在系统里有两个id分别为100、200的事务在执行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Transaction 100</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> c = <span class="string">'关羽'</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> c = <span class="string">'张飞'</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Transaction 200</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>此刻，表t中id为1的记录得到的版本链表如下所示：</p>
<p><img src="../image/MVCC6.png" alt="MVCC6.png" title="MVCC6"></p>
<p>假设现在有一个使用REPEATABLE READ隔离级别的事务开始执行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用REPEATABLE READ隔离级别的事务</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># SELECT1：Transaction 100、200未提交</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>; <span class="comment"># 得到的列c的值为'刘备'</span></span><br></pre></td></tr></table></figure>

<p>这个SELECT1的执行过程如下：</p>
<p>在执行SELECT语句时会先生成一个ReadView，ReadView的m_ids列表的内容就是[100, 200]。</p>
<p>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列c的内容是’张飞’，该版本的trx_id值为100，在m_ids列表内，所以不符合可见性要求，根据roll_pointer跳到下一个版本。</p>
<p>下一个版本的列c的内容是’关羽’，该版本的trx_id值也为100，也在m_ids列表内，所以也不符合要求，继续跳到下一个版本。</p>
<p>下一个版本的列c的内容是’刘备’，该版本的trx_id值为80，小于m_ids列表中最小的事务id100，所以这个版本是符合要求的，最后返回给用户的版本就是这条列c为’刘备’的记录。</p>
<p>之后，我们把事务id为100的事务提交一下，就像这样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Transaction 100</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> c = <span class="string">'关羽'</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> c = <span class="string">'张飞'</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>然后再到事务id为200的事务中更新一下表t中id为1的记录：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Transaction 200</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新了一些别的表的记录</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> c = <span class="string">'赵云'</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> t <span class="keyword">SET</span> c = <span class="string">'诸葛亮'</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>此刻，表t中id为1的记录的版本链就长这样：</p>
<p><img src="../image/MVCC7.png" alt="MVCC7.png" title="MVCC7"></p>
<p>然后再到刚才使用REPEATABLE READ隔离级别的事务中继续查找这个id为1的记录，如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用REPEATABLE READ隔离级别的事务</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># SELECT1：Transaction 100、200均未提交</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>; <span class="comment"># 得到的列c的值为'刘备'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SELECT2：Transaction 100提交，Transaction 200未提交</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>; <span class="comment"># 得到的列c的值仍为'刘备'</span></span><br></pre></td></tr></table></figure>

<p>这个SELECT2的执行过程如下：</p>
<p>因为之前已经生成过ReadView了，所以此时直接复用之前的ReadView，之前的ReadView中的m_ids列表就是[100, 200]。</p>
<p>然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列c的内容是’诸葛亮’，该版本的trx_id值为200，在m_ids列表内，所以不符合可见性要求，根据roll_pointer跳到下一个版本。</p>
<p>下一个版本的列c的内容是’赵云’，该版本的trx_id值为200，也在m_ids列表内，所以也不符合要求，继续跳到下一个版本。</p>
<p>下一个版本的列c的内容是’张飞’，该版本的trx_id值为100，而m_ids列表中是包含值为100的事务id的，所以该版本也不符合要求，同理下一个列c的内容是’关羽’的版本也不符合要求。继续跳到下一个版本。</p>
<p>下一个版本的列c的内容是’刘备’，该版本的trx_id值为80，80小于m_ids列表中最小的事务id100，所以这个版本是符合要求的，最后返回给用户的版本就是这条列c为’刘备’的记录。</p>
<p>也就是说两次SELECT查询得到的结果是重复的，记录的列c值都是’刘备’，这就是可重复读的含义。如果我们之后再把事务id为200的记录提交了，之后再到刚才使用REPEATABLE READ隔离级别的事务中继续查找这个id为1的记录，得到的结果还是’刘备’，具体执行过程大家可以自己分析一下。</p>
<h3 id="MVCC总结"><a href="#MVCC总结" class="headerlink" title="MVCC总结"></a>MVCC总结</h3><p>从上边的描述中我们可以看出来，所谓的MVCC（Multi-Version Concurrency Control ，多版本并发控制）指的就是在使用READ COMMITTD、REPEATABLE READ这两种隔离级别的事务在执行普通的SEELCT操作时访问记录的版本链的过程，这样子可以使不同事务的读-写、写-读操作并发执行，从而提升系统性能。READ COMMITTD、REPEATABLE READ这两个隔离级别的一个很大不同就是生成ReadView的时机不同，READ COMMITTD在每一次进行普通SELECT操作前都会生成一个ReadView，而REPEATABLE READ只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复这个ReadView就好了。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MVCC</tag>
      </tags>
  </entry>
  <entry>
    <title>redis系列-夯实基础面试相关</title>
    <url>/2020/04/05/redis%E7%B3%BB%E5%88%97-%E5%A4%AF%E5%AE%9E%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h3 id="最近看了很多redis相关的东西，做一点总结，redis涉及太多，本站支持在首页搜索关键字，看是否可以搜索到你想要的"><a href="#最近看了很多redis相关的东西，做一点总结，redis涉及太多，本站支持在首页搜索关键字，看是否可以搜索到你想要的" class="headerlink" title="最近看了很多redis相关的东西，做一点总结，redis涉及太多，本站支持在首页搜索关键字，看是否可以搜索到你想要的"></a>最近看了很多redis相关的东西，做一点总结，redis涉及太多，本站支持在首页搜索关键字，看是否可以搜索到你想要的</h3><h3 id="1、使用Redis有哪些好处？"><a href="#1、使用Redis有哪些好处？" class="headerlink" title="1、使用Redis有哪些好处？"></a>1、使用Redis有哪些好处？</h3><ol>
<li>基于内存的非关系型数据库，读取速度快</li>
<li>支持多种数据结构，</li>
<li>数据持久化</li>
<li>支持事务</li>
<li>支持主从复制</li>
</ol>
<h3 id="2、缺点："><a href="#2、缺点：" class="headerlink" title="2、缺点："></a>2、缺点：</h3><ol>
<li>容易受到物理内存的限制</li>
<li>不具备自动容错和恢复功能：主机从机宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端IP才能恢复</li>
<li>主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性</li>
<li>Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂，为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费</li>
</ol>
<h3 id="3、Redis相比Memcached有哪些优势？"><a href="#3、Redis相比Memcached有哪些优势？" class="headerlink" title="3、Redis相比Memcached有哪些优势？"></a>3、Redis相比Memcached有哪些优势？</h3><ol>
<li>Mencache把数据全部存于内存之中，不具备数据持久化</li>
<li>Memcached数据结构单一</li>
</ol>
<h3 id="4、Redis常见性能问题和解决方案"><a href="#4、Redis常见性能问题和解决方案" class="headerlink" title="4、Redis常见性能问题和解决方案"></a>4、Redis常见性能问题和解决方案</h3><ol>
<li>Master 最好不要做任何持久化工作，包括内存快照和 AOF 日志文件，特别是不要启用内存快照做持久化。</li>
<li>如果数据比较关键，某个 Slave 开启 AOF 备份数据，策略为每秒同步一次。</li>
<li>为了主从复制的速度和连接的稳定性，Slave 和 Master 最好在同一个局域网内。</li>
<li>尽量避免在压力较大的主库上增加从库。</li>
<li>Master 调用 BGREWRITEAOF 重写 AOF 文件，AOF 在重写的时候会占大量的 CPU 和内存资源，导致服务 load 过高，出现短暂服务暂停现象。</li>
<li>为了 Master 的稳定性，主从复制不要用图状结构，用单向链表结构更稳定，即主从关系为：Master&lt;–Slave1&lt;–Slave2&lt;–Slave3…，这样的结构也方便解决单点故障问题，实现 Slave 对 Master 的替换，也即，如果 Master 挂了，可以立马启用 Slave1 做 Master，其他不变。</li>
</ol>
<h3 id="5、MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据？"><a href="#5、MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据？" class="headerlink" title="5、MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据？"></a>5、MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据？</h3><ol>
<li>设置，淘汰策略：Redis的过期策略有定期删除+惰性删除两种，定期就是每隔固定时间去随机抽取一些设置了过期时间的key，去检查是否过期，如果没有随机抽取到，会采用惰性删除的方式，你来查了我就去检查是否过期，最后再不济，就是定期没检查，我也没去查，怎么办？这个时候引入内存淘汰机制，LRU方式，有很多种：比如尝试回收使用最少的键。</li>
</ol>
<h3 id="6、在什么样的场景下可以充分的利用Redis的特性，大大提高Redis的效率？"><a href="#6、在什么样的场景下可以充分的利用Redis的特性，大大提高Redis的效率？" class="headerlink" title="6、在什么样的场景下可以充分的利用Redis的特性，大大提高Redis的效率？"></a>6、在什么样的场景下可以充分的利用Redis的特性，大大提高Redis的效率？</h3><ol>
<li>比如网站的首页信息</li>
<li>排行榜的实现</li>
<li>为用户推送相似的新闻</li>
<li>短视频如何去重</li>
<li>统计网站的UV</li>
<li>保证接口的幂等性</li>
</ol>
<h3 id="7、Redis的缓存雪崩、穿透、击穿了解么？有什么异同点？分别怎么解决？"><a href="#7、Redis的缓存雪崩、穿透、击穿了解么？有什么异同点？分别怎么解决？" class="headerlink" title="7、Redis的缓存雪崩、穿透、击穿了解么？有什么异同点？分别怎么解决？"></a>7、Redis的缓存雪崩、穿透、击穿了解么？有什么异同点？分别怎么解决？</h3><ol>
<li>缓存雪崩：统一时间大量key过期，导致大量请求打到数据库中，压力过大<ul>
<li>解决方式：在设置key过期时间时，使用Random，将过期时间分散开</li>
</ul>
</li>
<li>缓存穿透：请求的时缓存和数据库都没有的数据，比如id = -1,这时的用户可能是攻击者<ul>
<li>解决方式：<ul>
<li>(1)对请求参数做校验 </li>
<li>(2)使用布隆过滤器(Bloom Filter):布隆过滤器的特点是：判断这个key存在不一定存在，但不存在一定不存在，因为是将key做了几个hash值，分散存储</li>
</ul>
</li>
</ul>
</li>
<li>缓存击穿：指的是某个热点数据，在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库<ul>
<li>解决方式：<ul>
<li>(1)设置热点数据永不过期 </li>
<li>(2)使用互斥锁</li>
<li>这里插入互斥锁代码</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getData</span><span class="params">(String key)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//从redis中拿数据</span></span><br><span class="line">        String result = getDataByKV(key);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//参数校验</span></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isBlank(result)) &#123;</span><br><span class="line">                <span class="comment">//获取锁</span></span><br><span class="line">                <span class="keyword">if</span> (reenLock.tryLock()) &#123;</span><br><span class="line">                    <span class="comment">//去数据库中查询</span></span><br><span class="line">                    result = getDataByDB(key);</span><br><span class="line">                    <span class="comment">//校验</span></span><br><span class="line">                    <span class="keyword">if</span> (!StringUtils.isBlank(result)) &#123;</span><br><span class="line">                        <span class="comment">//放进缓存</span></span><br><span class="line">                        setDataToKV(key, result);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100L</span>);</span><br><span class="line">                result = getData(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.info(<span class="string">"异常:&#123;&#125;"</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            reenLock.unLock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="8、Redis的基本类型有哪些？他们的使用场景了解么？比较高级的用法你使用过么？"><a href="#8、Redis的基本类型有哪些？他们的使用场景了解么？比较高级的用法你使用过么？" class="headerlink" title="8、Redis的基本类型有哪些？他们的使用场景了解么？比较高级的用法你使用过么？"></a>8、Redis的基本类型有哪些？他们的使用场景了解么？比较高级的用法你使用过么？</h3><ol>
<li>String：<ul>
<li>缓存功能：String字符串是最常用的数据类型，不仅仅是Redis，各个语言几乎都是最常用的</li>
<li>计数器：许多系统都会使用Redis作为系统的实时计数器，可以快速实现计数和查询的功能。而且最终的数据结果可以按照特定的时间落地到数据库或者其他存储介质中永久保存</li>
<li>共享用户session：用户重新刷新一次界面，可能需要访问一下数据进行重新登录，或者访问页面缓存Cookie，但是可以利用Redis将用户的Session集中管理</li>
</ul>
</li>
<li>Hash:<ul>
<li>一般是用来存储对象，可以比较方便的修改对象中某一个属性值，如果对象的值不经常改变用String较好</li>
</ul>
</li>
<li>List:<ul>
<li>List是有序列表，List可以存储例如粉丝列表，文章的评论之类的</li>
<li>消息队列：Redis的连标结构，可以轻松实现阻塞队列，可以使用左进右出的命令组成来完成队列的设计，比如：数据的生产者可以通过Lpush命令从左边插入数据，多个数据消费者，可以使用pop命令阻塞的”抢”队尾的数据</li>
<li>比如，我们常用的博客网站的文章列表，当用户量越来越多时，每一个用户都有自己的文章列表，而且当文章多时，都需要分页展示，这时可以考虑使用Redis的列表，列表不但有序同时还支持按照范围内获取元素，可以完美解决分页查询功能，大大提高查询效率。</li>
</ul>
</li>
<li>Set:<ul>
<li>set是无序集合，会自动去重，当然可以基于JVM的HashSet去重，但是一般系统都是部署在多台机器上的，所以基于JVM没办法保证数据一致，所以不如扔进set方便</li>
<li>既然是去重集合，集合嘛，有一些交集，并集之类的，比如要找两个人的共同好友，一个intersect命令搞定</li>
</ul>
</li>
<li>Sorted Set：<ul>
<li>Sorted Set是排序的Set，去重但可以排序，通过设定的分数进行排序，这里有点向JVM中TreeSet创建时需要定义排序规则</li>
<li>排行榜是最适合用Sorted Set,比如通过播放量，点击量进行排序</li>
<li>也可以用来做带权重的队列，比如普通的消息score为1，重要的消息score为2</li>
</ul>
</li>
<li>HyperLogLog:<ul>
<li>常见的业务场景，需要统计每个网页的UV数据，会如何实现？<ul>
<li>如果是PV非常好办，给每个网页一个独立的Redis计数器就可以了，key后缀加上当天的日期，请求一次incrby一次</li>
<li>但是UV就不同了，需要去重，每个用户一天之内的多次访问只能计数一次，一般的解决方案是为每个页面设置一个独立的set，将用户的id放进去，然后统计set集合的大小，但是有没有想过，假如是一个访问量非常大的页面，比如淘宝，那么集合会非常大，占用内存，那么有没有更优质的解决办法呢？其实对于业务来说100W和101W其实影响并不大</li>
<li>引入HyperLogLog，就是专门用来统计一些允许容错的数据结构，标准误差是0.81%，还是可以接受的</li>
<li>有三个命令 pfadd,pfcount,pfmerge通过字面上意思很好理解，这个结构需要的内存大小为12k，这于上亿用户量的set来比简直是九牛一毛</li>
</ul>
</li>
</ul>
</li>
<li>Bloom Filter:<ul>
<li>应用场景非常多，比如防止缓存穿透，比如在对用户推送新闻或者短视频时，实现去重操作，如果存储在关 系型数据库上，需要经常的exists判断，而且如果内存占用也是很大的开销</li>
<li>Bloom Filter可以理解为一个不怎么精确的set结构，当你使用contains方法是可能会误判，但是这个精确度是可以设置的，原则是 Bloom Filter说这个key存在那么有可能不存在，但Bloom Filter说这个key不存在，那么一定不存在。原理是对key进行hash运算，散列的保存在散列数组上，相比于JVM集合去存储整个元素，Bloom Filter存储的是hash值，非常节省空间</li>
<li>注意的是redis版本的问题需要手动导入Bloom Filter</li>
</ul>
</li>
<li>GeoHash：<ul>
<li>只需要知道可以用来实现附近的人功能，附近的人问题是如何通过坐标判断与目标坐标的远近，GeoHash算法是将二维的经纬度数据映射到一维的整数，这样所有的元素都将挂载到一条直线上，距离越近映射到二维坐标上也会很接近</li>
</ul>
</li>
<li>PubSub:<ul>
<li>Redis可以使用zset或者List实现一个简单的消息队列结构，但是有不足之处，就是不支持消息的多播机制，何为消息的多播机制？</li>
<li>消息多播指的是允许生产者生产一次消息，中间件负责将消息复制到多个消息队列，每个消息队列由相应的消费组进行消费，为了支持消息多播，Redis单独使用了一个模块来支持消息的多播，这个模块的就是PubSub<br>但我觉得PubSub了解一下就可以，目前没有很符合它的场景，因为他有不可避免的缺点<ul>
<li>PubSub的生产者传递过来一个消息，Redis会直接找到相应的消费者传递过去，如果一个消费者都没有，那么消息直接丢弃。如果开始有三个消费者，一个消费者突然挂掉了，生产者会继续发送消息，另外两个消费者可以持续接收到消息。但是挂掉的消费者重新连上的时候，断链期间生产者发送的消息对于这个消费者来说就是彻底丢失了。如果Redis停机重启，PubSub的消息是不会持久化的，毕竟Redis宕机就相当于一个消费者都没有，所有的消息直接被丢弃。</li>
<li>ps：近期Redis5.0新增了Stream数据结构，这个功能给Redis带来了持久化消息队列，从此PubSub感觉可以彻底离开Redis的舞台了(如果有大佬知道可以应用的场景，欢迎指正)</li>
</ul>
</li>
</ul>
</li>
<li>Stream5.0新发布—-需研究研究</li>
</ol>
<h3 id="9、Redis主从怎么同步数据的？集群的高可用怎么保证？持久化机制了解么？"><a href="#9、Redis主从怎么同步数据的？集群的高可用怎么保证？持久化机制了解么？" class="headerlink" title="9、Redis主从怎么同步数据的？集群的高可用怎么保证？持久化机制了解么？"></a>9、Redis主从怎么同步数据的？集群的高可用怎么保证？持久化机制了解么？</h3><ol>
<li>主从同步：slaveod 127.0.0.1 6379 配从机不配主机，相当于认了个老大，此时只有主机可以执行写操作，从机默认只能执行读操作(如果想从机也可以写入数据将slave-read-only:改为no)，所谓主从复制，读写分离，那么数据如何同步的呢？<ul>
<li>当建立一台slave时，会发送一个psync指令给master，如果是第一次链接到master，会触发一个全量复制。master会启动一个线程，生成RDB快照，将这个快照发送给slave，从机拿到快照后第一时间加载RDB文件，读取数据。<ul>
<li>问题一：一主二从模式下，主机宕机，从机原地待命，主机回来还是主机</li>
<li>问题二：从机宕机，每次与master断开，需要重新链接，除非配置进redis.conf文件</li>
</ul>
</li>
</ul>
</li>
<li>薪火相传：主机—&gt;从机—&gt;从机的从机  中间的从机的info replication：role是slave</li>
<li>反客为主：使用slaveof no one 命令手动的将其中一个从机设置为主机，主机回来之后与新的从机没有关系</li>
<li>哨兵模式：创建sentinel.conf文件，其中写入sentinel monitor host6379(名字) 127.0.0.1 6379 1(这个1代表主机挂了之后，谁得票数多余1票，谁就是新的master)，创建好了之后执行<pre><code>redis-sentinel sentinel.conf命令，执行之后</code></pre></li>
</ol>
<p><img src="../image/sentinel.png" alt="sentinel.png" title="sentinel"></p>
<p>假设主机挂了</p>
<p><img src="../image/after.png" alt="after.png" title="after"></p>
<p>选举6380为主机。<br>  此时如果主机也就是6379回来了，会被哨兵监控到，作为6380的从机。<br>  可以看到哨兵模式是有缺点的：(1)经常主从复制，有延迟 (2)在选举主机时，服务不可用</p>
<ol>
<li>高可用保证：上面提到的一主二从，薪火相传，反客为主，哨兵模式(反客为主的加强版)</li>
<li>持久化：AOF，RDB，通常都是AOF和RDB组合起来使用，用RDB恢复数据，AOF补全，因为RDB是每隔5分钟生成一个快照，但AOF是每个1s去以append-only的方式追加写数据。</li>
</ol>
<h3 id="10、为什么-redis-单线程却能支撑高并发？"><a href="#10、为什么-redis-单线程却能支撑高并发？" class="headerlink" title="10、为什么 redis 单线程却能支撑高并发？"></a>10、为什么 redis 单线程却能支撑高并发？</h3><ol>
<li>非阻塞IO多路复用</li>
<li>底层就是select poll epoll<ul>
<li>select缺点<ul>
<li>大小有限制，只有1024bit</li>
<li>FDSet不可重用</li>
<li>用户态到内核态有开销</li>
<li>O(n)再次变量的时间复杂度</li>
</ul>
</li>
<li>poll<ul>
<li>通过数组的方式进行了扩展</li>
<li>每次遍历将memset状态恢复</li>
<li>还存在上述3，4问题</li>
</ul>
</li>
<li>epoll(redis使用的方式)<ul>
<li>使用户态和内核态共享一块内存</li>
<li>不用占位，修改状态，采用重排的方式，每次只需遍历有数据的槽点，时间复杂度变味了O(1)</li>
</ul>
</li>
</ul>
</li>
<li>事件处理机制，文件事件/时间事件</li>
</ol>
<h3 id="11、如何保证缓存和数据库数据的一致性？"><a href="#11、如何保证缓存和数据库数据的一致性？" class="headerlink" title="11、如何保证缓存和数据库数据的一致性？"></a>11、如何保证缓存和数据库数据的一致性？</h3><ol>
<li>如果系统不是严格要求必须一致性的话，建议不要使用这个方案，将读请求和写请求串行化，串到一个内存队列中去，虽然这样可以保证一定不会出现不一致的情况，但会导致系统的吞吐量大幅度降低，并发量高了可能会导致队列阻塞，反而会成为整个系统的弱点。</li>
</ol>
<h3 id="12、redis分布式锁？"><a href="#12、redis分布式锁？" class="headerlink" title="12、redis分布式锁？"></a>12、redis分布式锁？</h3><ol>
<li>先拿setnx来争抢锁，抢到之后，用expire给锁加一个过期时间方式锁忘记了释放。如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那这个锁就永远得不到释放了，set指令有非常复杂的参数，可以把sentx和expire合成一条指令来用。</li>
<li>也可以使用Redisson底层使用的是Lua脚本，下一章会有演示</li>
</ol>
<h3 id="13、redis中的事务？"><a href="#13、redis中的事务？" class="headerlink" title="13、redis中的事务？"></a>13、redis中的事务？</h3><ol>
<li>用multi命令开启事务，中间执行的语句会被放入到队列中，为一个原子操作，exec结束事务，discard放弃事务</li>
<li>事务中如果有一个不符合规范的语句，整个事务失效，称作全体连坐</li>
<li>事务中如果有运行时才知道的错误，例如对一个字符串进行了incr命令，只有这条操作失败，其余的指令成功执行，称为源头债主，所以到这里应该知道redis的事务并不是严格意义上的满足原子性，仅仅是满足了隔离性，因为对其他操作并没有影响</li>
<li>watch监控，乐观锁，比较并修改，如果失败发现修改用unwatch放弃观察，注意一点multi和exec中间不允许watch命令，需要在事务开启之前执行watch</li>
</ol>
<h3 id="14、说说哈希槽的概念"><a href="#14、说说哈希槽的概念" class="headerlink" title="14、说说哈希槽的概念"></a>14、说说哈希槽的概念</h3><ol>
<li>先说下集群的概念：集群中的每一个 Redis 节点都 互相两两相连，客户端任意 直连 到集群中的 任意一台，就可以对其他 Redis 节点进行 读写 的操作。<ul>
<li>集群的主要作用是数据分区和高可用(故障转移)</li>
<li>集群如何数据分区？<ul>
<li>哈希值取余，此方案主要问题是，当新增或删减节点时，节点数量发生变化，系统中所有数据都需要重新计算映射关系</li>
<li>一致性哈希分区:将整个哈希值空间组织成一个圆环，增减节点的影响限制在相邻节点，但缺点是当节点数量较少时，增加或删除节点，对单个节点的影响可能比较大，造成数据的严重不平衡</li>
<li>在一致性哈希分区的基础上，引入了虚拟节点的概念，虚拟节点称为槽，Redis集群没有使用一致性hash,而是引入了哈希槽的概念，Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。</li>
</ul>
</li>
<li>节点之间如何通信？<ul>
<li>集群端口：在普通端口基础上+10000(固定值无法更改) 比如7000节点的集群端口为17000，集群端口只用于节点之间的通信</li>
<li>Gossip协议：按照某种规则选择通信的节点，优点是去中心化，缺点是收敛速度慢(收敛是指集群内所有节点获得的集群信息是一致的)</li>
<li>单对单</li>
<li>广播：优点是：集群的收敛速度哭啊，缺点是每条消息都要一次性发送给所有节点，CPU带宽等消耗较大</li>
<li>消息类型：meet(握手阶段)，ping，pong，fail(失败)，publish(广播)五种</li>
</ul>
</li>
<li>集群数据如何存储？<ul>
<li>clusterNode结构保存了一个节点的当前状态</li>
<li>clusterState结构保存了在当前节点视角下，集群所处的状态</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="15、假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知前缀开头，如何将它们全部找出来？"><a href="#15、假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知前缀开头，如何将它们全部找出来？" class="headerlink" title="15、假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知前缀开头，如何将它们全部找出来？"></a>15、假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知前缀开头，如何将它们全部找出来？</h3><ol>
<li>keys aaa*</li>
<li>scan 0 match aaa*</li>
<li>1的方式因为是单线程会造成阻塞，所以采用scan的方式，服务器不需要为游标保存状态，但返回的结果可能会有重复，而且如果遍历的过程中有数据修改，改动后的数据能不能遍历到是不确定的</li>
</ol>
<h3 id="17、Redis早期为什么选择单线程？"><a href="#17、Redis早期为什么选择单线程？" class="headerlink" title="17、Redis早期为什么选择单线程？"></a>17、Redis早期为什么选择单线程？</h3><ol>
<li>官方解释：redis是基于内存的操作，CPU不是redis的瓶颈，Redis的瓶颈是机器内存大小或者网络带宽,既然CPU不是瓶颈，单线程容易实现，就顺理成章的采用单线程的方案了</li>
<li>Redis为什么这么快？<ul>
<li>纯内存操作，不需要进行磁盘IO</li>
<li>单线程，没有锁竞争</li>
<li>多路I/O复用模型，非阻塞IO    </li>
<li>高效的数据结构</li>
</ul>
</li>
</ol>
<h3 id="18、五个基本结构的底层？"><a href="#18、五个基本结构的底层？" class="headerlink" title="18、五个基本结构的底层？"></a>18、五个基本结构的底层？</h3><ol>
<li>String：int + SDS</li>
<li>List：zipList + 双向链表</li>
<li>hash：zipList + 字典（类似于Java中的HashMap,数组+链表的链地址法来解决部分hash冲突，字典内部包含了两个hashtable，通常只有一个hashtable有值，扩容是需要rehash，这时候两个hashtable分别存储旧的和新的hashtable，待搬迁结束后，旧的将被删除，新的hashtable取而代之，扩容条件是：当hash表中元素的个数等于第一纬数组长度时就会开始扩容，扩容的数组是原来的2倍，但如果Redis正在做bgsave(持久化命令)，为了减少内存过多分离，Redis尽量不去扩容，但如果hash表非常慢了，达到了第一纬数组的5倍，这个时候会强制扩容，缩容条件是：条件是元素个数低于数组长度的10%，缩容不会考虑Redis是否在做bgsave）</li>
<li>set：intset + 字典（类似于Java中的HashMap）</li>
<li>zset：zipList + 跳跃表(首先，因为 zset 要支持随机的插入和删除，所以它 不宜使用数组来实现，关于排序问题，我们也很容易就想到 红黑树/ 平衡树 这样的树形结构，为什么 Redis 不使用这样一些结构呢？<br>ⅰ. 性能考虑： 在高并发的情况下，树形结构需要执行一些类似于 rebalance 这样的可能涉及整棵树的操作，相对来说跳跃表的变化只涉及局部 ；<br>ⅱ. 实现考虑： 在复杂度与红黑树相同的情况下，跳跃表实现起来更简单，看起来也更加直观；) + 字典（类似于Java中的HashMap）</li>
</ol>
<h3 id="19、项目中是怎么用缓存的，用了缓存之后会带来什么问题？"><a href="#19、项目中是怎么用缓存的，用了缓存之后会带来什么问题？" class="headerlink" title="19、项目中是怎么用缓存的，用了缓存之后会带来什么问题？"></a>19、项目中是怎么用缓存的，用了缓存之后会带来什么问题？</h3><ol>
<li>数据一致如何保证？</li>
<li>会不会发生缓存雪崩，缓存击穿，缓存穿透，如何避免？</li>
<li>缓存中的值更新，要先更新数据库，懒加载的方式再去更新缓存，缓存命中率怎么样，适不适合用，</li>
<li>集群模式下数据如何保证一致，主从复制，哨兵模式，集群，</li>
<li>balabala    </li>
</ol>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>彻底搞懂ThreadLocal</title>
    <url>/2020/03/10/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82ThreadLocal/</url>
    <content><![CDATA[<h3 id="1-问：ThreadLocal了解吗？您能给我说说他的主要用途吗？"><a href="#1-问：ThreadLocal了解吗？您能给我说说他的主要用途吗？" class="headerlink" title="1.问：ThreadLocal了解吗？您能给我说说他的主要用途吗？"></a>1.问：ThreadLocal了解吗？您能给我说说他的主要用途吗？</h3><p>答：</p>
<p>从JAVA官方对ThreadLocal类的说明定义（定义在示例代码中）：ThreadLocal类用来提供线程内部的局部变量。这种变量在多线程环境下访问（通过get和set方法访问）时能保证各个线程的变量相对独立于其他线程内的变量。ThreadLocal实例通常来说都是private static类型的，用于关联线程和线程上下文。</p>
<p>我们可以得知ThreadLocal的作用是：ThreadLocal的作用是提供线程内的局部变量，不同的线程之间不会相互干扰，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或组件之间一些公共变量的传递的复杂度。</p>
<p>上述可以概述为：ThreadLocal提供线程内部的局部变量，在本线程内随时随地可取，隔离其他线程。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该类提供了线程局部 (thread-local) 变量。 这些变量不同于它们的普通对应物，</span></span><br><span class="line"><span class="comment"> * 因为访问某个变量（通过其 get 或 set 方法）的每个线程都有自己的局部变量</span></span><br><span class="line"><span class="comment"> * 它独立于变量的初始化副本。ThreadLocal 实例通常是类中的 private static 字段</span></span><br><span class="line"><span class="comment"> * 它们希望将状态与某一个线程（例如，用户 ID 或事务 ID）相关联。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 例如，以下类生成对每个线程唯一的局部标识符。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 线程 ID 是在第一次调用 UniqueThreadIdGenerator.getCurrentThreadId() 时分配的，</span></span><br><span class="line"><span class="comment"> * 在后续调用中不会更改。</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * import java.util.concurrent.atomic.AtomicInteger;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * public class ThreadId &#123;</span></span><br><span class="line"><span class="comment"> *     // 原子性整数，包含下一个分配的线程Thread ID</span></span><br><span class="line"><span class="comment"> *     private static final AtomicInteger nextId = new AtomicInteger(0);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // 每一个线程对应的Thread ID</span></span><br><span class="line"><span class="comment"> *     private static final ThreadLocal&lt;Integer&gt; threadId =</span></span><br><span class="line"><span class="comment"> *         new ThreadLocal&lt;Integer&gt;() &#123;</span></span><br><span class="line"><span class="comment"> *             <span class="doctag">@Override</span> protected Integer initialValue() &#123;</span></span><br><span class="line"><span class="comment"> *                 return nextId.getAndIncrement();</span></span><br><span class="line"><span class="comment"> *         &#125;</span></span><br><span class="line"><span class="comment"> *     &#125;;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // 返回当前线程对应的唯一Thread ID, 必要时会进行分配</span></span><br><span class="line"><span class="comment"> *     public static int get() &#123;</span></span><br><span class="line"><span class="comment"> *         return threadId.get();</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> * 每个线程都保持对其线程局部变量副本的隐式引用，只要线程是活动的并且 ThreadLocal 实例是可访问的</span></span><br><span class="line"><span class="comment"> * 在线程消失之后，其线程局部实例的所有副本都会被垃圾回收，（除非存在对这些副本的其他引用）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Josh Bloch and Doug Lea</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义哈希码（仅在ThreadLocalMaps中有用）</span></span><br><span class="line"><span class="comment">     * 可用于降低hash冲突</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode=nextHashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成下一个哈希码hashCode. 生成操作是原子性的. 从0开始</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode=</span><br><span class="line">            <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示了连续分配的两个ThreadLocal实例的threadLocalHashCode值的增量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT=<span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回下一个哈希码hashCode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中nextHashCode()方法就是一个原子类不停地去加上0x61c88647，这是一个很特别的数，叫斐波那契散列（Fibonacci Hashing），斐波那契又有一个名称叫黄金分割，也就是说将这个数作为哈希值的增量将会使哈希表的分布更为均匀。</p>
<h3 id="2-问：ThreadLocal实现原理是什么，它是怎么样做到局部变量不同的线程之间不会相互干扰的？"><a href="#2-问：ThreadLocal实现原理是什么，它是怎么样做到局部变量不同的线程之间不会相互干扰的？" class="headerlink" title="2.问：ThreadLocal实现原理是什么，它是怎么样做到局部变量不同的线程之间不会相互干扰的？"></a>2.问：ThreadLocal实现原理是什么，它是怎么样做到局部变量不同的线程之间不会相互干扰的？</h3><p>答：</p>
<p>通常，如果我不去看源代码的话，我猜ThreadLocal是这样子设计的：每个ThreadLocal类都创建一个Map，然后用线程的ID threadID作为Map的key，要存储的局部变量作为Map的value，这样就能达到各个线程的值隔离的效果。这是最简单的设计方法，JDK最早期的ThreadLocal就是这样设计的。</p>
<p>但是，JDK后面优化了设计方案，现时JDK8 ThreadLocal的设计是：每个Thread维护一个ThreadLocalMap哈希表，这个哈希表的key是ThreadLocal实例本身，value才是真正要存储的值Object。</p>
<p>这个设计与我们一开始说的设计刚好相反，这样设计有如下几点优势：<br>1） 这样设计之后每个Map存储的Entry数量就会变小，因为之前的存储数量由Thread的数量决定，现在是由ThreadLocal的数量决定。</p>
<h4 id="关于这点需要做一个解释：至于jdk8之前的做法是有多少线程map中就存放多少，自然map很大，链表很长效率很低；jdk1-8之后用ThreadLocal作为key，也就是说每个线程内部维护一个ThreadLocalMap，每次set时都有偏移量，黄金分割点，不会导致key重复，map小冲突就小，效率高，即使还会存在冲突，不过没关系，这个ThreadLocal是不存在Next的所以不会存在链表，继续增加偏移量寻找下一个空点。"><a href="#关于这点需要做一个解释：至于jdk8之前的做法是有多少线程map中就存放多少，自然map很大，链表很长效率很低；jdk1-8之后用ThreadLocal作为key，也就是说每个线程内部维护一个ThreadLocalMap，每次set时都有偏移量，黄金分割点，不会导致key重复，map小冲突就小，效率高，即使还会存在冲突，不过没关系，这个ThreadLocal是不存在Next的所以不会存在链表，继续增加偏移量寻找下一个空点。" class="headerlink" title="关于这点需要做一个解释：至于jdk8之前的做法是有多少线程map中就存放多少，自然map很大，链表很长效率很低；jdk1.8之后用ThreadLocal作为key，也就是说每个线程内部维护一个ThreadLocalMap，每次set时都有偏移量，黄金分割点，不会导致key重复，map小冲突就小，效率高，即使还会存在冲突，不过没关系，这个ThreadLocal是不存在Next的所以不会存在链表，继续增加偏移量寻找下一个空点。"></a>关于这点需要做一个解释：至于jdk8之前的做法是有多少线程map中就存放多少，自然map很大，链表很长效率很低；jdk1.8之后用ThreadLocal作为key，也就是说每个线程内部维护一个ThreadLocalMap，每次set时都有偏移量，黄金分割点，不会导致key重复，map小冲突就小，效率高，即使还会存在冲突，不过没关系，这个ThreadLocal是不存在Next的所以不会存在链表，继续增加偏移量寻找下一个空点。</h4><p>2） 当Thread销毁之后，对应的ThreadLocalMap也会随之销毁，能减少内存的使用。</p>
<h3 id="3-问：您能说说ThreadLocal常用操作的底层实现原理吗？如存储set-T-value-，获取get-，删除remove-等操作。"><a href="#3-问：您能说说ThreadLocal常用操作的底层实现原理吗？如存储set-T-value-，获取get-，删除remove-等操作。" class="headerlink" title="3.问：您能说说ThreadLocal常用操作的底层实现原理吗？如存储set(T value)，获取get()，删除remove()等操作。"></a>3.问：您能说说ThreadLocal常用操作的底层实现原理吗？如存储set(T value)，获取get()，删除remove()等操作。</h3><p>答：</p>
<p>调用get()操作获取ThreadLocal中对应当前线程存储的值时，进行了如下操作：<br>1 ) 获取当前线程Thread对象，进而获取此线程对象中维护的ThreadLocalMap对象。<br>2 ) 判断当前的ThreadLocalMap是否存在：</p>
<p>如果存在，则以当前的ThreadLocal 为 key，调用ThreadLocalMap中的getEntry方法获取对应的存储实体 e。找到对应的存储实体 e，获取存储实体 e 对应的 value值，即为我们想要的当前线程对应此ThreadLocal的值，返回结果值。<br>如果不存在，则证明此线程没有维护的ThreadLocalMap对象，调用setInitialValue方法进行初始化。返回setInitialValue初始化的值。</p>
<p>setInitialValue方法的操作如下：<br>1 ) 调用initialValue获取初始化的值。<br>2 ) 获取当前线程Thread对象，进而获取此线程对象中维护的ThreadLocalMap对象。<br>3 ) 判断当前的ThreadLocalMap是否存在：</p>
<p>如果存在，则调用map.set设置此实体entry。</p>
<p>如果不存在，则调用createMap进行ThreadLocalMap对象的初始化，并将此实体entry作为第一个值存放至ThreadLocalMap中。</p>
<h3 id="4-问：对ThreadLocal的常用操作实际是对线程Thread中的ThreadLocalMap进行操作，核心是ThreadLocalMap这个哈希表，你能谈谈ThreadLocalMap的内部底层实现吗"><a href="#4-问：对ThreadLocal的常用操作实际是对线程Thread中的ThreadLocalMap进行操作，核心是ThreadLocalMap这个哈希表，你能谈谈ThreadLocalMap的内部底层实现吗" class="headerlink" title="4.问：对ThreadLocal的常用操作实际是对线程Thread中的ThreadLocalMap进行操作，核心是ThreadLocalMap这个哈希表，你能谈谈ThreadLocalMap的内部底层实现吗?"></a>4.问：对ThreadLocal的常用操作实际是对线程Thread中的ThreadLocalMap进行操作，核心是ThreadLocalMap这个哈希表，你能谈谈ThreadLocalMap的内部底层实现吗?</h3><p>答：</p>
<p>ThreadLocalMap的底层实现是一个定制的自定义HashMap哈希表，核心组成元素有：<br>1 ) Entry[] table;：底层哈希表 table, 必要时需要进行扩容，底层哈希表 table.length 长度必须是2的n次方。<br>2 ) int size;：实际存储键值对元素个数 entries<br>3 ) int threshold;：下一次扩容时的阈值，阈值 threshold = 底层哈希表table的长度 len * 2 / 3。当size &gt;= threshold时，遍历table并删除key为null的元素，如果删除后size &gt;= threshold*3/4时，需要对table进行扩容（详情请查看set(ThreadLocal&lt;?&gt; key, Object value)方法说明）。</p>
<p>其中Entry[] table;哈希表存储的核心元素是Entry，Entry包含：<br>1 ) ThreadLocal&lt;?&gt; k；：当前存储的ThreadLocal实例对象<br>2 ) Object value;：当前 ThreadLocal 对应储存的值value</p>
<p>需要注意的是，此Entry继承了弱引用 WeakReference，所以在使用ThreadLocalMap时，发现key == null，则意味着此key ThreadLocal不在被引用，需要将其从ThreadLocalMap哈希表中移除。(弱引用相关问题解释请查看 问答 5)</p>
<h3 id="5-问：ThreadLocalMap中的存储实体Entry使用ThreadLocal作为key，但这个Entry是继承弱引用WeakReference的，为什么要这样设计，使用了弱引用WeakReference会造成内存泄露问题吗？"><a href="#5-问：ThreadLocalMap中的存储实体Entry使用ThreadLocal作为key，但这个Entry是继承弱引用WeakReference的，为什么要这样设计，使用了弱引用WeakReference会造成内存泄露问题吗？" class="headerlink" title="5.问：ThreadLocalMap中的存储实体Entry使用ThreadLocal作为key，但这个Entry是继承弱引用WeakReference的，为什么要这样设计，使用了弱引用WeakReference会造成内存泄露问题吗？"></a>5.问：ThreadLocalMap中的存储实体Entry使用ThreadLocal作为key，但这个Entry是继承弱引用WeakReference的，为什么要这样设计，使用了弱引用WeakReference会造成内存泄露问题吗？</h3><p>答：</p>
<p>首先，回答这个问题之前，我需要解释一下什么是强引用，什么是弱引用。</p>
<p>我们在正常情况下，普遍使用的是强引用：<br>A a = new A();</p>
<p>B b = new B();复制代码当 a = null;b = null;时，一段时间后，JAVA垃圾回收机制GC会将 a 和 b 对应所分配的内存空间给回收。<br>但考虑这样一种情况：<br>C c = new C(b);<br>b = null;复制代码当 b 被设置成null时，那么是否意味这一段时间后GC工作可以回收 b 所分配的内存空间呢？答案是否定的，因为即使 b 被设置成null，但 c 仍然持有对 b 的引用，而且还是强引用，所以GC不会回收 b 原先所分配的空间，既不能回收，又不能使用，这就造成了 内存泄露。<br>那么如何处理呢？<br>可以通过c = null;，也可以使用弱引用WeakReference w = new WeakReference(b);。因为使用了弱引用WeakReference，GC是可以回收 b 原先所分配的空间的。<br>上述解释主要参考自：对ThreadLocal实现原理的一点思考</p>
<p>回到ThreadLocal的层面上，ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用来引用它，那么系统 GC 的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value 永远无法回收，造成内存泄漏。</p>
<p>其实，ThreadLocalMap的设计中已经考虑到这种情况，也加上了一些防护措施：在ThreadLocal的get(),set(),remove()的时候都会清除线程ThreadLocalMap里所有key为null的value。<br>但是这些被动的预防措施并不能保证不会内存泄漏：</p>
<p>使用static的ThreadLocal，延长了ThreadLocal的生命周期，可能导致的内存泄漏（参考ThreadLocal 内存泄露的实例分析）。</p>
<p>分配使用了ThreadLocal又不再调用get(),set(),remove()方法，那么就会导致内存泄漏。</p>
<p>从表面上看内存泄漏的根源在于使用了弱引用。网上的文章大多着重分析ThreadLocal使用了弱引用会导致内存泄漏，但是另一个问题也同样值得思考：为什么使用弱引用而不是强引用？<br>我们先来看看官方文档的说法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">To help deal with very large and <span class="keyword">long</span>-lived usages, </span><br><span class="line">the hash table entries use WeakReferences <span class="keyword">for</span> keys.</span><br></pre></td></tr></table></figure>

<p>为了应对非常大和长时间的用途，哈希表使用弱引用的 key。<br>下面我们分两种情况讨论：</p>
<p>key 使用强引用：引用的ThreadLocal的对象被回收了，但是ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏。</p>
<p>key 使用弱引用：引用的ThreadLocal的对象被回收了，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收。value在下一次ThreadLocalMap调用get(),set(),remove()的时候会被清除。</p>
<p>比较两种情况，我们可以发现：由于ThreadLocalMap的生命周期跟Thread一样长，如果都没有手动删除对应key，都会导致内存泄漏，但是使用弱引用可以多一层保障：弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用get(),set(),remove()的时候会被清除。</p>
<p>因此，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。<br>综合上面的分析，我们可以理解ThreadLocal内存泄漏的前因后果，那么怎么避免内存泄漏呢？<br>每次使用完ThreadLocal，都调用它的remove()方法，清除数据。<br>在使用线程池的情况下，没有及时清理ThreadLocal，不仅是内存泄漏的问题，更严重的是可能导致业务逻辑出现问题。所以，使用ThreadLocal就跟加锁完要解锁一样，用完就清理。</p>
<h3 id="6-问：ThreadLocal和synchronized的区别"><a href="#6-问：ThreadLocal和synchronized的区别" class="headerlink" title="6.问：ThreadLocal和synchronized的区别?"></a>6.问：ThreadLocal和synchronized的区别?</h3><p>答：ThreadLocal和synchronized关键字都用于处理多线程并发访问变量的问题，只是二者处理问题的角度和思路不同。</p>
<p>ThreadLocal是一个Java类,通过对当前线程中的局部变量的操作来解决不同线程的变量访问的冲突问题。所以，ThreadLocal提供了线程安全的共享对象机制，每个线程都拥有其副本。</p>
<p>Java中的synchronized是一个保留字，它依靠JVM的锁机制来实现临界区的函数或者变量的访问中的原子性。在同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量。此时，被用作“锁机制”的变量时多个线程共享的。</p>
<p>同步机制(synchronized关键字)采用了以“时间换空间”的方式，提供一份变量，让不同的线程排队访问。而ThreadLocal采用了“以空间换时间”的方式，为每一个线程都提供一份变量的副本，从而实现同时访问而互不影响。</p>
<h3 id="7-问：ThreadLocal在现时有什么应用场景？"><a href="#7-问：ThreadLocal在现时有什么应用场景？" class="headerlink" title="7.问：ThreadLocal在现时有什么应用场景？"></a>7.问：ThreadLocal在现时有什么应用场景？</h3><p>答：总的来说ThreadLocal主要是解决2种类型的问题：</p>
<p>解决并发问题：使用ThreadLocal代替synchronized来保证线程安全。同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。</p>
<p>解决数据存储问题：ThreadLocal为变量在每个线程中都创建了一个副本，所以每个线程可以访问自己内部的副本变量，不同线程之间不会互相干扰。如一个Parameter对象的数据需要在多个模块中使用，如果采用参数传递的方式，显然会增加模块之间的耦合性。此时我们可以使用ThreadLocal解决。</p>
<p>应用场景：<br>Spring使用ThreadLocal解决线程安全问题</p>
<p>我们知道在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域。就是因为Spring对一些Bean（如RequestContextHolder、TransactionSynchronizationManager、LocaleContextHolder等）中非线程安全状态采用ThreadLocal进行处理，让它们也成为线程安全的状态，因为有状态的Bean就可以在多线程中共享了。</p>
<p>一般的Web应用划分为展现层、服务层和持久层三个层次，在不同的层中编写对应的逻辑，下层通过接口向上层开放功能调用。在一般情况下，从接收请求到返回响应所经过的所有程序调用都同属于一个线程ThreadLocal是解决线程安全问题一个很好的思路，它通过为每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题。在很多情况下，ThreadLocal比直接使用synchronized同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="1-ThreadLocal提供线程内部的局部变量，在本线程内随时随地可取，隔离其他线程。"><a href="#1-ThreadLocal提供线程内部的局部变量，在本线程内随时随地可取，隔离其他线程。" class="headerlink" title="1.ThreadLocal提供线程内部的局部变量，在本线程内随时随地可取，隔离其他线程。"></a>1.ThreadLocal提供线程内部的局部变量，在本线程内随时随地可取，隔离其他线程。</h3><h3 id="2-ThreadLocal的设计是：每个Thread维护一个ThreadLocalMap哈希表，这个哈希表的key是ThreadLocal实例本身，value才是真正要存储的值Object。"><a href="#2-ThreadLocal的设计是：每个Thread维护一个ThreadLocalMap哈希表，这个哈希表的key是ThreadLocal实例本身，value才是真正要存储的值Object。" class="headerlink" title="2.ThreadLocal的设计是：每个Thread维护一个ThreadLocalMap哈希表，这个哈希表的key是ThreadLocal实例本身，value才是真正要存储的值Object。"></a>2.ThreadLocal的设计是：每个Thread维护一个ThreadLocalMap哈希表，这个哈希表的key是ThreadLocal实例本身，value才是真正要存储的值Object。</h3><h3 id="3-对ThreadLocal的常用操作实际是对线程Thread中的ThreadLocalMap进行操作。"><a href="#3-对ThreadLocal的常用操作实际是对线程Thread中的ThreadLocalMap进行操作。" class="headerlink" title="3.对ThreadLocal的常用操作实际是对线程Thread中的ThreadLocalMap进行操作。"></a>3.对ThreadLocal的常用操作实际是对线程Thread中的ThreadLocalMap进行操作。</h3><h3 id="4-ThreadLocalMap的底层实现是一个定制的自定义HashMap哈希表，ThreadLocalMap的阈值threshold-底层哈希表table的长度-len-2-3，当实际存储元素个数size-大于或等于-阈值threshold的-3-4-时size-gt-threshold-3-4，则对底层哈希表数组table进行扩容操作。"><a href="#4-ThreadLocalMap的底层实现是一个定制的自定义HashMap哈希表，ThreadLocalMap的阈值threshold-底层哈希表table的长度-len-2-3，当实际存储元素个数size-大于或等于-阈值threshold的-3-4-时size-gt-threshold-3-4，则对底层哈希表数组table进行扩容操作。" class="headerlink" title="4.ThreadLocalMap的底层实现是一个定制的自定义HashMap哈希表，ThreadLocalMap的阈值threshold = 底层哈希表table的长度 len * 2 / 3，当实际存储元素个数size 大于或等于 阈值threshold的 3/4 时size &gt;= threshold*3/4，则对底层哈希表数组table进行扩容操作。"></a>4.ThreadLocalMap的底层实现是一个定制的自定义HashMap哈希表，ThreadLocalMap的阈值threshold = 底层哈希表table的长度 len * 2 / 3，当实际存储元素个数size 大于或等于 阈值threshold的 3/4 时size &gt;= threshold*3/4，则对底层哈希表数组table进行扩容操作。</h3><h3 id="5-ThreadLocalMap中的哈希表Entry-table存储的核心元素是Entry，存储的key是ThreadLocal实例对象，value是ThreadLocal-对应储存的值value。需要注意的是，此Entry继承了弱引用-WeakReference，所以在使用ThreadLocalMap时，发现key-null，则意味着此key-ThreadLocal不在被引用，需要将其从ThreadLocalMap哈希表中移除。"><a href="#5-ThreadLocalMap中的哈希表Entry-table存储的核心元素是Entry，存储的key是ThreadLocal实例对象，value是ThreadLocal-对应储存的值value。需要注意的是，此Entry继承了弱引用-WeakReference，所以在使用ThreadLocalMap时，发现key-null，则意味着此key-ThreadLocal不在被引用，需要将其从ThreadLocalMap哈希表中移除。" class="headerlink" title="5.ThreadLocalMap中的哈希表Entry[] table存储的核心元素是Entry，存储的key是ThreadLocal实例对象，value是ThreadLocal 对应储存的值value。需要注意的是，此Entry继承了弱引用 WeakReference，所以在使用ThreadLocalMap时，发现key == null，则意味着此key  ThreadLocal不在被引用，需要将其从ThreadLocalMap哈希表中移除。"></a>5.ThreadLocalMap中的哈希表Entry[] table存储的核心元素是Entry，存储的key是ThreadLocal实例对象，value是ThreadLocal 对应储存的值value。需要注意的是，此Entry继承了弱引用 WeakReference，所以在使用ThreadLocalMap时，发现key == null，则意味着此key  ThreadLocal不在被引用，需要将其从ThreadLocalMap哈希表中移除。</h3><h3 id="6-ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用来引用它，那么系统-GC-的时候，这个ThreadLocal势必会被回收。所以，在ThreadLocal的get-set-remove-的时候都会清除线程ThreadLocalMap里所有key为null的value。如果我们不主动调用上述操作，则会导致内存泄露。"><a href="#6-ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用来引用它，那么系统-GC-的时候，这个ThreadLocal势必会被回收。所以，在ThreadLocal的get-set-remove-的时候都会清除线程ThreadLocalMap里所有key为null的value。如果我们不主动调用上述操作，则会导致内存泄露。" class="headerlink" title="6.ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用来引用它，那么系统 GC 的时候，这个ThreadLocal势必会被回收。所以，在ThreadLocal的get(),set(),remove()的时候都会清除线程ThreadLocalMap里所有key为null的value。如果我们不主动调用上述操作，则会导致内存泄露。"></a>6.ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用来引用它，那么系统 GC 的时候，这个ThreadLocal势必会被回收。所以，在ThreadLocal的get(),set(),remove()的时候都会清除线程ThreadLocalMap里所有key为null的value。如果我们不主动调用上述操作，则会导致内存泄露。</h3><h3 id="7-为了安全地使用ThreadLocal，必须要像每次使用完锁就解锁一样，在每次使用完ThreadLocal后都要调用remove-来清理无用的Entry。这在操作在使用线程池时尤为重要。"><a href="#7-为了安全地使用ThreadLocal，必须要像每次使用完锁就解锁一样，在每次使用完ThreadLocal后都要调用remove-来清理无用的Entry。这在操作在使用线程池时尤为重要。" class="headerlink" title="7.为了安全地使用ThreadLocal，必须要像每次使用完锁就解锁一样，在每次使用完ThreadLocal后都要调用remove()来清理无用的Entry。这在操作在使用线程池时尤为重要。"></a>7.为了安全地使用ThreadLocal，必须要像每次使用完锁就解锁一样，在每次使用完ThreadLocal后都要调用remove()来清理无用的Entry。这在操作在使用线程池时尤为重要。</h3><h3 id="8-ThreadLocal和synchronized的区别：同步机制-synchronized关键字-采用了以“时间换空间”的方式，提供一份变量，让不同的线程排队访问。而ThreadLocal采用了“以空间换时间”的方式，为每一个线程都提供一份变量的副本，从而实现同时访问而互不影响。"><a href="#8-ThreadLocal和synchronized的区别：同步机制-synchronized关键字-采用了以“时间换空间”的方式，提供一份变量，让不同的线程排队访问。而ThreadLocal采用了“以空间换时间”的方式，为每一个线程都提供一份变量的副本，从而实现同时访问而互不影响。" class="headerlink" title="8.ThreadLocal和synchronized的区别：同步机制(synchronized关键字)采用了以“时间换空间”的方式，提供一份变量，让不同的线程排队访问。而ThreadLocal采用了“以空间换时间”的方式，为每一个线程都提供一份变量的副本，从而实现同时访问而互不影响。"></a>8.ThreadLocal和synchronized的区别：同步机制(synchronized关键字)采用了以“时间换空间”的方式，提供一份变量，让不同的线程排队访问。而ThreadLocal采用了“以空间换时间”的方式，为每一个线程都提供一份变量的副本，从而实现同时访问而互不影响。</h3><h3 id="9-ThreadLocal主要是解决2种类型的问题：A-解决并发问题：使用ThreadLocal代替同步机制解决并发问题。B-解决数据存储问题：如一个Parameter对象的数据需要在多个模块中使用，如果采用参数传递的方式，显然会增加模块之间的耦合性。此时我们可以使用ThreadLocal解决。"><a href="#9-ThreadLocal主要是解决2种类型的问题：A-解决并发问题：使用ThreadLocal代替同步机制解决并发问题。B-解决数据存储问题：如一个Parameter对象的数据需要在多个模块中使用，如果采用参数传递的方式，显然会增加模块之间的耦合性。此时我们可以使用ThreadLocal解决。" class="headerlink" title="9.ThreadLocal主要是解决2种类型的问题：A. 解决并发问题：使用ThreadLocal代替同步机制解决并发问题。B. 解决数据存储问题：如一个Parameter对象的数据需要在多个模块中使用，如果采用参数传递的方式，显然会增加模块之间的耦合性。此时我们可以使用ThreadLocal解决。"></a>9.ThreadLocal主要是解决2种类型的问题：A. 解决并发问题：使用ThreadLocal代替同步机制解决并发问题。B. 解决数据存储问题：如一个Parameter对象的数据需要在多个模块中使用，如果采用参数传递的方式，显然会增加模块之间的耦合性。此时我们可以使用ThreadLocal解决。</h3><p>作者：liangzzz<br>链接：<a href="https://juejin.im/post/5a0e985df265da430e4ebb92" target="_blank" rel="noopener">https://juejin.im/post/5a0e985df265da430e4ebb92</a><br>来源：掘金<br>中间加上了自己的理解</p>
]]></content>
      <categories>
        <category>高并发系列</category>
      </categories>
      <tags>
        <tag>高并发</tag>
        <tag>ThreadLocal</tag>
      </tags>
  </entry>
  <entry>
    <title>静态代理/动态代理/AOP</title>
    <url>/2020/03/07/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-AOP/</url>
    <content><![CDATA[<h3 id="本文是看过的一篇文章做的记录"><a href="#本文是看过的一篇文章做的记录" class="headerlink" title="本文是看过的一篇文章做的记录"></a>本文是看过的一篇文章做的记录</h3><h4 id="Java-代理模式实现方式，主要有如下五种方法"><a href="#Java-代理模式实现方式，主要有如下五种方法" class="headerlink" title="Java 代理模式实现方式，主要有如下五种方法"></a>Java 代理模式实现方式，主要有如下五种方法</h4><ol>
<li>静态代理，工程师编辑代理类代码，实现代理模式；在编译期就生成了代理类。</li>
<li>基于 JDK 实现动态代理，通过jdk提供的工具方法Proxy.newProxyInstance动态构建全新的代理类(继承Proxy类，并持有InvocationHandler接口引用 )字节码文件并实例化对象返回。(jdk动态代理是由java内部的反射机制来实例化代理对象，并代理的调用委托类方法)</li>
<li>基于CGlib 动态代理模式 基于继承被代理类生成代理子类，不用实现接口。只需要被代理类是非final 类即可。(cglib动态代理底层是借助asm字节码技术</li>
<li>基于 Aspectj 实现动态代理（修改目标类的字节，织入代理的字节，在程序编译的时候 插入动态代理的字节码，不会生成全新的Class ）</li>
<li>基于 instrumentation 实现动态代理（修改目标类的字节码、类装载的时候动态拦截去修改，基于javaagent） -javaagent:spring-instrument-4.3.8.RELEASE.jar （类装载的时候 插入动态代理的字节码，不会生成全新的Class ）</li>
</ol>
<h3 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h3><p>委托类 即指的是代理模式中的被代理对象<br>代理类 指的是生成的代表委托类的一个角色<br>静态代理实现<br>静态代理是代理类在编译期间就创建好了，不是编译器生成的代理类，而是手动创建的类。在编译时就已经将接口，被代理类，代理类等确定下来。，软件设计中所指的代理一般是指静态代理，也就是在代码中显式指定的代理。</p>
<h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><p>委托类和代理类之间的约束接口Cat<br>约束接口实现类 Lion，实现 Cat 接口，委托角色<br>代理类实现 FeederProxy，实现Cat 接口，并含有一个 Cat接口引用属性。 代理角色，代理 cat接口属性引用实例的行为并可以新增公共逻辑<br>Cat接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yunlong.sun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/03/07 - 17:12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ProjectName</span> JavaAopLearning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 静态代理类接口, 委托类和代理类都需要实现的接口规范。</span></span><br><span class="line"><span class="comment"> * 定义了一个猫科动物的两个行为接口，吃东西，奔跑。</span></span><br><span class="line"><span class="comment"> * 作为代理类 和委托类之间的约束接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">eatFood</span><span class="params">(String foodName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">running</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 委托类 Lion</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yunlong.sun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/03/15 - 17:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ProjectName</span> JavaAopLearning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 狮子 实现了猫科动物接口Cat， 并实现了具体的行为。作为委托类实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lion</span> <span class="keyword">implements</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> runningSpeed;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRunningSpeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> runningSpeed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRunningSpeed</span><span class="params">(<span class="keyword">int</span> runningSpeed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.runningSpeed=runningSpeed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Lion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">eatFood</span><span class="params">(String foodName)</span> </span>&#123;</span><br><span class="line">        String eat=<span class="keyword">this</span>.name + <span class="string">" Lion eat food. foodName = "</span> + foodName;</span><br><span class="line">        System.out.println(eat);</span><br><span class="line">        <span class="keyword">return</span> eat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">running</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name + <span class="string">" Lion is running . Speed :"</span> + <span class="keyword">this</span>.runningSpeed);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理类角色(FeederProxy)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yunlong.sun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/03/15 - 17:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ProjectName</span> JavaAopLearning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 饲养员 实现Cat接口，作为静态代理类实现。代理狮子的行为。</span></span><br><span class="line"><span class="comment"> * 代理类中可以新增一些其他行为，在实践中主要做的是参数校验的功能。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeederProxy</span> <span class="keyword">implements</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Cat cat;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FeederProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FeederProxy</span><span class="params">(Cat cat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cat <span class="keyword">instanceof</span> Cat) &#123;</span><br><span class="line">            <span class="keyword">this</span>.cat=cat;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCat</span><span class="params">(Cat cat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cat <span class="keyword">instanceof</span> Cat) &#123;</span><br><span class="line">            <span class="keyword">this</span>.cat=cat;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">eatFood</span><span class="params">(String foodName)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"proxy Lion exec eatFood "</span>);</span><br><span class="line">        <span class="keyword">return</span> cat.eatFood(foodName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">running</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"proxy Lion exec running."</span>);</span><br><span class="line">        <span class="keyword">return</span> cat.running();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.vincent.proxy.staticproxy.FeederProxy;</span><br><span class="line"><span class="keyword">import</span> org.vincent.proxy.staticproxy.Lion;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态代理类测试</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yunlong.sun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/03/15 - 18:31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ProjectName</span> JavaAopLearning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 静态代理类测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">staticProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Lion lion=<span class="keyword">new</span> Lion();</span><br><span class="line">        lion.setName(<span class="string">"狮子 小王"</span>);</span><br><span class="line">        lion.setRunningSpeed(<span class="number">100</span>);        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * new 静态代理类，静态代理类在编译前已经创建好了，和动态代理的最大区别点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Cat proxy=<span class="keyword">new</span> FeederProxy(lion);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" -- "</span> + proxy.eatFood(<span class="string">"水牛"</span>));</span><br><span class="line">        proxy.running();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态代理很好的诠释了代理设计模式，代理模式最主要的就是有一个公共接口（Cat），一个委托类（Lion），一个代理类（FeederProxy）,代理类持有委托类的实例，代为执行具体类实例方法。 上面说到，代理模式就是在访问实际对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。这里的间接性就是指客户端不直接调用实际对象的方法，客户端依赖公共接口并使用代理类。 那么我们在代理过程中就可以加上一些其他用途。 就这个例子来说在 eatFood方法调用中，代理类在调用具体实现类之前添加System.out.println(“proxy Lion exec eatFood “);语句 就是添加间接性带来的收益。代理类存在的意义是为了增加一些公共的逻辑代码。</p>
<h3 id="动态代理类-基于接口实现"><a href="#动态代理类-基于接口实现" class="headerlink" title="动态代理类(基于接口实现)"></a>动态代理类(基于接口实现)</h3><p>静态代理是代理类在代码运行前已经创建好，并生成class文件；动态代理类 是代理类在程序运行时创建的代理模式。</p>
<p>动态代理类的代理类并不是在Java代码中定义的，而是在运行时根据我们在Java代码中的“指示”动态生成的。相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。 想想你有100个静态代理类，现在有一个需求，每个代理类都需要新增一个处理逻辑，你需要打开100个代理类在每个代理方法里面新增处理逻辑吗？ 有或者代理类有5个方法，每个方法都需要新增一个处理逻辑， 你需要在每个方法都手动新增处理逻辑吗？ 想想就挺无趣的。动态代理类帮你一键搞定。</p>
<p>动态代理类涉及角色<br>委托类和代理类实现的公共接口(Person.java)<br>实现公共接口的具体委托类(SoftwareEngineer.java)<br>InvocationHandler接口被Proxy类回调处理，一般实现 InvocationHandler 接口的类具有委托类引用，接口方法 invoke 中添加公共代码并调用委托类的接口方法。(PersonInvocationHandler.java)<br>JDK提供生成动态代理类的核心类Proxy ( JDK 提供的Proxy.java)<br>基于JDK技术 动态代理类技术核心 Proxy类和一个 InvocationHandler 接口<br>java的java.lang.reflect包下提供了Proxy类和一个 InvocationHandler 接口，这个类Proxy定义了生成JDK动态代理类的方法 getProxyClass(ClassLoader loader,Class&lt;?&gt;… interfaces)生成动态代理类,返回class实例代表一个class文件。可以保存该 class 文件查看jdk生成的代理类文件长什么样</p>
<p>该生成的动态代理类继承Proxy类，(重要特性) ，并实现公共接口。</p>
<p>InvocationHandler这个接口 是被动态代理类回调的接口，我们所有需要增加的针对委托类的统一处理逻辑都增加到invoke 方法里面在调用委托类接口方法之前或之后 结束战斗。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 案例:公共接口</span></span><br><span class="line"><span class="comment"> * 创建Person 接口 用于定义 委托类和代理类之间的约束行为</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 人名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dst  工作目的地</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">goWorking</span><span class="params">(String name, String dst)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取名称</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置名称</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体实现类，等下被委托，被代理的类 SoftwareEngineer.java</span></span><br><span class="line"><span class="comment"> * 动态代理委托类实现， 实现接口 Person。 被动态生成的代理类代理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoftwareEngineer</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SoftwareEngineer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SoftwareEngineer</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goWorking</span><span class="params">(String name, String dst)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"name ="</span> + name + <span class="string">" ， 去 "</span> + dst + <span class="string">" 工作"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * InvocationHandler 接口实现</span></span><br><span class="line"><span class="comment"> * PersonInvocationHandler 类 实现InvocationHandler接口，这个类中持有一个被代理对象(委托类)的实例target。该类别JDK Proxy类回调</span></span><br><span class="line"><span class="comment"> * InvocationHandler 接口中有一个invoke方法，当一个代理实例的方法被调用时，代理方法将被编码并分发到 InvocationHandler接口的invoke方法执行。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonInvocationHandler</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 被代理对象引用，invoke 方法里面method 需要使用这个 被代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    T target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonInvocationHandler</span><span class="params">(T target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target=target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy  代表动态生成的 动态代理 对象实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 代表被调用委托类的接口方法，和生成的代理类实例调用的接口方法是一致的，它对应的Method 实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args   代表调用接口方法对应的Object参数数组，如果接口是无参，则为null； 对于原始数据类型返回的他的包装类型。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;        <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在转调具体目标对象之前，可以执行一些功能处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        System.out.println(<span class="string">"被动态代理类回调执行, 代理类 proxyClass ="</span> + proxy.getClass() + <span class="string">" 方法名: "</span> + method.getName() + <span class="string">"方法. 方法返回类型："</span> + method.getReturnType()</span><br><span class="line">                + <span class="string">" 接口方法入参数组: "</span> + (args == <span class="keyword">null</span> ? <span class="string">"null"</span> : Arrays.toString(args)));        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 代理过程中插入监测方法,计算该方法耗时</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        MonitorUtil.start();</span><br><span class="line">        Thread.sleep(<span class="number">1</span>);        <span class="comment">/** 调用呗代理对象的真实方法，*/</span></span><br><span class="line">        Object result=method.invoke(target, args);</span><br><span class="line">        MonitorUtil.finish(method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * PersonInvocationHandler invoke 方法中添加的公共代码，这里简单以统计方法执行时间为逻辑</span></span><br><span class="line"><span class="comment"> * 方法用时监控类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Long&gt; tl=<span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        tl.set(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结束时打印耗时</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodName 方法名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(String methodName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> finishTime=System.currentTimeMillis();</span><br><span class="line">        System.out.println(methodName + <span class="string">"方法执行耗时"</span> + (finishTime - tl.get()) + <span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sun.misc.ProxyGenerator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态代理类测试</span></span><br><span class="line"><span class="comment"> * 最后的是 怎么创建代理类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;        <span class="comment">// 打开保存JDK动态代理生成的类文件</span></span><br><span class="line">        saveGeneratedJdkProxyFiles();        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第一种方法: 通过 Proxy.newProxyInstance 方法 获取代理对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">"-------------------第一种创建代理类方法--------------"</span>);        <span class="comment">//创建一个实例对象，这个对象是被代理的对象，委托类</span></span><br><span class="line">        Person person=<span class="keyword">new</span> SoftwareEngineer(<span class="string">"Vincent"</span>);        <span class="comment">//创建一个与代理类相关联的InvocationHandler,每一个代理类都有一个关联的 InvocationHandler，并将代理类引用传递进去</span></span><br><span class="line">        InvocationHandler Handler=<span class="keyword">new</span> PersonInvocationHandler&lt;&gt;(person);        <span class="comment">//创建一个 代理对象 personProxy 来代理 person，创建的代理对象的每个执行方法都会被替换执行Invocation接口中的invoke方法</span></span><br><span class="line">        Person personProxy=(Person) Proxy.newProxyInstance(Person.class.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;Person.class&#125;, Handler);        <span class="comment">/** 代理类信息 */</span></span><br><span class="line">        System.out.println(<span class="string">"package = "</span> + personProxy.getClass().getPackage() + <span class="string">" SimpleName = "</span> + personProxy.getClass().getSimpleName() + <span class="string">" name ="</span> + personProxy.getClass().getName() + <span class="string">" CanonicalName = "</span> + <span class="string">""</span> + personProxy.getClass().getCanonicalName() + <span class="string">" 实现的接口 Interfaces = "</span> + Arrays.toString(personProxy.getClass().getInterfaces()) + <span class="string">" superClass = "</span> + personProxy.getClass().getSuperclass() + <span class="string">" methods ="</span> + Arrays.toString(personProxy.getClass().getMethods()));        <span class="comment">// 通过 代理类 执行 委托类的代码逻辑</span></span><br><span class="line">        personProxy.goWorking(personProxy.getName(), <span class="string">"深圳"</span>);</span><br><span class="line">        System.out.println(<span class="string">"-------------------第二种创建代理类方法--------------"</span>);        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  动态代理对象步骤</span></span><br><span class="line"><span class="comment">         *      1、 创建一个与代理对象相关联的 InvocationHandler，以及真实的委托类实例</span></span><br><span class="line"><span class="comment">         *      2、Proxy类的getProxyClass静态方法生成一个动态代理类stuProxyClass，该类继承Proxy类，实现 Person.java接口；JDK动态代理的特点是代理类必须继承Proxy类</span></span><br><span class="line"><span class="comment">         *      3、通过代理类 proxyClass 获得他的带InvocationHandler 接口的构造函数 ProxyConstructor</span></span><br><span class="line"><span class="comment">         *      4、通过 构造函数实例 ProxyConstructor 实例化一个代理对象，并将  InvocationHandler 接口实例传递给代理类。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 1、创建 InvocationHandler 实例并设置代理的目标类对象</span></span><br><span class="line">        Person persontwo=<span class="keyword">new</span> SoftwareEngineer(<span class="string">"Vincent"</span>);</span><br><span class="line">        InvocationHandler Handlertwo=<span class="keyword">new</span> PersonInvocationHandler&lt;&gt;(persontwo);        <span class="comment">// 2 创建代理类,是一个字节码文件, 把 proxyClass 保存起来就能看到 他继承Proxy 类，实现Person接口</span></span><br><span class="line">        Class&lt;?&gt; proxyClass=Proxy.getProxyClass(Person.class.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;Person.class&#125;);        <span class="comment">/** 代理类信息 */</span></span><br><span class="line">        System.out.println(<span class="string">"package = "</span> + proxyClass.getPackage() + <span class="string">" SimpleName = "</span> + proxyClass.getSimpleName() + <span class="string">" name ="</span> + proxyClass.getName() + <span class="string">" CanonicalName = "</span> + <span class="string">""</span> + proxyClass.getCanonicalName() + <span class="string">" 实现的接口 Interfaces = "</span> + Arrays.toString(proxyClass.getInterfaces()) + <span class="string">" superClass = "</span> + proxyClass.getSuperclass() + <span class="string">" methods ="</span> + Arrays.toString(proxyClass.getMethods()));        <span class="comment">// 3、  通过 proxyClass 获得 一个带有InvocationHandler参数的构造器constructor</span></span><br><span class="line">        Constructor&lt;?&gt; ProxyConstructor=proxyClass.getConstructor(InvocationHandler.class);        <span class="comment">// 4、通过构造器创建一个  动态代理类 实例</span></span><br><span class="line">        Person stuProxy=(Person) ProxyConstructor.newInstance(Handlertwo);        <span class="comment">/** 检测生成的类是否是代理类 */</span></span><br><span class="line">        System.out.println(<span class="string">"stuProxy isProxy "</span> + Proxy.isProxyClass(stuProxy.getClass()));        <span class="comment">/** 获取 代理类关联的 InvocationHandler 是哪个*/</span></span><br><span class="line">        InvocationHandler handlerObject=Proxy.getInvocationHandler(stuProxy);</span><br><span class="line">        System.out.println(handlerObject.getClass().getName());</span><br><span class="line">        stuProxy.goWorking(stuProxy.getName(), <span class="string">"广州"</span>);        <span class="comment">// 保存代理類</span></span><br><span class="line">        saveClass(<span class="string">"$PersonProxy0"</span>, proxyClass.getInterfaces(), <span class="string">"D:/123/"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成代理类 class 并保持到文件中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> className  生成的代理类名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interfaces 代理类需要实现的接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pathdir    代理类保存的目录路径,以目录分隔符结尾</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">saveClass</span><span class="params">(String className, Class&lt;?&gt;[] interfaces, String pathdir)</span> </span>&#123;        <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第一个参数是 代理类 名 。</span></span><br><span class="line"><span class="comment">     * 第二个参数是 代理类需要实现的接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        <span class="keyword">byte</span>[] classFile=ProxyGenerator.generateProxyClass(className, interfaces);        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果目录不存在就新建所有子目录</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Path path1=Paths.get(pathdir);</span><br><span class="line">        <span class="keyword">if</span> (!path1.toFile().exists()) &#123;</span><br><span class="line">            path1.toFile().mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        String path=pathdir + className + <span class="string">".class"</span>;</span><br><span class="line">        <span class="keyword">try</span> (FileOutputStream fos=<span class="keyword">new</span> FileOutputStream(path)) &#123;</span><br><span class="line">            fos.write(classFile);</span><br><span class="line">            fos.flush();</span><br><span class="line">            System.out.println(<span class="string">"代理类class文件写入成功"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"写文件错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置保存Java动态代理生成的类文件。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">saveGeneratedJdkProxyFiles</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Field field=System.class.getDeclaredField(<span class="string">"props"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Properties props=(Properties) field.get(<span class="keyword">null</span>);</span><br><span class="line">        props.put(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.vincent.proxy.dynamicproxy.Person;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析JDK生成的动态代理类</span></span><br><span class="line"><span class="comment"> *         saveGeneratedJdkProxyFiles方法 打开了存储jdk生成的动态代理类 以 接口方法 goWorking 为例讲解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m4;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m5;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ((Boolean) <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;)).booleanValue();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String var1)</span> <span class="keyword">throws</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m4, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getName</span><span class="params">()</span> <span class="keyword">throws</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String) <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[]) <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String) <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[]) <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对接口  goWorking 的调用 转变成   super.h.invoke(this, m5, new Object[]&#123;var1, var2&#125;); 调用。</span></span><br><span class="line"><span class="comment">     * h 就是Proxy.java类的一个 InvocationHandler 接口 属性，</span></span><br><span class="line"><span class="comment">     * 我们在创建 动态代理类实例时候都必须 传一个 InvocationHandler 接口的实例过去。 这里就是刚才我们定义的 PersonInvocationHandler 。</span></span><br><span class="line"><span class="comment">     * 回到过后是不是就回到了 PersonInvocationHandler.invoke方法里面，所以 PersonInvocationHandler 是我们生成的动态代理类的拦截器，拦截所有方法调用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">goWorking</span><span class="params">(String var1, String var2)</span> <span class="keyword">throws</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m5, <span class="keyword">new</span> Object[]&#123;var1, var2&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var4;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var5);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ((Integer) <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[]) <span class="keyword">null</span>)).intValue();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态代码块，根据动态代理实现的公共接口类接口方法 获取到所有接口方法 的 Method 实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1=Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, <span class="keyword">new</span> Class[]&#123;Class.forName(<span class="string">"java.lang.Object"</span>)&#125;);</span><br><span class="line">            m4=Class.forName(<span class="string">"org.vincent.proxy.dynamicproxy.Person"</span>).getMethod(<span class="string">"setName"</span>, <span class="keyword">new</span> Class[]&#123;Class.forName(<span class="string">"java.lang.String"</span>)&#125;);</span><br><span class="line">            m3=Class.forName(<span class="string">"org.vincent.proxy.dynamicproxy.Person"</span>).getMethod(<span class="string">"getName"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">            m2=Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">            m5=Class.forName(<span class="string">"org.vincent.proxy.dynamicproxy.Person"</span>).getMethod(<span class="string">"goWorking"</span>, <span class="keyword">new</span> Class[]&#123;Class.forName(<span class="string">"java.lang.String"</span>), Class.forName(<span class="string">"java.lang.String"</span>)&#125;);</span><br><span class="line">            m0=Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK为我们的生成了一个叫$Proxy0（这个名字后面的0是编号，有多个代理类会一次递增）的代理类，这个类文件时默认不会保存在文件，放在内存中的，我们在创建代理对象时，就是通过反射获得这个类的构造方法，然后创建代理对象实例。通过对这个生成的代理类源码的查看，我们很容易能看出，动态代理实现的具体过程。</p>
<p>我们可以对 InvocationHandler 看做一个中介类，中介类持有一个被代理对象，被Proxy类回调。在invoke方法中调用了被代理对象的相应方法。通过聚合方式持有被代理对象的引用，把客户端对invoke的调用最终都转为对被代理对象的调用。</p>
<p>客户端代码通过代理类引用调用接口方法时，通过代理类关联的中介类对象引用来调用中介类对象的invoke方法，从而达到代理执行被代理对象的方法。也就是说，动态代理Proxy类提供了模板实现，对外提供扩展点，外部通过实现InvocationHandler接口将被代理类纳入JDK代理类Proxy。</p>
<p>一个典型的基于JDK动态代理创建对象过程可分为以下四个步骤：</p>
<ol>
<li><p>通过实现InvocationHandler接口创建自己的调用处理器 IvocationHandler handler = new InvocationHandlerImpl(…);</p>
</li>
<li><p>通过为Proxy类指定ClassLoader对象和一组interface代理类需要实现的接口，创建动态代理类类文件，默认JDK并不会保存这个文件到文件中；可以保存起来观察生成的代理类结构Class clazz = Proxy.getProxyClass(classLoader,new Class[]{…});</p>
</li>
<li><p>通过上面新建的代理clazz的反射机制获取动态代理类的一个构造函数，其构造函数入参类型是调用处理器接口(IvocationHandler)类型 Constructor constructor = clazz.getConstructor(new Class[]{InvocationHandler.class});</p>
</li>
<li><p>通过构造函数实例创建代理类实例，此时需将调用处理器对象作为参数被传入 Interface Proxy = (Interface)constructor.newInstance(new Object[] (handler)); 为了简化对象创建过程，Proxy类中的newInstance工具方法封装了2~4，只需两步即可完成代理对象的创建。</p>
</li>
</ol>
<h3 id="JDK动态代理特点总结"><a href="#JDK动态代理特点总结" class="headerlink" title="JDK动态代理特点总结"></a>JDK动态代理特点总结</h3><p>生成的代理类：$Proxy0 extends Proxy implements Person，我们看到代理类继承了Proxy类，Java的继承机制决定了JDK动态代理类们无法实现对 类 的动态代理。所以也就决定了java动态代理只能对接口进行代理，<br>每个生成的动态代理实例都会关联一个调用处理器对象，可以通过 Proxy 提供的静态方法 getInvocationHandler 去获得代理类实例的调用处理器对象。在代理类实例上调用其代理的接口中所声明的方法时，这些方法最终都会由调用处理器的 invoke 方法执行<br>代理类的根类 java.lang.Object 中有三个方法也同样会被分派到调用处理器的 invoke 方法执行，它们是 hashCode，equals 和 toString，可能的原因有：一是因为这些方法为 public 且非 final 类型，能够被代理类覆盖； 二是因为这些方法往往呈现出一个类的某种特征属性，具有一定的区分度，所以为了保证代理类与委托类对外的一致性，这三个方法也应该被调用处理器分派到委托类执行。<br>JDK动态代理不足<br>JDK动态代理的代理类字节码在创建时，需要实现业务实现类所实现的接口作为参数。如果业务实现类是没有实现接口而是直接定义业务方法的话，就无法使用JDK动态代理了。(JDK动态代理重要特点是代理接口) 并且，如果业务实现类中新增了接口中没有的方法，这些方法是无法被代理的（因为无法被调用）。</p>
<p>动态代理只能对接口产生代理，不能对类产生代理</p>
<p>基于CGlib 技术动态代理代理类实现 (基于继承)<br>Cglib是针对类来实现代理的，他的原理是对代理的目标类生成一个子类，并覆盖其中方法实现增强，因为底层是基于创建被代理类的一个子类，所以它避免了JDK动态代理类的缺陷。</p>
<p>但因为采用的是继承，所以不能对final修饰的类进行代理。final修饰的类不可继承。</p>
<p>导入maven 依赖<br>cglib 是基于asm 字节修改技术。导入 cglib 会间接导入 asm, ant, ant-launcher 三个jar 包。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- cglib 动态代理依赖 begin --&gt;</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;cglib&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;3.2.5&lt;/version&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br><span class="line">&lt;!-- cglib 动态代理依赖 stop --&gt;</span><br></pre></td></tr></table></figure>

<p>业务类实现<br>cglib是针对类来实现代理的，原理是对指定的业务类生成他的一个子类，并覆盖其中的业务方法来实现代理。因为采用的是继承，所以不能对final修饰的类进行代理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>： Cglib 代理模式中 被代理的委托类 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: 1.0 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By: </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"wang wang wang"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Dog .."</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>： Cglib 方法拦截器,不用依赖被代理业务类的引用。   </span></span><br><span class="line"><span class="comment"> * 方法拦截器 实现 MethodInterceptor 接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Company</span>: PLCC  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Copyright</span>: Copyright (c) 2019  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span>: 1.0  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Modified</span> By:  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Created</span> by lenovo on 2018/12/26-17:56  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于生成 Cglib 动态代理类工具方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 代表需要 被代理的 委托类的 Class 对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">CglibProxyGeneratory</span><span class="params">(Class target)</span> </span>&#123;        <span class="comment">/** 创建cglib 代理类 start */</span></span><br><span class="line">        <span class="comment">// 创建加强器，用来创建动态代理类</span></span><br><span class="line">        Enhancer enhancer=<span class="keyword">new</span> Enhancer();        <span class="comment">// 为代理类指定需要代理的类，也即是父类</span></span><br><span class="line">        enhancer.setSuperclass(target);        <span class="comment">// 设置方法拦截器回调引用，对于代理类上所有方法的调用，都会调用CallBack，而Callback则需要实现intercept() 方法进行拦截</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);        <span class="comment">// 获取动态代理类对象并返回</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();        <span class="comment">/** 创建cglib 代理类 end */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能主要是在调用业务类方法之前 之后添加统计时间的方法逻辑.</span></span><br><span class="line"><span class="comment">     * intercept 因为  具有 MethodProxy proxy 参数的原因 不再需要代理类的引用对象了,直接通过proxy 对象访问被代理对象的方法(这种方式更快)。</span></span><br><span class="line"><span class="comment">     * 当然 也可以通过反射机制，通过 method 引用实例    Object result = method.invoke(target, args); 形式反射调用被代理类方法，</span></span><br><span class="line"><span class="comment">     * target 实例代表被代理类对象引用, 初始化 CglibMethodInterceptor 时候被赋值 。但是Cglib不推荐使用这种方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj    代表Cglib 生成的动态代理类 对象本身</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 代理类中被拦截的接口方法 Method 实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args   接口方法参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy  用于调用父类真正的业务类方法。可以直接调用被代理类接口方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before"</span>);</span><br><span class="line">        MonitorUtil.start();</span><br><span class="line">        Object result=proxy.invokeSuper(obj, args);        <span class="comment">//Object result = method.invoke(target, args);</span></span><br><span class="line">        System.out.println(<span class="string">"after"</span>);</span><br><span class="line">        MonitorUtil.finish(method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个切面，用于在方法拦截器中intercept 方法中调用真正业务方法之前 之后处理逻辑</span></span><br><span class="line"><span class="comment"> * 方法用时监控类,作为一个切面 ，具有两个方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Long&gt; tl=<span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        tl.set(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结束时打印耗时</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodName 方法名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(String methodName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> finishTime=System.currentTimeMillis();</span><br><span class="line">        System.out.println(methodName + <span class="string">"方法执行耗时"</span> + (finishTime - tl.get()) + <span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.core.DebuggingClassWriter;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cglib测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCglib</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(System.getProperty(<span class="string">"user.dir"</span>));        <span class="comment">/** 开启 保存cglib生成的动态代理类类文件*/</span></span><br><span class="line">        saveGeneratedCGlibProxyFiles(System.getProperty(<span class="string">"user.dir"</span>));        <span class="comment">/** 第一种方法: 创建cglib 代理类 start */</span></span><br><span class="line">        <span class="comment">// 创建加强器，用来创建动态代理类</span></span><br><span class="line">        Enhancer enhancer=<span class="keyword">new</span> Enhancer();        <span class="comment">// 为代理类指定需要代理的类，也即是父类</span></span><br><span class="line">        enhancer.setSuperclass(Dog.class);        <span class="comment">// new 一个新的方法拦截器</span></span><br><span class="line">        CglibMethodInterceptor cglibMethodInterceptor=<span class="keyword">new</span> CglibMethodInterceptor();        <span class="comment">// 设置方法拦截器回调引用，对于代理类上所有方法的调用，都会调用CallBack，而Callback则需要实现intercept() 方法进行拦截</span></span><br><span class="line">        enhancer.setCallback(cglibMethodInterceptor);        <span class="comment">// 获取动态代理类对象并返回</span></span><br><span class="line">        Dog dog=(Dog) enhancer.create();        <span class="comment">/** 创建cglib 代理类 end */</span></span><br><span class="line">        System.out.println(dog.call());        <span class="comment">// 对于上面这几步，可以新增一个工具方法 放置在 CglibMethodInterceptor 里面；也就有了第二种方法</span></span><br><span class="line">        <span class="comment">// new 一个新的方法拦截器，该拦截器还顺带一个用于创建代理类的工具方法。看起来简单很多</span></span><br><span class="line">        cglibMethodInterceptor=<span class="keyword">new</span> CglibMethodInterceptor();</span><br><span class="line">        dog=(Dog) cglibMethodInterceptor.CglibProxyGeneratory(Dog.class);</span><br><span class="line">        System.out.println(dog.call());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置保存Cglib代理生成的类文件。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveGeneratedCGlibProxyFiles</span><span class="params">(String dir)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Field field=System.class.getDeclaredField(<span class="string">"props"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Properties props=(Properties) field.get(<span class="keyword">null</span>);</span><br><span class="line">        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, dir);<span class="comment">//dir为保存文件路径</span></span><br><span class="line">        props.put(<span class="string">"net.sf.cglib.core.DebuggingClassWriter.traceEnabled"</span>, <span class="string">"true"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Cglib-总结"><a href="#Cglib-总结" class="headerlink" title="Cglib 总结"></a>Cglib 总结</h3><p>CGlib可以传入接口也可以传入普通的类，接口使用实现的方式,普通类使用会使用继承的方式生成代理类.<br>由于是继承方式,如果是 static方法,private方法,final方法等描述的方法是不能被代理的<br>做了方法访问优化，使用建立方法索引的方式避免了传统JDK动态代理需要通过Method方法反射调用.<br>提供callback 和filter设计，可以灵活地给不同的方法绑定不同的callback。编码更方便灵活。<br>CGLIB会默认代理Object中equals,toString,hashCode,clone等方法。比JDK代理多了clone。<br>静态代理 基于JDK动态代理 基于Cglib 动态代理<br>静态代理是通过在代码中显式编码定义一个业务实现类的代理类，在代理类中对同名的业务方法进行包装，用户通过代理类调用被包装过的业务方法；</p>
<p>JDK动态代理是通过接口中的方法名，在动态生成的代理类中调用业务实现类的同名方法；</p>
<p>CGlib动态代理是通过继承业务类，生成的动态代理类是业务类的子类，通过重写业务方法进行代理；</p>
<p>静态代理在编译时产生class字节码文件，可以直接使用，效率高。动态代理必须实现InvocationHandler接口，通过invoke调用被委托类接口方法是通过反射方式，比较消耗系统性能，但可以减少代理类的数量，使用更灵活。 cglib代理无需实现接口，通过生成类字节码实现代理，比反射稍快，不存在性能问题，但cglib会继承目标对象，需要重写方法，所以目标对象不能为final类。</p>
<h3 id="AOP-实现案例"><a href="#AOP-实现案例" class="headerlink" title="AOP 实现案例"></a>AOP 实现案例</h3><p>AOP的源码中用到了两种动态代理来实现拦截切入功能：jdk动态代理和cglib动态代理。两种方法同时存在，各有优劣。 jdk动态代理是由java内部的反射机制来实现的，cglib动态代理底层则是借助asm来实现的。 总的来说，反射机制在生成类的过程中比较高效，执行时候通过反射调用委托类接口方法比较慢；而asm在生成类之后的相关代理类执行过程中比较高效（可以通过将asm生成的类进行缓存，这样解决asm生成类过程低效问题）。 还有一点必须注意：jdk动态代理的应用前提，必须是委托类基于统一的接口。如果没有上述前提，jdk动态代理不能应用。 由此可以看出，jdk动态代理有一定的局限性，cglib这种第三方类库实现的动态代理应用更加广泛，且在效率上更有优势。</p>
<p>实现AOP关键特点是定义好两个角色 切点 和 切面 。 代理模式中被代理类 委托类处于切点角色，需要添加的其他比如 校验逻辑，事务，审计逻辑 属于非功能实现逻辑通过 切面类定义的方法插入进去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JDK动态代理 aop 实现方式</span></span><br><span class="line"><span class="comment"> * 定义切面接口，完成将通用公共方法注入到被代理类接口调用处理中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAspect</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在切点接口方法执行之前执行</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 切点参数列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">startTransaction</span><span class="params">(Object... args)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在切点接口方法执行之后执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">endTrasaction</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义切面实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomAspect</span> <span class="keyword">implements</span> <span class="title">IAspect</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对参数 做判空处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 切点参数列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startTransaction</span><span class="params">(Object... args)</span> </span>&#123;</span><br><span class="line">        Objects.nonNull(args);</span><br><span class="line">        <span class="keyword">boolean</span> result=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (Object temp : args) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Objects.isNull(temp)) &#123;</span><br><span class="line">                result=<span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endTrasaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I get datasource here and end transaction"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义切点角色接口 因为是基于JDK实现的Aop ，所以委托类需要基于接口实现。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 委托类实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">IUserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"save user[username="</span> + username + <span class="string">",password="</span> + password + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK动态代理生成器工具类<br>可以看到 generatorJDKProxy 方法入参只有两个参数 一个切点接口引用，一个切面接口引用；在InvocationHandler 内部类中可以完整看到切面类方法是怎么影响切点代码执行逻辑的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>： JDK动态代理类生成器 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKDynamicProxyGenerator</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetPoint 需要被代理的委托类对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> aspect      切面对象,该对象方法将在切点方法之前或之后执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">generatorJDKProxy</span><span class="params">(IUserService targetPoint, <span class="keyword">final</span> IAspect aspect)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 *   委托类使用的类加载器</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                targetPoint.getClass().getClassLoader(),                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 委托类实现的接口</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                targetPoint.getClass().getInterfaces(),                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 生成的动态代理类关联的 执行处理器，代理我们的业务逻辑被生成的动态代理类回调</span></span><br><span class="line"><span class="comment">                 * 具体逻辑代码执行,返回值为方法执行结果, 在aop模型中，委托类的接口方法称为切点。</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;                        <span class="comment">// 执行切面方法,对入参进行校验</span></span><br><span class="line">                        <span class="keyword">boolean</span> prepareAction=aspect.startTransaction(args);</span><br><span class="line">                        <span class="keyword">if</span> (prepareAction) &#123;                           <span class="comment">// 具体逻辑代码执行,返回值为方法执行结果</span></span><br><span class="line">                            Object result=method.invoke(targetPoint, args);</span><br><span class="line">                            aspect.endTrasaction();</span><br><span class="line">                            <span class="keyword">return</span> result;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"args: "</span> + Arrays.toString(args) + <span class="string">"不能为null "</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testAopJDKProxy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJDKProxy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"无代理前 调用方法 userService.saveUser 输出......"</span>);</span><br><span class="line">        IUserService userService=<span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        userService.saveUser(<span class="string">"zby"</span>, <span class="string">"1234567890"</span>);</span><br><span class="line">        System.out.println(<span class="string">"有代理后AOP 是怎么样的？ Proxy......"</span>);</span><br><span class="line">        IUserService proxyUserService=(IUserService) JDKDynamicProxyGenerator.generatorJDKProxy(userService, <span class="keyword">new</span> CustomAspect());</span><br><span class="line">        proxyUserService.saveUser(<span class="string">"zby"</span>, <span class="string">"1234567890"</span>);        <span class="comment">/** 制造异常,两个入参都是null   */</span></span><br><span class="line">        proxyUserService.saveUser(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cglib aop 实现方式</span></span><br><span class="line"><span class="comment"> * 定义切面接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>： 定义切面接口，切面接口定义了两个切面方法，分别在切点接口方法执行前和执行后执行 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAspect</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在切点接口方法执行之前执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startTransaction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在切点接口方法执行之后执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">endTrasaction</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>： 改类作为AOP 模型中切面角色类， 实现切面接口，切面接口定义了两个切面方法，分别在切点接口方法执行前和执行后执行 。 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * 切面实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomAspect</span> <span class="keyword">implements</span> <span class="title">IAspect</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"cglib. I get datasource here and start transaction"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endTrasaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"cglib I get datasource here and end transaction"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Cglib 是基于类实现的动态代理即业务类只需要实现类即可，不用强制必须实现某个接口为了突出这个优点这里没有实现接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>： 业务实现类UserServiceImpl 该类 作为AOP中切点角色，切面定义的方法插入到切点的接口方法 执行前和执行后执行。 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">IUserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"cglib save user[username="</span> + username + <span class="string">",password="</span> + password + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Package</span>: Cglib 动态代理生成器工具类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>： 基于Cglib代理类生成器工具类 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxyGenerator</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 需要被代理的委托类对象，Cglib需要继承该类生成子类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> aspect 切面对象,改对象方法将在切点方法之前或之后执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">generatorCglibProxy</span><span class="params">(<span class="keyword">final</span> Object target, <span class="keyword">final</span> IAspect aspect)</span> </span>&#123;        <span class="comment">//3.1 new Enhancer</span></span><br><span class="line">        Enhancer enhancer=<span class="keyword">new</span> Enhancer();        <span class="comment">//3.2 设置需要代理的父类</span></span><br><span class="line">        enhancer.setSuperclass(target.getClass());        <span class="comment">//3.3 设置回调</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span></span></span><br><span class="line"><span class="function">                    <span class="keyword">throws</span> Throwable </span>&#123;                <span class="comment">// 执行切面方法</span></span><br><span class="line">                aspect.startTransaction();                <span class="comment">// 具体逻辑代码执行,返回值为方法执行结果</span></span><br><span class="line">                Object result=methodProxy.invokeSuper(proxy, args);                <span class="comment">// 执行切面方法</span></span><br><span class="line">                aspect.endTrasaction();                <span class="comment">// 返回方法执行结果</span></span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);        <span class="comment">// 3.4 创建代理对象</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>： 基于动态代理类AOP测试案例 </span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testAopCglibKProxy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCglibProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before Proxy......"</span>);</span><br><span class="line">        UserServiceImpl userService=<span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        userService.saveUser(<span class="string">"zby"</span>, <span class="string">"1234567890"</span>);</span><br><span class="line">        System.out.println(<span class="string">"引入Cglib  Proxy代理库 后......"</span>);</span><br><span class="line">        UserServiceImpl proxyUserService=(UserServiceImpl) CglibProxyGenerator.generatorCglibProxy(userService, <span class="keyword">new</span> CustomAspect());</span><br><span class="line">        proxyUserService.saveUser(<span class="string">"zby"</span>, <span class="string">"1234567890"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AspectJ-实现-AOP-效果"><a href="#AspectJ-实现-AOP-效果" class="headerlink" title="AspectJ 实现 AOP 效果"></a>AspectJ 实现 AOP 效果</h3><p>AOP 实现的关键就在于 AOP 框架自动创建的 AOP 代理，AOP 代理则可分为静态代理和动态代理两大类:</p>
<p>静态代理是指使用 AOP 框架提供的命令进行编译，从而在编译阶段通过AOP框架指令生成 AOP 代理类，因此也称为编译时增强；还有一种静态代理是编写代码实现不用工具；这种方式一般是代理模式会使用。<br>动态代理则在运行时借助于 JDK 动态代理、CGLIB 等在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。<br>基于 AspectJ 的编译时增强进行 AOP POM 依赖<br>原生 AspectJ 不依赖Spring案例, 基于 AspectJ 的编译时增强进行 AOP 它是在编译期修改字节码，增强功能；并不会生成新的代理类字节码。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!-- AspectJ begin--&gt;&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;1.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- AspectJ stop--&gt;</span><br></pre></td></tr></table></figure>

<h3 id="动态代理-使用场景"><a href="#动态代理-使用场景" class="headerlink" title="动态代理 使用场景"></a>动态代理 使用场景</h3><ol>
<li>日志集中打印</li>
<li>事务</li>
<li>权限管理</li>
<li>AOP</li>
</ol>
<h3 id="SpringAop-什么时候调用jdk动态代理？什么时候调用cglib"><a href="#SpringAop-什么时候调用jdk动态代理？什么时候调用cglib" class="headerlink" title="SpringAop 什么时候调用jdk动态代理？什么时候调用cglib"></a>SpringAop 什么时候调用jdk动态代理？什么时候调用cglib</h3><ol>
<li>导入log4j.jar，开启log4j DEBUG模式</li>
</ol>
<ol start="2">
<li>查看打印日志，可以发现一个重要信息：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span>-<span class="number">03</span>-<span class="number">03</span> <span class="number">15</span>:<span class="number">13</span>:<span class="number">31</span>,<span class="number">870</span> DEBUG [org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator] - Creating implicit proxy <span class="keyword">for</span> bean <span class="string">'userService'</span> with <span class="number">0</span> common interceptors and <span class="number">4</span> specific interceptors</span><br><span class="line">spring再执行aop时，执行了 AnnotationAwareAspectJAutoProxyCreator 类中的某个方法</span><br></pre></td></tr></table></figure>


<ol start="3">
<li>通过 AnnotationAwareAspectJAutoProxyCreator 找到最终执行的是其父类 AbstractAutoProxyCreator 中的 protected Advisor[] buildAdvisors(String beanName, Object[] specificInterceptors) 方法</li>
</ol>
<ol start="4">
<li>重新在 buildAdvisors 这个方法打断点进行调试</li>
</ol>
<ol start="5">
<li>AbstractAutoProxyCreator 类中发现有一个重要的方法createProxy 如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createProxy</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">           Class&lt;?&gt; beanClass,String beanName,Object[]specificInterceptors,TargetSource targetSource)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ConfigurableListableBeanFactory)&#123;</span><br><span class="line">           AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory)<span class="keyword">this</span>.beanFactory,beanName,beanClass);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ProxyFactory proxyFactory=<span class="keyword">new</span> ProxyFactory();</span><br><span class="line">       proxyFactory.copyFrom(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(!proxyFactory.isProxyTargetClass())&#123;</span><br><span class="line">           <span class="keyword">if</span>(shouldProxyTargetClass(beanClass,beanName))&#123;</span><br><span class="line">               proxyFactory.setProxyTargetClass(<span class="keyword">true</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span>&#123;</span><br><span class="line">               evaluateProxyInterfaces(beanClass,proxyFactory);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Advisor[]advisors=buildAdvisors(beanName,specificInterceptors);</span><br><span class="line">       proxyFactory.addAdvisors(advisors);</span><br><span class="line">       proxyFactory.setTargetSource(targetSource);</span><br><span class="line">       customizeProxyFactory(proxyFactory);</span><br><span class="line"></span><br><span class="line">       proxyFactory.setFrozen(<span class="keyword">this</span>.freezeProxy);</span><br><span class="line">       <span class="keyword">if</span>(advisorsPreFiltered())&#123;</span><br><span class="line">           proxyFactory.setPreFiltered(<span class="keyword">true</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 核心代码</span></span><br><span class="line">       <span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>接着进入 ProxyFactory 中的 getProxy 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// createAopProxy 方法中判断是选择jdk动态代理还是cglib方式代理</span></span><br><span class="line">        <span class="keyword">return</span> createAopProxy().getProxy(classLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">再进入到 ProxyCreatorSupport 中的 createAopProxy 方法</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> AopProxy <span class="title">createAopProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.active) &#123;</span><br><span class="line">            activate();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// getAopProxyFactory() 返回的是 DefaultAopProxyFactory对象，所以重点还是在 createAopProxy 方法上</span></span><br><span class="line">        <span class="keyword">return</span> getAopProxyFactory().createAopProxy(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<ol start="6">
<li>进入到 DefaultAopProxyFactory 类中的 createAopProxy 方法，这个方法就是如何选择JDK动态代理还是Cglib代理</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.config.isProxyTargetClass() 代表 配置中的proxy-target-class属性true/false，默认false</span></span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">            <span class="comment">// 目标代理类，如 com.service.impl.UserServiceImpl</span></span><br><span class="line">            Class&lt;?&gt; targetClass=config.getTargetClass();</span><br><span class="line">            <span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</span><br><span class="line">                        <span class="string">"Either an interface or a target is required for proxy creation."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 目标类如果是一个接口 或 </span></span><br><span class="line">            <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>方法中参数config 是一个 AdvisedSupport类型， AdvisedSupport 继承了 ProxyConfig 类，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyConfig</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 代表 配置中的proxy-target-class，如果设置true，则使用Cglib方式代理</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> proxyTargetClass=<span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> optimize=<span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> opaque=<span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> exposeProxy=<span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> frozen=<span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>高并发</tag>
        <tag>ThreadLocal</tag>
      </tags>
  </entry>
</search>
